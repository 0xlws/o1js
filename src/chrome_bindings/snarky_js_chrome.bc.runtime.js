// Generated by js_of_ocaml 3.7.1
(function(joo_global_object)
   {(function()
       {var
         DefaultLocale=
          {days:
           ["Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"],
           shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
           months:
           ["January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"],
           shortMonths:
           ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"],
           AM:"AM",
           PM:"PM",
           am:"am",
           pm:"pm",
           formats:
           {D:"%m/%d/%y",
            F:"%Y-%m-%d",
            R:"%H:%M",
            T:"%H:%M:%S",
            X:"%T",
            c:"%a %b %d %X %Y",
            r:"%I:%M:%S %p",
            v:"%e-%b-%Y",
            x:"%D"}},
         defaultStrftime=new Strftime(DefaultLocale,0,false),
         isCommonJS=typeof module !== "undefined",
         namespace;
        if(isCommonJS)
         {namespace = module.exports = adaptedStrftime;
          namespace.strftime = deprecatedStrftime;
          if(joo_global_object)joo_global_object.strftime = adaptedStrftime}
        else
         {namespace
          =
          joo_global_object
          ||
          function(){return this || (1,eval)("this")}();
          namespace.strftime = adaptedStrftime}
        var
         _require=isCommonJS?"require('strftime')":"strftime",
         _deprecationWarnings={};
        function deprecationWarning(name,instead)
         {if(! _deprecationWarnings[name])
           {if
             (typeof console
              !==
              "undefined"
              &&
              typeof console.warn
              ==
              "function")
             console.warn
              ("[WARNING] "
               +
               name
               +
               " is deprecated and will be removed in version 1.0. Instead, use `"
               +
               instead
               +
               "`.");
            _deprecationWarnings[name] = true}}
        namespace.strftimeTZ = deprecatedStrftimeTZ;
        namespace.strftimeUTC = deprecatedStrftimeUTC;
        namespace.localizedStrftime = deprecatedStrftimeLocalized;
        function adaptForwards(fn)
         {fn.localize = defaultStrftime.localize.bind(defaultStrftime);
          fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
          fn.utc = defaultStrftime.utc.bind(defaultStrftime)}
        adaptForwards(adaptedStrftime);
        function adaptedStrftime(fmt,d,locale)
         {if(d && d.days){locale = d;d = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + "(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        adaptForwards(deprecatedStrftime);
        function deprecatedStrftime(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftime(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftime(format, [date])`",
             _require + "(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeTZ(fmt,d,locale,timezone)
         {if
           ((typeof locale == "number" || typeof locale == "string")
            &&
            timezone
            ==
            null)
           {timezone = locale;locale = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
             +
             _require
             +
             ".localize(locale); s.timezone(tz)(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, tz)`",
             "var s = "
             +
             _require
             +
             ".timezone(tz); s(format, [date])` or `"
             +
             _require
             +
             ".timezone(tz)(format, [date])");
          var
           strftime=
            (locale?defaultStrftime.localize(locale):defaultStrftime).timezone
             (timezone);
          return strftime(fmt,d)}
        var utcStrftime=defaultStrftime.utc();
        function deprecatedStrftimeUTC(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, date, locale)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).utc(); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, [date])`",
             "var s = " + _require + ".utc(); s(format, [date])");
          var strftime=locale?utcStrftime.localize(locale):utcStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeLocalized(locale)
         {deprecationWarning
           ("`" + _require + ".localizedStrftime(locale)`",
            _require + ".localize(locale)");
          return defaultStrftime.localize(locale)}
        if(typeof Date.now !== "function")
         Date.now = function(){return + new Date()};
        function Strftime(locale,customTimezoneOffset,useUtcTimezone)
         {var
           _locale=locale || DefaultLocale,
           _customTimezoneOffset=customTimezoneOffset || 0,
           _useUtcBasedDate=useUtcTimezone || false,
           _cachedDateTimestamp=0,
           _cachedDate;
          function _strftime(format,date)
           {var timestamp;
            if(! date)
             {var currentTimestamp=Date.now();
              if(currentTimestamp > _cachedDateTimestamp)
               {_cachedDateTimestamp = currentTimestamp;
                _cachedDate = new Date(_cachedDateTimestamp);
                timestamp = _cachedDateTimestamp;
                if(_useUtcBasedDate)
                 _cachedDate
                 =
                 new
                  Date
                  (_cachedDateTimestamp
                   +
                   getTimestampToUtcOffsetFor(_cachedDate)
                   +
                   _customTimezoneOffset)}
              date = _cachedDate}
            else
             {timestamp = date.getTime();
              if(_useUtcBasedDate)
               date
               =
               new
                Date
                (date.getTime()
                 +
                 getTimestampToUtcOffsetFor(date)
                 +
                 _customTimezoneOffset)}
            return _processFormat(format,date,_locale,timestamp)}
          function _processFormat(format,date,locale,timestamp)
           {var
             resultString="",
             padding=null,
             isInScope=false,
             length=format.length,
             extendedTZ=false;
            for(var i=0;i < length;i++)
             {var currentCharCode=format.charCodeAt(i);
              if(isInScope === true)
               {if(currentCharCode === 45)
                 {padding = "";continue}
                else
                 if(currentCharCode === 95)
                  {padding = " ";continue}
                 else
                  if(currentCharCode === 48)
                   {padding = "0";continue}
                  else
                   if(currentCharCode === 58)
                    {if(extendedTZ)
                      if
                       (typeof console
                        !==
                        "undefined"
                        &&
                        typeof console.warn
                        ==
                        "function")
                       console.warn
                        ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                     extendedTZ = true;
                     continue}
                switch(currentCharCode)
                 {case 65:resultString += locale.days[date.getDay()];break;
                  case 66:
                   resultString += locale.months[date.getMonth()];break;
                  case 67:
                   resultString
                   +=
                   padTill2(Math.floor(date.getFullYear() / 100),padding);
                   break;
                  case 68:
                   resultString
                   +=
                   _processFormat(locale.formats.D,date,locale,timestamp);
                   break;
                  case 70:
                   resultString
                   +=
                   _processFormat(locale.formats.F,date,locale,timestamp);
                   break;
                  case 72:
                   resultString += padTill2(date.getHours(),padding);break;
                  case 73:
                   resultString += padTill2(hours12(date.getHours()),padding);
                   break;
                  case 76:
                   resultString += padTill3(Math.floor(timestamp % 1000));
                   break;
                  case 77:
                   resultString += padTill2(date.getMinutes(),padding);break;
                  case 80:
                   resultString += date.getHours() < 12?locale.am:locale.pm;
                   break;
                  case 82:
                   resultString
                   +=
                   _processFormat(locale.formats.R,date,locale,timestamp);
                   break;
                  case 83:
                   resultString += padTill2(date.getSeconds(),padding);break;
                  case 84:
                   resultString
                   +=
                   _processFormat(locale.formats.T,date,locale,timestamp);
                   break;
                  case 85:
                   resultString += padTill2(weekNumber(date,"sunday"),padding);
                   break;
                  case 87:
                   resultString += padTill2(weekNumber(date,"monday"),padding);
                   break;
                  case 88:
                   resultString
                   +=
                   _processFormat(locale.formats.X,date,locale,timestamp);
                   break;
                  case 89:resultString += date.getFullYear();break;
                  case 90:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += "GMT";
                   else
                    {var tzString=date.toString().match(/\(([\w\s]+)\)/);
                     resultString += tzString && tzString[1] || ""}
                   break;
                  case 97:
                   resultString += locale.shortDays[date.getDay()];break;
                  case 98:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 99:
                   resultString
                   +=
                   _processFormat(locale.formats.c,date,locale,timestamp);
                   break;
                  case 100:
                   resultString += padTill2(date.getDate(),padding);break;
                  case 101:
                   resultString
                   +=
                   padTill2(date.getDate(),padding == null?" ":padding);
                   break;
                  case 104:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 106:
                   var
                    y=new Date(date.getFullYear(),0,1),
                    day=
                     Math.ceil
                      ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                   resultString += padTill3(day);
                   break;
                  case 107:
                   resultString
                   +=
                   padTill2(date.getHours(),padding == null?" ":padding);
                   break;
                  case 108:
                   resultString
                   +=
                   padTill2
                    (hours12(date.getHours()),padding == null?" ":padding);
                   break;
                  case 109:
                   resultString += padTill2(date.getMonth() + 1,padding);break;
                  case 110:resultString += "\n";break;
                  case 111:
                   resultString
                   +=
                   String(date.getDate())
                   +
                   ordinal(date.getDate());
                   break;
                  case 112:
                   resultString += date.getHours() < 12?locale.AM:locale.PM;
                   break;
                  case 114:
                   resultString
                   +=
                   _processFormat(locale.formats.r,date,locale,timestamp);
                   break;
                  case 115:resultString += Math.floor(timestamp / 1000);break;
                  case 116:resultString += "\t";break;
                  case 117:
                   var day=date.getDay();resultString += day === 0?7:day;break;
                  case 118:
                   resultString
                   +=
                   _processFormat(locale.formats.v,date,locale,timestamp);
                   break;
                  case 119:resultString += date.getDay();break;
                  case 120:
                   resultString
                   +=
                   _processFormat(locale.formats.x,date,locale,timestamp);
                   break;
                  case 121:
                   resultString += ("" + date.getFullYear()).slice(2);break;
                  case 122:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += extendedTZ?"+00:00":"+0000";
                   else
                    {var off;
                     if(_customTimezoneOffset !== 0)
                      off = _customTimezoneOffset / (60 * 1000);
                     else
                      off = - date.getTimezoneOffset();
                     var
                      sign=off < 0?"-":"+",
                      sep=extendedTZ?":":"",
                      hours=Math.floor(Math.abs(off / 60)),
                      mins=Math.abs(off % 60);
                     resultString
                     +=
                     sign
                     +
                     padTill2(hours)
                     +
                     sep
                     +
                     padTill2(mins)}
                   break;
                  default:resultString += format[i];break}
                padding = null;
                isInScope = false;
                continue}
              if(currentCharCode === 37){isInScope = true;continue}
              resultString += format[i]}
            return resultString}
          var strftime=_strftime;
          strftime.localize
          =
          function(locale)
           {return new
                    Strftime
                    (locale || _locale,_customTimezoneOffset,_useUtcBasedDate)};
          strftime.timezone
          =
          function(timezone)
           {var
             customTimezoneOffset=_customTimezoneOffset,
             useUtcBasedDate=_useUtcBasedDate,
             timezoneType=typeof timezone;
            if(timezoneType === "number" || timezoneType === "string")
             {useUtcBasedDate = true;
              if(timezoneType === "string")
               {var
                 sign=timezone[0] === "-"?- 1:1,
                 hours=parseInt(timezone.slice(1,3),10),
                 minutes=parseInt(timezone.slice(3,5),10);
                customTimezoneOffset
                =
                sign
                *
                (60 * hours + minutes)
                *
                60
                *
                1000}
              else
               if(timezoneType === "number")
                customTimezoneOffset = timezone * 60 * 1000}
            return new Strftime(_locale,customTimezoneOffset,useUtcBasedDate)};
          strftime.utc
          =
          function(){return new Strftime(_locale,_customTimezoneOffset,true)};
          return strftime}
        function padTill2(numberToPad,paddingChar)
         {if(paddingChar === "" || numberToPad > 9)return numberToPad;
          if(paddingChar == null)paddingChar = "0";
          return paddingChar + numberToPad}
        function padTill3(numberToPad)
         {if(numberToPad > 99)return numberToPad;
          if(numberToPad > 9)return "0" + numberToPad;
          return "00" + numberToPad}
        function hours12(hour)
         {if(hour === 0)return 12;else if(hour > 12)return hour - 12;
          return hour}
        function weekNumber(date,firstWeekday)
         {firstWeekday = firstWeekday || "sunday";
          var weekday=date.getDay();
          if(firstWeekday === "monday")
           if(weekday === 0)weekday = 6;else weekday--;
          var
           firstDayOfYearUtc=Date.UTC(date.getFullYear(),0,1),
           dateUtc=Date.UTC(date.getFullYear(),date.getMonth(),date.getDate()),
           yday=Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
           weekNum=(yday + 7 - weekday) / 7;
          return Math.floor(weekNum)}
        function ordinal(number)
         {var i=number % 10,ii=number % 100;
          if(ii >= 11 && ii <= 13 || i === 0 || i >= 4)return "th";
          switch(i){case 1:return "st";case 2:return "nd";case 3:return "rd"}}
        function getTimestampToUtcOffsetFor(date)
         {return (date.getTimezoneOffset() || 0) * 60000}}
      ())}
  (function(){return this}()));
(function(joo_global_object)
   {"use strict";
    var plonk_wasm=joo_global_object.plonk_wasm;
    function rust_affine_to_caml_affine(pt)
     {var infinity=pt.infinity;
      if(infinity)
       {pt.free();return 0}
      else
       {var x=pt.x,y=pt.y;pt.free();return [0,[0,x,y]]}}
    function js_class_vector_of_rust_vector(v,klass)
     {var len=v.length,res=new Array(len);
      for(var i=0,pos=0;i < len;i++)res[i] = klass.__wrap(v[i]);
      return res}
    function caml_array_of_rust_vector(v,klass,convert,should_free)
     {v = js_class_vector_of_rust_vector(v,klass);
      var len=v.length,res=new Array(len + 1);
      res[0] = 0;
      for(var i=0;i < len;i++)
       {var rust_val=v[i];
        res[i + 1] = convert(rust_val);
        if(should_free)rust_val.free()}
      return res}
    function caml_poly_comm_of_rust_poly_comm(poly_comm,klass,should_free)
     {var
       rust_shifted=poly_comm.shifted,
       rust_unshifted=poly_comm.unshifted,
       caml_shifted;
      if(rust_shifted === undefined)
       caml_shifted = 0;
      else
       caml_shifted = [0,rust_affine_to_caml_affine(rust_shifted)];
      var
       caml_unshifted=
        caml_array_of_rust_vector
         (rust_unshifted,klass,rust_affine_to_caml_affine,should_free);
      return [0,caml_unshifted,caml_shifted]}
    function caml_vesta_poly_comm_of_rust(x)
     {return caml_poly_comm_of_rust_poly_comm(x,plonk_wasm.WasmGVesta,false)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_pallas_poly_comm_of_rust(x)
     {return caml_poly_comm_of_rust_poly_comm(x,plonk_wasm.WasmGPallas,false)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    var caml_global_data=[0];
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    var
     free_finalization_registry=
      new
       (joo_global_object.FinalizationRegistry)
       (function(instance_representative){instance_representative.free()});
    function free_on_finalize(x)
     {var instance_representative=x.constructor.__wrap(x.ptr);
      free_finalization_registry.register(x,instance_representative,x);
      return x}
    function caml_plonk_domain_to_rust(x,klass){return new klass(x[1],x[2])}
    function rust_affine_of_caml_affine(pt,klass)
     {var res=new klass();
      if(pt === 0)res.infinity = true;else{res.x = pt[1][1];res.y = pt[1][2]}
      return res}
    function js_class_vector_to_rust_vector(v)
     {var len=v.length,res=new (joo_global_object.Uint32Array)(len);
      for(var i=0;i < len;i++)res[i] = v[i].ptr;
      return res}
    function caml_array_to_rust_vector(v,convert,mk_new)
     {v = v.slice(1);
      for(var i=0,l=v.length;i < l;i++)
       {var class_val=convert(v[i],mk_new);
        v[i] = class_val;
        free_finalization_registry.unregister(class_val)}
      return js_class_vector_to_rust_vector(v)}
    function caml_poly_comm_to_rust_poly_comm
     (poly_comm,poly_comm_class,mk_affine)
     {var
       caml_unshifted=poly_comm[1],
       caml_shifted=poly_comm[2],
       rust_shifted=undefined;
      if(caml_shifted !== 0)
       rust_shifted = rust_affine_of_caml_affine(caml_shifted[1],mk_affine);
      var
       rust_unshifted=
        caml_array_to_rust_vector
         (caml_unshifted,rust_affine_of_caml_affine,mk_affine);
      return new poly_comm_class(rust_unshifted,rust_shifted)}
    function caml_plonk_verification_evals_to_rust
     (x,klass,poly_comm_class,mk_affine)
     {function convert(poly_comm)
       {return caml_poly_comm_to_rust_poly_comm
                (poly_comm,poly_comm_class,mk_affine)}
      function convertArray(comms)
       {var n=comms.length,res=new Array(n - 1);
        for(var i=1;i < n;i++)res[i - 1] = convert(comms[i]);
        return js_class_vector_to_rust_vector(res)}
      var
       sigma_comm=convertArray(x[1]),
       coefficients_comm=convertArray(x[2]),
       generic_comm=convert(x[3]),
       psm_comm=convert(x[4]),
       complete_add_comm=convert(x[5]),
       mul_comm=convert(x[6]),
       emul_comm=convert(x[7]),
       endomul_scalar_comm=convert(x[8]);
      return new
              klass
              (sigma_comm,
               coefficients_comm,
               generic_comm,
               psm_comm,
               complete_add_comm,
               mul_comm,
               emul_comm,
               endomul_scalar_comm)}
    function caml_plonk_verification_shifts_to_rust(x,klass)
     {return new klass(x[1],x[2],x[3],x[4],x[5],x[6],x[7])}
    function caml_plonk_verifier_index_to_rust
     (x,
      klass,
      domain_class,
      verification_evals_class,
      poly_comm_class,
      mk_affine,
      verification_shifts_class)
     {var
       domain=caml_plonk_domain_to_rust(x[1],domain_class),
       max_poly_size=x[2],
       max_quot_size=x[3],
       srs=x[4],
       evals=
        caml_plonk_verification_evals_to_rust
         (x[5],verification_evals_class,poly_comm_class,mk_affine),
       shifts=
        caml_plonk_verification_shifts_to_rust(x[6],verification_shifts_class);
      return new klass(domain,max_poly_size,max_quot_size,srs,evals,shifts)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_neg(x){return x.neg()}
    function integers_uint_of_string(s,max_val)
     {var i=0,len=caml_ml_string_length(s),negative=false;
      if(i >= len)caml_failwith("int_of_string");
      var c=caml_string_unsafe_get(s,i);
      if(c === 45){i++;negative = true}else if(c === 43)i++;
      var no_digits=true;
      max_val.hi = max_val.hi >>> 0;
      var
       ten=caml_int64_of_int32(10),
       max_base_10=max_val.udivmod(ten).quotient,
       res=caml_int64_of_int32(0);
      for(;i < len;i++)
       {var c=caml_string_unsafe_get(s,i),d=caml_parse_digit(c);
        if(d < 0 || d >= 10)break;
        no_digits = false;
        if(caml_int64_ult(max_base_10,res))return max_val;
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(ten,res),d);
        if(caml_int64_ult(res,d))return max_val}
      if(no_digits)caml_failwith("int_of_string");
      if(negative)res = caml_int64_neg(res);
      res.hi = res.hi >>> 0;
      return res}
    function caml_int64_to_int32(x){return x.toInt()}
    var
     UInt32=
      function()
        {function UInt32(x){this.value = x >>> 0}
         UInt32.prototype.caml_custom = "integers:uint32";
         return UInt32}
       ();
    function integers_uint32_of_int64(i)
     {return new UInt32(caml_int64_to_int32(i))}
    function integers_uint32_of_string(s)
     {var max_val=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      return integers_uint32_of_int64(integers_uint_of_string(s,max_val))}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    function caml_pasta_fq_copy(x,y)
     {for(var i=0,l=x.length;i < l;i++)x[i] = y[i]}
    var caml_pasta_fq_sub=plonk_wasm.caml_pasta_fq_sub;
    function caml_pasta_fq_mut_sub(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_sub(x,y))}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function column_of_rust(col)
     {var tag=col.tag,gate_type=col.gate_type,i=col.i;
      col.free();
      return {0:[tag,i],2:[tag,i],5:[tag,i],6:[tag,gate_type],7:[tag,i]}[tag]
             ||
             tag}
    function variable_of_rust(variable)
     {var col=variable.col,row=variable.row;
      variable.free();
      return [0,column_of_rust(col),row]}
    function polish_token_of_rust(token)
     {var
       tag=token.tag,
       i0=token.i0,
       i1=token.i1,
       f=token.f,
       v=variable_of_rust(token.v);
      token.free();
      return {5:[5,i0,i1],6:[6,f],7:[7,v],9:[9,i0],14:[14,i0],16:[16,i0]}[tag]
             ||
             tag}
    function wrap(ptr,klass)
     {var obj=Object.create(klass.prototype);obj.ptr = ptr;return obj}
    function index_term_of_rust(term,token_class)
     {var
       column=column_of_rust(term.column),
       coefficient=
        js_class_vector_of_rust_vector(term.coefficient,token_class);
      coefficient = coefficient.map(polish_token_of_rust);
      coefficient = [0].concat(coefficient);
      term.free();
      return [0,column,coefficient]}
    function linearization_of_rust(linearization,affine_class)
     {var
       F=affine_class === plonk_wasm.WasmGVesta?"Fq":"Fp",
       WasmPolishToken=plonk_wasm["Wasm" + F + "PolishToken"],
       WasmIndexTerm=plonk_wasm["Wasm" + F + "IndexTerm"],
       constant_term=
        js_class_vector_of_rust_vector
         (linearization.constant_term,WasmPolishToken);
      constant_term = constant_term.map(polish_token_of_rust);
      constant_term = [0].concat(constant_term);
      var
       index_terms=
        Array.from(linearization.index_terms).map
         (function(ptr)
           {var wasmIndexTerm=wrap(ptr,WasmIndexTerm);
            return index_term_of_rust(wasmIndexTerm,WasmPolishToken)});
      index_terms = [0].concat(index_terms);
      linearization.free();
      return [0,constant_term,index_terms]}
    function caml_plonk_domain_of_rust(x)
     {var log_size_of_group=x.log_size_of_group,group_gen=x.group_gen;
      x.free();
      return [0,log_size_of_group,group_gen]}
    function caml_plonk_verification_evals_of_rust(x,affine_klass)
     {function convert(poly_comm)
       {return caml_poly_comm_of_rust_poly_comm(poly_comm,affine_klass,false)}
      function convertArray(comms)
       {comms
        =
        js_class_vector_of_rust_vector(comms,plonk_wasm.WasmFqPolyComm);
        return [0].concat(comms.map(convert))}
      var
       sigma_comm=convertArray(x.sigma_comm),
       coefficients_comm=convertArray(x.coefficients_comm),
       generic_comm=convert(x.generic_comm),
       psm_comm=convert(x.psm_comm),
       complete_add_comm=convert(x.complete_add_comm),
       mul_comm=convert(x.mul_comm),
       emul_comm=convert(x.emul_comm),
       endomul_scalar_comm=convert(x.endomul_scalar_comm);
      x.free();
      return [0,
              sigma_comm,
              coefficients_comm,
              generic_comm,
              psm_comm,
              complete_add_comm,
              mul_comm,
              emul_comm,
              endomul_scalar_comm,
              0]}
    function caml_plonk_verification_shifts_of_rust(x)
     {var res=[0,x.s0,x.s1,x.s2,x.s3,x.s4,x.s5,x.s6];x.free();return res}
    var None=0;
    function caml_plonk_verifier_index_of_rust(x,affine_class)
     {var
       domain=caml_plonk_domain_of_rust(x.domain),
       max_poly_size=x.max_poly_size,
       max_quot_size=x.max_quot_size,
       srs=free_on_finalize(x.srs),
       evals=caml_plonk_verification_evals_of_rust(x.evals,affine_class),
       shifts=caml_plonk_verification_shifts_of_rust(x.shifts),
       lookup_index=None;
      x.free();
      return [0,domain,max_poly_size,max_quot_size,srs,evals,shifts,None]}
    function caml_pasta_fq_plonk_verifier_index_of_rust(x)
     {return caml_plonk_verifier_index_of_rust(x,plonk_wasm.WasmGPallas)}
    function caml_pasta_fq_plonk_verifier_index_to_rust(x)
     {return caml_plonk_verifier_index_to_rust
              (x,
               plonk_wasm.WasmFqPlonkVerifierIndex,
               plonk_wasm.WasmFqDomain,
               plonk_wasm.WasmFqPlonkVerificationEvals,
               plonk_wasm.WasmFqPolyComm,
               plonk_wasm.caml_pallas_affine_one,
               plonk_wasm.WasmFqShifts)}
    function caml_pasta_fq_plonk_verifier_index_deep_copy(x)
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_deep_copy
                (caml_pasta_fq_plonk_verifier_index_to_rust(x)))}
    var caml_pasta_fq_print=plonk_wasm.caml_pasta_fq_print;
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function integers_ulonglong_size(unit){return 8}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function bigstring_blit_bigstring_bytes_stub
     (v_bstr,v_src_pos,v_str,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var c=caml_ba_get_1(v_bstr,v_src_pos + i);
        caml_bytes_set(v_str,v_dst_pos + i,c)}
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_pasta_fp_plonk_index_create(gates,public_inputs,urs)
     {var
       t=
        plonk_wasm.caml_pasta_fp_plonk_index_create(gates,public_inputs,urs);
      return free_on_finalize(t)}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    var caml_vesta_endo_base=plonk_wasm.caml_vesta_endo_base;
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function caml_pasta_fp_plonk_gate_vector_create()
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fp_plonk_gate_vector_create())}
    function caml_pasta_fq_plonk_verifier_index_create(x)
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_create(x))}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_pasta_fq_domain_generator=
      plonk_wasm.caml_pasta_fq_domain_generator;
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_fq_srs_h(t)
     {return rust_affine_to_caml_affine(plonk_wasm.caml_fq_srs_h(t))}
    function caml_pallas_negate(x)
     {var res=plonk_wasm.caml_pallas_negate(x);
      free_on_finalize(res);
      return res}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    var caml_ml_channels=new Array();
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_plonk_wire_of_rust(wire)
     {var res=[0,wire.row,wire.col];wire.free();return res}
    function caml_plonk_wires_of_rust(wires)
     {var
       res=
        [0,
         caml_plonk_wire_of_rust(wires[0]),
         caml_plonk_wire_of_rust(wires[1]),
         caml_plonk_wire_of_rust(wires[2]),
         caml_plonk_wire_of_rust(wires[3]),
         caml_plonk_wire_of_rust(wires[4]),
         caml_plonk_wire_of_rust(wires[5]),
         caml_plonk_wire_of_rust(wires[6])];
      wires.free();
      return res}
    function caml_u8array_vector_of_rust_flat_vector(v,inner_len)
     {var
       len=v.length,
       output_len=len / inner_len,
       res=new Array(output_len + 1);
      res[0] = 0;
      for(var i=1,pos=0;i <= output_len;i++)
       {var inner_res=new (joo_global_object.Uint8Array)(inner_len);
        for(var j=0;j < inner_len;j++,pos++)inner_res[j] = v[pos];
        res[i] = inner_res}
      return res}
    function caml_plonk_gate_of_rust(gate)
     {var
       res=
        [0,
         gate.typ,
         caml_plonk_wires_of_rust(gate.wires),
         caml_u8array_vector_of_rust_flat_vector(gate.c,32)];
      gate.free();
      return res}
    function caml_pasta_fq_plonk_gate_vector_get(v,i)
     {return caml_plonk_gate_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_gate_vector_get(v,i))}
    function caml_u8array_vector_to_rust_flat_vector(v)
     {var i=1,len=v.length - i;
      if(len === 0)return new (joo_global_object.Uint8Array)(0);
      var
       inner_len=v[i].length,
       res=new (joo_global_object.Uint8Array)(len * inner_len);
      for(var pos=0;i <= len;i++)
       for(var j=0;j < inner_len;j++,pos++)res[pos] = v[i][j];
      return res}
    function caml_option_to_maybe_undefined(x){return x === 0?undefined:x[1]}
    function caml_random_oracles_to_rust(x,roKlass)
     {var
       joint_combiner_ocaml=caml_option_to_maybe_undefined(x[1]),
       joint_combiner_chal=undefined,
       joint_combiner=undefined;
      if(joint_combiner_ocaml !== undefined)
       {joint_combiner_chal = joint_combiner_ocaml[1][1];
        joint_combiner = joint_combiner_ocaml[2]}
      return new
              roKlass
              (joint_combiner_chal,
               joint_combiner,
               x[2],
               x[3],
               x[4][1],
               x[5],
               x[6],
               x[7],
               x[8],
               x[9][1],
               x[10][1],
               x[11][1])}
    var
     UInt64=
      function()
        {function UInt64(x){this.value = x}
         UInt64.prototype.caml_custom = "integers:uint64";
         return UInt64}
       ();
    function integers_uint64_of_string(s)
     {var max_val=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      return new UInt64(integers_uint_of_string(s,max_val))}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_fp_srs_h(t)
     {return rust_affine_to_caml_affine(plonk_wasm.caml_fp_srs_h(t))}
    function caml_pasta_fp_plonk_verifier_index_of_rust(x)
     {return caml_plonk_verifier_index_of_rust(x,plonk_wasm.WasmGVesta)}
    function caml_pasta_fp_plonk_verifier_index_create(x)
     {var
       vk=plonk_wasm.caml_pasta_fp_plonk_verifier_index_create(x),
       vk_caml=caml_pasta_fp_plonk_verifier_index_of_rust(vk);
      return vk_caml}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    var caml_pasta_fq_deep_copy=plonk_wasm.caml_pasta_fq_deep_copy;
    function bigstring_is_mmapped_stub(x){return 0}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function bin_prot_blit_buf_float_array_stub
     (v_src_pos,v_buf,v_dst_pos,v_arr,v_len)
     {var c,t=new Array(8);
      for(var i=0;i < v_len;i++)
       {for(var j=0;j < 8;j++)
         t[7 - j] = caml_ba_get_1(v_buf,v_src_pos + j + i * 8);
        c = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        caml_array_set(v_arr,v_dst_pos + i,c)}
      return 0}
    function caml_pasta_fq_plonk_verifier_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fq_plonk_verifier_index_write
              (append,
               caml_pasta_fq_plonk_verifier_index_to_rust(t),
               caml_jsstring_of_string(path))}
    function caml_pallas_random()
     {var res=plonk_wasm.caml_pallas_random();
      free_on_finalize(res);
      return res}
    var caml_pasta_fp_to_bigint=plonk_wasm.caml_pasta_fp_to_bigint;
    function caml_vesta_poly_comm_to_rust(x)
     {return caml_poly_comm_to_rust_poly_comm
              (x,plonk_wasm.WasmFpPolyComm,plonk_wasm.caml_vesta_affine_one)}
    function caml_pasta_fp_commitments_to_rust(x)
     {function convertArray(v)
       {var n=v.length - 1,res=new Array(n);
        for(var i=0;i < n;++i)res[i] = caml_vesta_poly_comm_to_rust(v[i + 1]);
        return js_class_vector_to_rust_vector(res)}
      var
       w_comm=convertArray(x[1]),
       z_comm=caml_vesta_poly_comm_to_rust(x[2]),
       t_comm=caml_vesta_poly_comm_to_rust(x[3]);
      return new (plonk_wasm.WasmFpProverCommitments)(w_comm,z_comm,t_comm)}
    function caml_pasta_fp_opening_proof_to_rust(x)
     {function convert_affines(affines)
       {return caml_array_to_rust_vector
                (affines,
                 rust_affine_of_caml_affine,
                 plonk_wasm.caml_vesta_affine_one)}
      var
       lr=x[1],
       delta=rust_affine_of_caml_affine(x[2],plonk_wasm.caml_vesta_affine_one),
       z1=x[3],
       z2=x[4],
       sg=rust_affine_of_caml_affine(x[5],plonk_wasm.caml_vesta_affine_one),
       len=lr.length,
       l_ocaml=new Array(len),
       r_ocaml=new Array(len);
      for(var i=1;i < len;i++){l_ocaml[i] = lr[i][1];r_ocaml[i] = lr[i][2]}
      var l=convert_affines(l_ocaml),r=convert_affines(r_ocaml);
      return new (plonk_wasm.WasmFpOpeningProof)(l,r,delta,z1,z2,sg)}
    function caml_fp_vector_to_rust(v)
     {return caml_u8array_vector_to_rust_flat_vector(v)}
    var PERMUTS_MINUS_1=6,COLUMNS=15;
    function caml_pasta_fp_proof_evaluations_to_rust(x)
     {var w=new (plonk_wasm.WasmVecVecFp)(COLUMNS);
      for(var i=0;i < COLUMNS;++i)w.push(caml_fp_vector_to_rust(x[1][i + 1]));
      var
       z=caml_fp_vector_to_rust(x[2]),
       s=new (plonk_wasm.WasmVecVecFp)(PERMUTS_MINUS_1);
      for(i = 0;i < PERMUTS_MINUS_1;++i)
       s.push(caml_fp_vector_to_rust(x[3][i + 1]));
      var
       generic_selector=caml_fp_vector_to_rust(x[4]),
       poseidon_selector=caml_fp_vector_to_rust(x[5]);
      return new
              (plonk_wasm.WasmFpProofEvaluations)
              (w,z,s,generic_selector,poseidon_selector)}
    function caml_pasta_fp_proof_to_rust(x)
     {var
       commitments=caml_pasta_fp_commitments_to_rust(x[1]),
       proof=caml_pasta_fp_opening_proof_to_rust(x[2]),
       evals0=caml_pasta_fp_proof_evaluations_to_rust(x[3][1]),
       evals1=caml_pasta_fp_proof_evaluations_to_rust(x[3][2]),
       ft_eval1=x[4],
       public_=caml_fp_vector_to_rust(x[5]),
       prev_challenges=x[6],
       chals_len=prev_challenges.length,
       prev_challenges_scalars=new (plonk_wasm.WasmVecVecFp)(chals_len - 1),
       prev_challenges_comms=new Array(chals_len - 1);
      for(var i=1;i < chals_len;i++)
       {prev_challenges_scalars.push
         (caml_fp_vector_to_rust(prev_challenges[i][1]));
        prev_challenges_comms[i - 1]
        =
        caml_vesta_poly_comm_to_rust(prev_challenges[i][2])}
      prev_challenges_comms
      =
      js_class_vector_to_rust_vector(prev_challenges_comms);
      return new
              (plonk_wasm.WasmFpProverProof)
              (commitments,
               proof,
               evals0,
               evals1,
               ft_eval1,
               public_,
               prev_challenges_scalars,
               prev_challenges_comms)}
    function caml_pasta_fp_commitments_of_rust(x)
     {function convertArray(v)
       {var
         a=js_class_vector_of_rust_vector(v,plonk_wasm.WasmFpPolyComm),
         res=[0];
        for(var i=0;i < a.length;++i)
         res.push(caml_vesta_poly_comm_of_rust(a[i]));
        return res}
      var
       w_comm=convertArray(x.w_comm),
       z_comm=caml_vesta_poly_comm_of_rust(x.z_comm),
       t_comm=caml_vesta_poly_comm_of_rust(x.t_comm);
      x.free();
      return [0,w_comm,z_comm,t_comm]}
    function caml_pasta_fp_opening_proof_of_rust(x)
     {function convert_affines(affines)
       {return caml_array_of_rust_vector
                (affines,
                 plonk_wasm.WasmGVesta,
                 rust_affine_to_caml_affine,
                 false)}
      var
       l=convert_affines(x.lr_0),
       r=convert_affines(x.lr_1),
       delta=rust_affine_to_caml_affine(x.delta),
       z1=x.z1,
       z2=x.z2,
       sg=rust_affine_to_caml_affine(x.sg);
      x.free();
      var len=l.length;
      if(len !== r.length)throw new Error("l and r lengths don't match");
      var lr=new Array(len);
      lr[0] = 0;
      for(var i=1;i < len;i++)
       {var tuple=new Array(3);
        tuple[0] = 0;
        tuple[1] = l[i];
        tuple[2] = r[i];
        lr[i] = tuple}
      return [0,lr,delta,z1,z2,sg]}
    function caml_fp_vector_of_rust(v)
     {return caml_u8array_vector_of_rust_flat_vector(v,32)}
    function caml_pasta_fp_proof_evaluations_of_rust(x)
     {function convertArray(v,n)
       {var res=[0];
        for(var i=0;i < n;++i)res.push(caml_fp_vector_of_rust(v.get(i)));
        return res}
      var
       w=convertArray(x.w,COLUMNS),
       z=caml_fp_vector_of_rust(x.z),
       s=convertArray(x.s,PERMUTS_MINUS_1),
       generic_selector=caml_fp_vector_of_rust(x.generic_selector),
       poseidon_selector=caml_fp_vector_of_rust(x.poseidon_selector);
      x.free();
      return [0,w,z,s,generic_selector,poseidon_selector]}
    function caml_pasta_fp_proof_of_rust(x)
     {var
       messages=caml_pasta_fp_commitments_of_rust(x.commitments),
       proof=caml_pasta_fp_opening_proof_of_rust(x.proof),
       evals0=caml_pasta_fp_proof_evaluations_of_rust(x.evals0),
       evals1=caml_pasta_fp_proof_evaluations_of_rust(x.evals1),
       ft_eval1=x.ft_eval1,
       public_=caml_fp_vector_of_rust(x.public_),
       prev_challenges_scalars=x.prev_challenges_scalars,
       prev_challenges_comms=
        js_class_vector_of_rust_vector
         (x.prev_challenges_comms,plonk_wasm.WasmFpPolyComm),
       chals_len=prev_challenges_comms.length,
       prev_challenges=new Array(chals_len);
      prev_challenges[0] = 0;
      for(var i=1;i < chals_len;i++)
       {var res=new Array(3);
        res[0] = 0;
        res[1] = caml_fp_vector_of_rust(prev_challenges_scalars.get(i - 1));
        res[2] = caml_vesta_poly_comm_of_rust(prev_challenges_comms[i]);
        prev_challenges[i] = res}
      return [0,
              messages,
              proof,
              [0,evals0,evals1],
              ft_eval1,
              public_,
              prev_challenges]}
    function caml_pasta_fp_plonk_proof_deep_copy(proof)
     {return caml_pasta_fp_proof_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_proof_deep_copy
                (caml_pasta_fp_proof_to_rust(proof)))}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_pasta_fq_plonk_verifier_index_dummy()
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_dummy())}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    var
     bigInt=
      function(undefined)
        {"use strict";
         var
          BASE=1e7,
          LOG_BASE=7,
          MAX_INT=9007199254740992,
          MAX_INT_ARR=smallToArray(MAX_INT),
          DEFAULT_ALPHABET="0123456789abcdefghijklmnopqrstuvwxyz",
          BigInt=joo_global_object.BigInt,
          supportsNativeBigInt=typeof BigInt === "function";
         function Integer(v,radix,alphabet,caseSensitive)
          {if(typeof v === "undefined")return Integer[0];
           if(typeof radix !== "undefined")
            return + radix === 10 && ! alphabet
                    ?parseValue(v)
                    :parseBase(v,radix,alphabet,caseSensitive);
           return parseValue(v)}
         function BigInteger(value,sign)
          {this.value = value;
           this.sign = sign;
           this.isSmall = false;
           this.caml_custom = "_z"}
         BigInteger.prototype = Object.create(Integer.prototype);
         function SmallInteger(value)
          {this.value = value;
           this.sign = value < 0;
           this.isSmall = true;
           this.caml_custom = "_z"}
         SmallInteger.prototype = Object.create(Integer.prototype);
         function NativeBigInt(value)
          {this.value = value;this.caml_custom = "_z"}
         NativeBigInt.prototype = Object.create(Integer.prototype);
         function isPrecise(n){return - MAX_INT < n && n < MAX_INT}
         function smallToArray(n)
          {if(n < 1e7)return [n];
           if(n < 1e14)return [n % 1e7,Math.floor(n / 1e7)];
           return [n % 1e7,Math.floor(n / 1e7) % 1e7,Math.floor(n / 1e14)]}
         function arrayToSmall(arr)
          {trim(arr);
           var length=arr.length;
           if(length < 4 && compareAbs(arr,MAX_INT_ARR) < 0)
            switch(length)
             {case 0:return 0;
              case 1:return arr[0];
              case 2:return arr[0] + arr[1] * BASE;
              default:return arr[0] + (arr[1] + arr[2] * BASE) * BASE}
           return arr}
         function trim(v){var i=v.length;while(v[--i] === 0);v.length = i + 1}
         function createArray(length)
          {var x=new Array(length),i=- 1;while(++i < length)x[i] = 0;return x}
         function truncate(n)
          {if(n > 0)return Math.floor(n);return Math.ceil(n)}
         function add(a,b)
          {var
            l_a=a.length,
            l_b=b.length,
            r=new Array(l_a),
            carry=0,
            base=BASE,
            sum,
            i;
           for(i = 0;i < l_b;i++)
            {sum = a[i] + b[i] + carry;
             carry = sum >= base?1:0;
             r[i] = sum - carry * base}
           while(i < l_a)
            {sum = a[i] + carry;
             carry = sum === base?1:0;
             r[i++] = sum - carry * base}
           if(carry > 0)r.push(carry);
           return r}
         function addAny(a,b)
          {if(a.length >= b.length)return add(a,b);return add(b,a)}
         function addSmall(a,carry)
          {var l=a.length,r=new Array(l),base=BASE,sum,i;
           for(i = 0;i < l;i++)
            {sum = a[i] - base + carry;
             carry = Math.floor(sum / base);
             r[i] = sum - carry * base;
             carry += 1}
           while(carry > 0)
            {r[i++] = carry % base;carry = Math.floor(carry / base)}
           return r}
         BigInteger.prototype.add
         =
         function(v)
          {var n=parseValue(v);
           if(this.sign !== n.sign)return this.subtract(n.negate());
           var a=this.value,b=n.value;
           if(n.isSmall)
            return new BigInteger(addSmall(a,Math.abs(b)),this.sign);
           return new BigInteger(addAny(a,b),this.sign)};
         BigInteger.prototype.plus = BigInteger.prototype.add;
         SmallInteger.prototype.add
         =
         function(v)
          {var n=parseValue(v),a=this.value;
           if(a < 0 !== n.sign)return this.subtract(n.negate());
           var b=n.value;
           if(n.isSmall)
            {if(isPrecise(a + b))return new SmallInteger(a + b);
             b = smallToArray(Math.abs(b))}
           return new BigInteger(addSmall(b,Math.abs(a)),a < 0)};
         SmallInteger.prototype.plus = SmallInteger.prototype.add;
         NativeBigInt.prototype.add
         =
         function(v)
          {return new NativeBigInt(this.value + parseValue(v).value)};
         NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
         function subtract(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            r=new Array(a_l),
            borrow=0,
            base=BASE,
            i,
            difference;
           for(i = 0;i < b_l;i++)
            {difference = a[i] - borrow - b[i];
             if(difference < 0){difference += base;borrow = 1}else borrow = 0;
             r[i] = difference}
           for(i = b_l;i < a_l;i++)
            {difference = a[i] - borrow;
             if(difference < 0)
              difference += base;
             else
              {r[i++] = difference;break}
             r[i] = difference}
           for(;i < a_l;i++)r[i] = a[i];
           trim(r);
           return r}
         function subtractAny(a,b,sign)
          {var value;
           if(compareAbs(a,b) >= 0)
            value = subtract(a,b);
           else
            {value = subtract(b,a);sign = ! sign}
           value = arrayToSmall(value);
           if(typeof value === "number")
            {if(sign)value = - value;return new SmallInteger(value)}
           return new BigInteger(value,sign)}
         function subtractSmall(a,b,sign)
          {var l=a.length,r=new Array(l),carry=- b,base=BASE,i,difference;
           for(i = 0;i < l;i++)
            {difference = a[i] + carry;
             carry = Math.floor(difference / base);
             difference %= base;
             r[i] = difference < 0?difference + base:difference}
           r = arrayToSmall(r);
           if(typeof r === "number")
            {if(sign)r = - r;return new SmallInteger(r)}
           return new BigInteger(r,sign)}
         BigInteger.prototype.subtract
         =
         function(v)
          {var n=parseValue(v);
           if(this.sign !== n.sign)return this.add(n.negate());
           var a=this.value,b=n.value;
           if(n.isSmall)return subtractSmall(a,Math.abs(b),this.sign);
           return subtractAny(a,b,this.sign)};
         BigInteger.prototype.minus = BigInteger.prototype.subtract;
         SmallInteger.prototype.subtract
         =
         function(v)
          {var n=parseValue(v),a=this.value;
           if(a < 0 !== n.sign)return this.add(n.negate());
           var b=n.value;
           if(n.isSmall)return new SmallInteger(a - b);
           return subtractSmall(b,Math.abs(a),a >= 0)};
         SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
         NativeBigInt.prototype.subtract
         =
         function(v)
          {return new NativeBigInt(this.value - parseValue(v).value)};
         NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
         BigInteger.prototype.negate
         =
         function(){return new BigInteger(this.value,! this.sign)};
         SmallInteger.prototype.negate
         =
         function()
          {var sign=this.sign,small=new SmallInteger(- this.value);
           small.sign = ! sign;
           return small};
         NativeBigInt.prototype.negate
         =
         function(){return new NativeBigInt(- this.value)};
         BigInteger.prototype.abs
         =
         function(){return new BigInteger(this.value,false)};
         SmallInteger.prototype.abs
         =
         function(){return new SmallInteger(Math.abs(this.value))};
         NativeBigInt.prototype.abs
         =
         function()
          {return new NativeBigInt(this.value >= 0?this.value:- this.value)};
         function multiplyLong(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            l=a_l + b_l,
            r=createArray(l),
            base=BASE,
            product,
            carry,
            i,
            a_i,
            b_j;
           for(i = 0;i < a_l;++i)
            {a_i = a[i];
             for(var j=0;j < b_l;++j)
              {b_j = b[j];
               product = a_i * b_j + r[i + j];
               carry = Math.floor(product / base);
               r[i + j] = product - carry * base;
               r[i + j + 1] += carry}}
           trim(r);
           return r}
         function multiplySmall(a,b)
          {var l=a.length,r=new Array(l),base=BASE,carry=0,product,i;
           for(i = 0;i < l;i++)
            {product = a[i] * b + carry;
             carry = Math.floor(product / base);
             r[i] = product - carry * base}
           while(carry > 0)
            {r[i++] = carry % base;carry = Math.floor(carry / base)}
           return r}
         function shiftLeft(x,n)
          {var r=[];while(n-- > 0)r.push(0);return r.concat(x)}
         function multiplyKaratsuba(x,y)
          {var n=Math.max(x.length,y.length);
           if(n <= 30)return multiplyLong(x,y);
           n = Math.ceil(n / 2);
           var
            b=x.slice(n),
            a=x.slice(0,n),
            d=y.slice(n),
            c=y.slice(0,n),
            ac=multiplyKaratsuba(a,c),
            bd=multiplyKaratsuba(b,d),
            abcd=multiplyKaratsuba(addAny(a,b),addAny(c,d)),
            product=
             addAny
              (addAny(ac,shiftLeft(subtract(subtract(abcd,ac),bd),n)),
               shiftLeft(bd,2 * n));
           trim(product);
           return product}
         function useKaratsuba(l1,l2)
          {return - (0.012 * l1) - 0.012 * l2 + 0.000015 * l1 * l2 > 0}
         BigInteger.prototype.multiply
         =
         function(v)
          {var
            n=parseValue(v),
            a=this.value,
            b=n.value,
            sign=this.sign !== n.sign,
            abs;
           if(n.isSmall)
            {if(b === 0)return Integer[0];
             if(b === 1)return this;
             if(b === - 1)return this.negate();
             abs = Math.abs(b);
             if(abs < BASE)return new BigInteger(multiplySmall(a,abs),sign);
             b = smallToArray(abs)}
           if(useKaratsuba(a.length,b.length))
            return new BigInteger(multiplyKaratsuba(a,b),sign);
           return new BigInteger(multiplyLong(a,b),sign)};
         BigInteger.prototype.times = BigInteger.prototype.multiply;
         function multiplySmallAndArray(a,b,sign)
          {if(a < BASE)return new BigInteger(multiplySmall(b,a),sign);
           return new BigInteger(multiplyLong(b,smallToArray(a)),sign)}
         SmallInteger.prototype._multiplyBySmall
         =
         function(a)
          {if(isPrecise(a.value * this.value))
            return new SmallInteger(a.value * this.value);
           return multiplySmallAndArray
                   (Math.abs(a.value),
                    smallToArray(Math.abs(this.value)),
                    this.sign !== a.sign)};
         BigInteger.prototype._multiplyBySmall
         =
         function(a)
          {if(a.value === 0)return Integer[0];
           if(a.value === 1)return this;
           if(a.value === - 1)return this.negate();
           return multiplySmallAndArray
                   (Math.abs(a.value),this.value,this.sign !== a.sign)};
         SmallInteger.prototype.multiply
         =
         function(v){return parseValue(v)._multiplyBySmall(this)};
         SmallInteger.prototype.times = SmallInteger.prototype.multiply;
         NativeBigInt.prototype.multiply
         =
         function(v)
          {return new NativeBigInt(this.value * parseValue(v).value)};
         NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
         function square(a)
          {var
            l=a.length,
            r=createArray(l + l),
            base=BASE,
            product,
            carry,
            i,
            a_i,
            a_j;
           for(i = 0;i < l;i++)
            {a_i = a[i];
             carry = 0 - a_i * a_i;
             for(var j=i;j < l;j++)
              {a_j = a[j];
               product = 2 * (a_i * a_j) + r[i + j] + carry;
               carry = Math.floor(product / base);
               r[i + j] = product - carry * base}
             r[i + l] = carry}
           trim(r);
           return r}
         BigInteger.prototype.square
         =
         function(){return new BigInteger(square(this.value),false)};
         SmallInteger.prototype.square
         =
         function()
          {var value=this.value * this.value;
           if(isPrecise(value))return new SmallInteger(value);
           return new
                   BigInteger
                   (square(smallToArray(Math.abs(this.value))),false)};
         NativeBigInt.prototype.square
         =
         function(v){return new NativeBigInt(this.value * this.value)};
         function divMod1(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            base=BASE,
            result=createArray(b.length),
            divisorMostSignificantDigit=b[b_l - 1],
            lambda=Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder=multiplySmall(a,lambda),
            divisor=multiplySmall(b,lambda),
            quotientDigit,
            shift,
            carry,
            borrow,
            i,
            l,
            q;
           if(remainder.length <= a_l)remainder.push(0);
           divisor.push(0);
           divisorMostSignificantDigit = divisor[b_l - 1];
           for(shift = a_l - b_l;shift >= 0;shift--)
            {quotientDigit = base - 1;
             if(remainder[shift + b_l] !== divisorMostSignificantDigit)
              quotientDigit
              =
              Math.floor
               ((remainder[shift + b_l] * base + remainder[shift + b_l - 1])
                /
                divisorMostSignificantDigit);
             carry = 0;
             borrow = 0;
             l = divisor.length;
             for(i = 0;i < l;i++)
              {carry += quotientDigit * divisor[i];
               q = Math.floor(carry / base);
               borrow += remainder[shift + i] - (carry - q * base);
               carry = q;
               if(borrow < 0)
                {remainder[shift + i] = borrow + base;borrow = - 1}
               else
                {remainder[shift + i] = borrow;borrow = 0}}
             while(borrow !== 0)
              {quotientDigit -= 1;
               carry = 0;
               for(i = 0;i < l;i++)
                {carry += remainder[shift + i] - base + divisor[i];
                 if(carry < 0)
                  {remainder[shift + i] = carry + base;carry = 0}
                 else
                  {remainder[shift + i] = carry;carry = 1}}
               borrow += carry}
             result[shift] = quotientDigit}
           remainder = divModSmall(remainder,lambda)[0];
           return [arrayToSmall(result),arrayToSmall(remainder)]}
         function divMod2(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            result=[],
            part=[],
            base=BASE,
            guess,
            xlen,
            highx,
            highy,
            check;
           while(a_l)
            {part.unshift(a[--a_l]);
             trim(part);
             if(compareAbs(part,b) < 0){result.push(0);continue}
             xlen = part.length;
             highx = part[xlen - 1] * base + part[xlen - 2];
             highy = b[b_l - 1] * base + b[b_l - 2];
             if(xlen > b_l)highx = (highx + 1) * base;
             guess = Math.ceil(highx / highy);
             do
              {check = multiplySmall(b,guess);
               if(compareAbs(check,part) <= 0)break;
               guess--}
             while
              (guess);
             result.push(guess);
             part = subtract(part,check)}
           result.reverse();
           return [arrayToSmall(result),arrayToSmall(part)]}
         function divModSmall(value,lambda)
          {var
            length=value.length,
            quotient=createArray(length),
            base=BASE,
            i,
            q,
            remainder,
            divisor;
           remainder = 0;
           for(i = length - 1;i >= 0;--i)
            {divisor = remainder * base + value[i];
             q = truncate(divisor / lambda);
             remainder = divisor - q * lambda;
             quotient[i] = q | 0}
           return [quotient,remainder | 0]}
         function divModAny(self,v)
          {var value,n=parseValue(v);
           if(supportsNativeBigInt)
            return [new NativeBigInt(self.value / n.value),
                    new NativeBigInt(self.value % n.value)];
           var a=self.value,b=n.value,quotient;
           if(b === 0)throw new Error("Cannot divide by zero");
           if(self.isSmall)
            {if(n.isSmall)
              return [new SmallInteger(truncate(a / b)),
                      new SmallInteger(a % b)];
             return [Integer[0],self]}
           if(n.isSmall)
            {if(b === 1)return [self,Integer[0]];
             if(b == - 1)return [self.negate(),Integer[0]];
             var abs=Math.abs(b);
             if(abs < BASE)
              {value = divModSmall(a,abs);
               quotient = arrayToSmall(value[0]);
               var remainder=value[1];
               if(self.sign)remainder = - remainder;
               if(typeof quotient === "number")
                {if(self.sign !== n.sign)quotient = - quotient;
                 return [new SmallInteger(quotient),
                         new SmallInteger(remainder)]}
               return [new BigInteger(quotient,self.sign !== n.sign),
                       new SmallInteger(remainder)]}
             b = smallToArray(abs)}
           var comparison=compareAbs(a,b);
           if(comparison === - 1)return [Integer[0],self];
           if(comparison === 0)
            return [Integer[self.sign === n.sign?1:- 1],Integer[0]];
           if(a.length + b.length <= 200)
            value = divMod1(a,b);
           else
            value = divMod2(a,b);
           quotient = value[0];
           var qSign=self.sign !== n.sign,mod=value[1],mSign=self.sign;
           if(typeof quotient === "number")
            {if(qSign)quotient = - quotient;
             quotient = new SmallInteger(quotient)}
           else
            quotient = new BigInteger(quotient,qSign);
           if(typeof mod === "number")
            {if(mSign)mod = - mod;mod = new SmallInteger(mod)}
           else
            mod = new BigInteger(mod,mSign);
           return [quotient,mod]}
         BigInteger.prototype.divmod
         =
         function(v)
          {var result=divModAny(this,v);
           return {quotient:result[0],remainder:result[1]}};
         NativeBigInt.prototype.divmod
         =
         SmallInteger.prototype.divmod
         =
         BigInteger.prototype.divmod;
         BigInteger.prototype.divide
         =
         function(v){return divModAny(this,v)[0]};
         NativeBigInt.prototype.over
         =
         NativeBigInt.prototype.divide
         =
         function(v)
          {return new NativeBigInt(this.value / parseValue(v).value)};
         SmallInteger.prototype.over
         =
         SmallInteger.prototype.divide
         =
         BigInteger.prototype.over
         =
         BigInteger.prototype.divide;
         BigInteger.prototype.mod = function(v){return divModAny(this,v)[1]};
         NativeBigInt.prototype.mod
         =
         NativeBigInt.prototype.remainder
         =
         function(v)
          {return new NativeBigInt(this.value % parseValue(v).value)};
         SmallInteger.prototype.remainder
         =
         SmallInteger.prototype.mod
         =
         BigInteger.prototype.remainder
         =
         BigInteger.prototype.mod;
         BigInteger.prototype.pow
         =
         function(v)
          {var n=parseValue(v),a=this.value,b=n.value,value,x,y;
           if(b === 0)return Integer[1];
           if(a === 0)return Integer[0];
           if(a === 1)return Integer[1];
           if(a === - 1)return n.isEven()?Integer[1]:Integer[- 1];
           if(n.sign)return Integer[0];
           if(! n.isSmall)
            throw new Error("The exponent " + n.toString() + " is too large.");
           if(this.isSmall)
            if(isPrecise(value = Math.pow(a,b)))
             return new SmallInteger(truncate(value));
           x = this;
           y = Integer[1];
           while(true)
            {if(b & 1 === 1){y = y.times(x);--b}
             if(b === 0)break;
             b /= 2;
             x = x.square()}
           return y};
         SmallInteger.prototype.pow = BigInteger.prototype.pow;
         NativeBigInt.prototype.pow
         =
         function(v)
          {var
            n=parseValue(v),
            a=this.value,
            b=n.value,
            _0=BigInt(0),
            _1=BigInt(1),
            _2=BigInt(2);
           if(b === _0)return Integer[1];
           if(a === _0)return Integer[0];
           if(a === _1)return Integer[1];
           if(a === BigInt(- 1))return n.isEven()?Integer[1]:Integer[- 1];
           if(n.isNegative())return new NativeBigInt(_0);
           var x=this,y=Integer[1];
           while(true)
            {if((b & _1) === _1){y = y.times(x);--b}
             if(b === _0)break;
             b /= _2;
             x = x.square()}
           return y};
         BigInteger.prototype.modPow
         =
         function(exp,mod)
          {exp = parseValue(exp);
           mod = parseValue(mod);
           if(mod.isZero())
            throw new Error("Cannot take modPow with modulus 0");
           var r=Integer[1],base=this.mod(mod);
           if(exp.isNegative())
            {exp = exp.multiply(Integer[- 1]);base = base.modInv(mod)}
           while(exp.isPositive())
            {if(base.isZero())return Integer[0];
             if(exp.isOdd())r = r.multiply(base).mod(mod);
             exp = exp.divide(2);
             base = base.square().mod(mod)}
           return r};
         NativeBigInt.prototype.modPow
         =
         SmallInteger.prototype.modPow
         =
         BigInteger.prototype.modPow;
         function compareAbs(a,b)
          {if(a.length !== b.length)return a.length > b.length?1:- 1;
           for(var i=a.length - 1;i >= 0;i--)
            if(a[i] !== b[i])return a[i] > b[i]?1:- 1;
           return 0}
         BigInteger.prototype.compareAbs
         =
         function(v)
          {var n=parseValue(v),a=this.value,b=n.value;
           if(n.isSmall)return 1;
           return compareAbs(a,b)};
         SmallInteger.prototype.compareAbs
         =
         function(v)
          {var n=parseValue(v),a=Math.abs(this.value),b=n.value;
           if(n.isSmall){b = Math.abs(b);return a === b?0:a > b?1:- 1}
           return - 1};
         NativeBigInt.prototype.compareAbs
         =
         function(v)
          {var a=this.value,b=parseValue(v).value;
           a = a >= 0?a:- a;
           b = b >= 0?b:- b;
           return a === b?0:a > b?1:- 1};
         BigInteger.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var n=parseValue(v),a=this.value,b=n.value;
           if(this.sign !== n.sign)return n.sign?1:- 1;
           if(n.isSmall)return this.sign?- 1:1;
           return compareAbs(a,b) * (this.sign?- 1:1)};
         BigInteger.prototype.compareTo = BigInteger.prototype.compare;
         SmallInteger.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var n=parseValue(v),a=this.value,b=n.value;
           if(n.isSmall)return a == b?0:a > b?1:- 1;
           if(a < 0 !== n.sign)return a < 0?- 1:1;
           return a < 0?1:- 1};
         SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
         NativeBigInt.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var a=this.value,b=parseValue(v).value;
           return a === b?0:a > b?1:- 1};
         NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
         BigInteger.prototype.equals
         =
         function(v){return this.compare(v) === 0};
         NativeBigInt.prototype.eq
         =
         NativeBigInt.prototype.equals
         =
         SmallInteger.prototype.eq
         =
         SmallInteger.prototype.equals
         =
         BigInteger.prototype.eq
         =
         BigInteger.prototype.equals;
         BigInteger.prototype.notEquals
         =
         function(v){return this.compare(v) !== 0};
         NativeBigInt.prototype.neq
         =
         NativeBigInt.prototype.notEquals
         =
         SmallInteger.prototype.neq
         =
         SmallInteger.prototype.notEquals
         =
         BigInteger.prototype.neq
         =
         BigInteger.prototype.notEquals;
         BigInteger.prototype.greater
         =
         function(v){return this.compare(v) > 0};
         NativeBigInt.prototype.gt
         =
         NativeBigInt.prototype.greater
         =
         SmallInteger.prototype.gt
         =
         SmallInteger.prototype.greater
         =
         BigInteger.prototype.gt
         =
         BigInteger.prototype.greater;
         BigInteger.prototype.lesser
         =
         function(v){return this.compare(v) < 0};
         NativeBigInt.prototype.lt
         =
         NativeBigInt.prototype.lesser
         =
         SmallInteger.prototype.lt
         =
         SmallInteger.prototype.lesser
         =
         BigInteger.prototype.lt
         =
         BigInteger.prototype.lesser;
         BigInteger.prototype.greaterOrEquals
         =
         function(v){return this.compare(v) >= 0};
         NativeBigInt.prototype.geq
         =
         NativeBigInt.prototype.greaterOrEquals
         =
         SmallInteger.prototype.geq
         =
         SmallInteger.prototype.greaterOrEquals
         =
         BigInteger.prototype.geq
         =
         BigInteger.prototype.greaterOrEquals;
         BigInteger.prototype.lesserOrEquals
         =
         function(v){return this.compare(v) <= 0};
         NativeBigInt.prototype.leq
         =
         NativeBigInt.prototype.lesserOrEquals
         =
         SmallInteger.prototype.leq
         =
         SmallInteger.prototype.lesserOrEquals
         =
         BigInteger.prototype.leq
         =
         BigInteger.prototype.lesserOrEquals;
         BigInteger.prototype.isEven
         =
         function(){return (this.value[0] & 1) === 0};
         SmallInteger.prototype.isEven
         =
         function(){return (this.value & 1) === 0};
         NativeBigInt.prototype.isEven
         =
         function(){return (this.value & BigInt(1)) === BigInt(0)};
         BigInteger.prototype.isOdd
         =
         function(){return (this.value[0] & 1) === 1};
         SmallInteger.prototype.isOdd
         =
         function(){return (this.value & 1) === 1};
         NativeBigInt.prototype.isOdd
         =
         function(){return (this.value & BigInt(1)) === BigInt(1)};
         BigInteger.prototype.isPositive = function(){return ! this.sign};
         SmallInteger.prototype.isPositive
         =
         function(){return this.value > 0};
         NativeBigInt.prototype.isPositive
         =
         SmallInteger.prototype.isPositive;
         BigInteger.prototype.isNegative = function(){return this.sign};
         SmallInteger.prototype.isNegative
         =
         function(){return this.value < 0};
         NativeBigInt.prototype.isNegative
         =
         SmallInteger.prototype.isNegative;
         BigInteger.prototype.isUnit = function(){return false};
         SmallInteger.prototype.isUnit
         =
         function(){return Math.abs(this.value) === 1};
         NativeBigInt.prototype.isUnit
         =
         function(){return this.abs().value === BigInt(1)};
         BigInteger.prototype.isZero = function(){return false};
         SmallInteger.prototype.isZero = function(){return this.value === 0};
         NativeBigInt.prototype.isZero
         =
         function(){return this.value === BigInt(0)};
         BigInteger.prototype.isDivisibleBy
         =
         function(v)
          {var n=parseValue(v);
           if(n.isZero())return false;
           if(n.isUnit())return true;
           if(n.compareAbs(2) === 0)return this.isEven();
           return this.mod(n).isZero()};
         NativeBigInt.prototype.isDivisibleBy
         =
         SmallInteger.prototype.isDivisibleBy
         =
         BigInteger.prototype.isDivisibleBy;
         function isBasicPrime(v)
          {var n=v.abs();
           if(n.isUnit())return false;
           if(n.equals(2) || n.equals(3) || n.equals(5))return true;
           if(n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
            return false;
           if(n.lesser(49))return true}
         function millerRabinTest(n,a)
          {var nPrev=n.prev(),b=nPrev,r=0,d,t,i,x;
           while(b.isEven())b = b.divide(2),r++;
           next:
           for(i = 0;i < a.length;i++)
            {if(n.lesser(a[i]))continue;
             x = bigInt(a[i]).modPow(b,n);
             if(x.isUnit() || x.equals(nPrev))continue;
             for(d = r - 1;d != 0;d--)
              {x = x.square().mod(n);
               if(x.isUnit())return false;
               if(x.equals(nPrev))continue next}
             return false}
           return true}
         BigInteger.prototype.isPrime
         =
         function(strict)
          {var isPrime=isBasicPrime(this);
           if(isPrime !== undefined)return isPrime;
           var n=this.abs(),bits=n.bitLength();
           if(bits <= 64)
            return millerRabinTest(n,[2,3,5,7,11,13,17,19,23,29,31,37]);
           var
            logN=Math.log(2) * bits.toJSNumber(),
            t=Math.ceil(strict === true?2 * Math.pow(logN,2):logN);
           for(var a=[],i=0;i < t;i++)a.push(bigInt(i + 2));
           return millerRabinTest(n,a)};
         NativeBigInt.prototype.isPrime
         =
         SmallInteger.prototype.isPrime
         =
         BigInteger.prototype.isPrime;
         BigInteger.prototype.isProbablePrime
         =
         function(iterations)
          {var isPrime=isBasicPrime(this);
           if(isPrime !== undefined)return isPrime;
           var n=this.abs(),t=iterations === undefined?5:iterations;
           for(var a=[],i=0;i < t;i++)
            a.push(bigInt.randBetween(2,n.minus(2)));
           return millerRabinTest(n,a)};
         NativeBigInt.prototype.isProbablePrime
         =
         SmallInteger.prototype.isProbablePrime
         =
         BigInteger.prototype.isProbablePrime;
         BigInteger.prototype.modInv
         =
         function(n)
          {var
            t=bigInt.zero,
            newT=bigInt.one,
            r=parseValue(n),
            newR=this.abs(),
            q,
            lastT,
            lastR;
           while(! newR.isZero())
            {q = r.divide(newR);
             lastT = t;
             lastR = r;
             t = newT;
             r = newR;
             newT = lastT.subtract(q.multiply(newT));
             newR = lastR.subtract(q.multiply(newR))}
           if(! r.isUnit())
            throw new
                   Error
                   (this.toString()
                    +
                    " and "
                    +
                    n.toString()
                    +
                    " are not co-prime");
           if(t.compare(0) === - 1)t = t.add(n);
           if(this.isNegative())return t.negate();
           return t};
         NativeBigInt.prototype.modInv
         =
         SmallInteger.prototype.modInv
         =
         BigInteger.prototype.modInv;
         BigInteger.prototype.next
         =
         function()
          {var value=this.value;
           if(this.sign)return subtractSmall(value,1,this.sign);
           return new BigInteger(addSmall(value,1),this.sign)};
         SmallInteger.prototype.next
         =
         function()
          {var value=this.value;
           if(value + 1 < MAX_INT)return new SmallInteger(value + 1);
           return new BigInteger(MAX_INT_ARR,false)};
         NativeBigInt.prototype.next
         =
         function(){return new NativeBigInt(this.value + BigInt(1))};
         BigInteger.prototype.prev
         =
         function()
          {var value=this.value;
           if(this.sign)return new BigInteger(addSmall(value,1),true);
           return subtractSmall(value,1,this.sign)};
         SmallInteger.prototype.prev
         =
         function()
          {var value=this.value;
           if(value - 1 > - MAX_INT)return new SmallInteger(value - 1);
           return new BigInteger(MAX_INT_ARR,true)};
         NativeBigInt.prototype.prev
         =
         function(){return new NativeBigInt(this.value - BigInt(1))};
         var powersOfTwo=[1];
         while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
         var
          powers2Length=powersOfTwo.length,
          highestPower2=powersOfTwo[powers2Length - 1];
         function shift_isSmall(n){return Math.abs(n) <= BASE}
         BigInteger.prototype.shiftLeft
         =
         function(v)
          {var n=parseValue(v).toJSNumber();
           if(! shift_isSmall(n))
            throw new Error(String(n) + " is too large for shifting.");
           if(n < 0)return this.shiftRight(- n);
           var result=this;
           if(result.isZero())return result;
           while(n >= powers2Length)
            {result = result.multiply(highestPower2);n -= powers2Length - 1}
           return result.multiply(powersOfTwo[n])};
         NativeBigInt.prototype.shiftLeft
         =
         SmallInteger.prototype.shiftLeft
         =
         BigInteger.prototype.shiftLeft;
         BigInteger.prototype.shiftRight
         =
         function(v)
          {var remQuo,n=parseValue(v).toJSNumber();
           if(! shift_isSmall(n))
            throw new Error(String(n) + " is too large for shifting.");
           if(n < 0)return this.shiftLeft(- n);
           var result=this;
           while(n >= powers2Length)
            {if(result.isZero() || result.isNegative() && result.isUnit())
              return result;
             remQuo = divModAny(result,highestPower2);
             result = remQuo[1].isNegative()?remQuo[0].prev():remQuo[0];
             n -= powers2Length - 1}
           remQuo = divModAny(result,powersOfTwo[n]);
           return remQuo[1].isNegative()?remQuo[0].prev():remQuo[0]};
         NativeBigInt.prototype.shiftRight
         =
         SmallInteger.prototype.shiftRight
         =
         BigInteger.prototype.shiftRight;
         function bitwise(x,y,fn)
          {y = parseValue(y);
           var
            xSign=x.isNegative(),
            ySign=y.isNegative(),
            xRem=xSign?x.not():x,
            yRem=ySign?y.not():y,
            xDigit=0,
            yDigit=0,
            xDivMod=null,
            yDivMod=null,
            result=[];
           while(! xRem.isZero() || ! yRem.isZero())
            {xDivMod = divModAny(xRem,highestPower2);
             xDigit = xDivMod[1].toJSNumber();
             if(xSign)xDigit = highestPower2 - 1 - xDigit;
             yDivMod = divModAny(yRem,highestPower2);
             yDigit = yDivMod[1].toJSNumber();
             if(ySign)yDigit = highestPower2 - 1 - yDigit;
             xRem = xDivMod[0];
             yRem = yDivMod[0];
             result.push(fn(xDigit,yDigit))}
           var sum=fn(xSign?1:0,ySign?1:0) !== 0?bigInt(- 1):bigInt(0);
           for(var i=result.length - 1;i >= 0;i -= 1)
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
           return sum}
         BigInteger.prototype.not = function(){return this.negate().prev()};
         NativeBigInt.prototype.not
         =
         SmallInteger.prototype.not
         =
         BigInteger.prototype.not;
         BigInteger.prototype.and
         =
         function(n){return bitwise(this,n,function(a,b){return a & b})};
         NativeBigInt.prototype.and
         =
         SmallInteger.prototype.and
         =
         BigInteger.prototype.and;
         BigInteger.prototype.or
         =
         function(n){return bitwise(this,n,function(a,b){return a | b})};
         NativeBigInt.prototype.or
         =
         SmallInteger.prototype.or
         =
         BigInteger.prototype.or;
         BigInteger.prototype.xor
         =
         function(n){return bitwise(this,n,function(a,b){return a ^ b})};
         NativeBigInt.prototype.xor
         =
         SmallInteger.prototype.xor
         =
         BigInteger.prototype.xor;
         var
          LOBMASK_I=1 << 30,
          LOBMASK_BI=(BASE & - BASE) * (BASE & - BASE) | LOBMASK_I;
         function roughLOB(n)
          {var
            v=n.value,
            x=
             typeof v === "number"
              ?v | LOBMASK_I
              :typeof v === "bigint"
                ?v | BigInt(LOBMASK_I)
                :v[0] + v[1] * BASE | LOBMASK_BI;
           return x & - x}
         function integerLogarithm(value,base)
          {if(base.compareTo(value) <= 0)
            {var
              tmp=integerLogarithm(value,base.square(base)),
              p=tmp.p,
              e=tmp.e,
              t=p.multiply(base);
             return t.compareTo(value) <= 0?{p:t,e:e * 2 + 1}:{p:p,e:e * 2}}
           return {p:bigInt(1),e:0}}
         BigInteger.prototype.bitLength
         =
         function()
          {var n=this;
           if(n.compareTo(bigInt(0)) < 0)n = n.negate().subtract(bigInt(1));
           if(n.compareTo(bigInt(0)) === 0)return bigInt(0);
           return bigInt(integerLogarithm(n,bigInt(2)).e).add(bigInt(1))};
         NativeBigInt.prototype.bitLength
         =
         SmallInteger.prototype.bitLength
         =
         BigInteger.prototype.bitLength;
         function max(a,b)
          {a = parseValue(a);b = parseValue(b);return a.greater(b)?a:b}
         function min(a,b)
          {a = parseValue(a);b = parseValue(b);return a.lesser(b)?a:b}
         function gcd(a,b)
          {a = parseValue(a).abs();
           b = parseValue(b).abs();
           if(a.equals(b))return a;
           if(a.isZero())return b;
           if(b.isZero())return a;
           var c=Integer[1],d,t;
           while(a.isEven() && b.isEven())
            {d = min(roughLOB(a),roughLOB(b));
             a = a.divide(d);
             b = b.divide(d);
             c = c.multiply(d)}
           while(a.isEven())a = a.divide(roughLOB(a));
           do
            {while(b.isEven())b = b.divide(roughLOB(b));
             if(a.greater(b)){t = b;b = a;a = t}
             b = b.subtract(a)}
           while
            (! b.isZero());
           return c.isUnit()?a:a.multiply(c)}
         function lcm(a,b)
          {a = parseValue(a).abs();
           b = parseValue(b).abs();
           return a.divide(gcd(a,b)).multiply(b)}
         function randBetween(a,b)
          {a = parseValue(a);
           b = parseValue(b);
           var low=min(a,b),high=max(a,b),range=high.subtract(low).add(1);
           if(range.isSmall)return low.add(Math.floor(Math.random() * range));
           var digits=toBase(range,BASE).value,result=[],restricted=true;
           for(var i=0;i < digits.length;i++)
            {var
              top=restricted?digits[i]:BASE,
              digit=truncate(Math.random() * top);
             result.push(digit);
             if(digit < top)restricted = false}
           return low.add(Integer.fromArray(result,BASE,false))}
         function parseBase(text,base,alphabet,caseSensitive)
          {alphabet = alphabet || DEFAULT_ALPHABET;
           text = String(text);
           if(! caseSensitive)
            {text = text.toLowerCase();alphabet = alphabet.toLowerCase()}
           var length=text.length,i,absBase=Math.abs(base),alphabetValues={};
           for(i = 0;i < alphabet.length;i++)alphabetValues[alphabet[i]] = i;
           for(i = 0;i < length;i++)
            {var c=text[i];
             if(c === "-")continue;
             if(c in alphabetValues)
              if(alphabetValues[c] >= absBase)
               {if(c === "1" && absBase === 1)continue;
                throw new
                       Error
                       (c + " is not a valid digit in base " + base + ".")}}
           base = parseValue(base);
           var digits=[],isNegative=text[0] === "-";
           for(i = isNegative?1:0;i < text.length;i++)
            {var c=text[i];
             if(c in alphabetValues)
              digits.push(parseValue(alphabetValues[c]));
             else
              if(c === "<")
               {var start=i;
                do i++;while(text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1,i)))}
              else
               throw new Error(c + " is not a valid character")}
           return parseBaseFromArray(digits,base,isNegative)}
         function parseBaseFromArray(digits,base,isNegative)
          {var val=Integer[0],pow=Integer[1],i;
           for(i = digits.length - 1;i >= 0;i--)
            {val = val.add(digits[i].times(pow));pow = pow.times(base)}
           return isNegative?val.negate():val}
         function stringify(digit,alphabet)
          {alphabet = alphabet || DEFAULT_ALPHABET;
           if(digit < alphabet.length)return alphabet[digit];
           return "<" + digit + ">"}
         function toBase(n,base)
          {base = bigInt(base);
           if(base.isZero())
            {if(n.isZero())return {value:[0],isNegative:false};
             throw new Error("Cannot convert nonzero numbers to base 0.")}
           if(base.equals(- 1))
            {if(n.isZero())return {value:[0],isNegative:false};
             if(n.isNegative())
              return {value:
                      [].concat.apply
                       ([],
                        Array.apply(null,Array(- n.toJSNumber())).map
                         (Array.prototype.valueOf,[1,0])),
                      isNegative:false};
             var
              arr=
               Array.apply(null,Array(n.toJSNumber() - 1)).map
                (Array.prototype.valueOf,[0,1]);
             arr.unshift([1]);
             return {value:[].concat.apply([],arr),isNegative:false}}
           var neg=false;
           if(n.isNegative() && base.isPositive()){neg = true;n = n.abs()}
           if(base.isUnit())
            {if(n.isZero())return {value:[0],isNegative:false};
             return {value:
                     Array.apply(null,Array(n.toJSNumber())).map
                      (Number.prototype.valueOf,1),
                     isNegative:neg}}
           var out=[],left=n,divmod;
           while(left.isNegative() || left.compareAbs(base) >= 0)
            {divmod = left.divmod(base);
             left = divmod.quotient;
             var digit=divmod.remainder;
             if(digit.isNegative())
              {digit = base.minus(digit).abs();left = left.next()}
             out.push(digit.toJSNumber())}
           out.push(left.toJSNumber());
           return {value:out.reverse(),isNegative:neg}}
         function toBaseString(n,base,alphabet)
          {var arr=toBase(n,base);
           return (arr.isNegative?"-":"")
                  +
                  arr.value.map(function(x){return stringify(x,alphabet)}).join
                   ("")}
         BigInteger.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         SmallInteger.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         NativeBigInt.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         BigInteger.prototype.toString
         =
         function(radix,alphabet)
          {if(radix === undefined)radix = 10;
           if(radix !== 10)return toBaseString(this,radix,alphabet);
           var
            v=this.value,
            l=v.length,
            str=String(v[--l]),
            zeros="0000000",
            digit;
           while(--l >= 0)
            {digit = String(v[l]);str += zeros.slice(digit.length) + digit}
           var sign=this.sign?"-":"";
           return sign + str};
         SmallInteger.prototype.toString
         =
         function(radix,alphabet)
          {if(radix === undefined)radix = 10;
           if(radix != 10)return toBaseString(this,radix,alphabet);
           return String(this.value)};
         NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
         NativeBigInt.prototype.toJSON
         =
         BigInteger.prototype.toJSON
         =
         SmallInteger.prototype.toJSON
         =
         function(){return this.toString()};
         BigInteger.prototype.valueOf
         =
         function(){return parseInt(this.toString(),10)};
         BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
         SmallInteger.prototype.valueOf = function(){return this.value};
         SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
         NativeBigInt.prototype.valueOf
         =
         NativeBigInt.prototype.toJSNumber
         =
         function(){return parseInt(this.toString(),10)};
         function parseStringValue(v)
          {if(isPrecise(+ v))
            {var x=+ v;
             if(x === truncate(x))
              return supportsNativeBigInt
                      ?new NativeBigInt(BigInt(x))
                      :new SmallInteger(x);
             throw new Error("Invalid integer: " + v)}
           var sign=v[0] === "-";
           if(sign)v = v.slice(1);
           var split=v.split(/e/i);
           if(split.length > 2)
            throw new Error("Invalid integer: " + split.join("e"));
           if(split.length === 2)
            {var exp=split[1];
             if(exp[0] === "+")exp = exp.slice(1);
             exp = + exp;
             if(exp !== truncate(exp) || ! isPrecise(exp))
              throw new
                     Error
                     ("Invalid integer: " + exp + " is not a valid exponent.");
             var text=split[0],decimalPlace=text.indexOf(".");
             if(decimalPlace >= 0)
              {exp -= text.length - decimalPlace - 1;
               text
               =
               text.slice(0,decimalPlace)
               +
               text.slice(decimalPlace + 1)}
             if(exp < 0)
              throw new
                     Error
                     ("Cannot include negative exponent part for integers");
             text += new Array(exp + 1).join("0");
             v = text}
           var isValid=/^([0-9][0-9]*)$/.test(v);
           if(! isValid)throw new Error("Invalid integer: " + v);
           if(supportsNativeBigInt)
            return new NativeBigInt(BigInt(sign?"-" + v:v));
           var r=[],max=v.length,l=LOG_BASE,min=max - l;
           while(max > 0)
            {r.push(+ v.slice(min,max));min -= l;if(min < 0)min = 0;max -= l}
           trim(r);
           return new BigInteger(r,sign)}
         function parseNumberValue(v)
          {if(supportsNativeBigInt)return new NativeBigInt(BigInt(v));
           if(isPrecise(v))
            {if(v !== truncate(v))throw new Error(v + " is not an integer.");
             return new SmallInteger(v)}
           return parseStringValue(v.toString())}
         function parseValue(v)
          {if(typeof v === "number")return parseNumberValue(v);
           if(typeof v === "string")return parseStringValue(v);
           if(typeof v === "bigint")return new NativeBigInt(v);
           return v}
         for(var i=0;i < 1000;i++)
          {Integer[i] = parseValue(i);if(i > 0)Integer[- i] = parseValue(- i)}
         Integer.one = Integer[1];
         Integer.zero = Integer[0];
         Integer.minusOne = Integer[- 1];
         Integer.max = max;
         Integer.min = min;
         Integer.gcd = gcd;
         Integer.lcm = lcm;
         Integer.isInstance
         =
         function(x)
          {return x instanceof BigInteger
                  ||
                  x instanceof SmallInteger
                  ||
                  x instanceof NativeBigInt};
         Integer.randBetween = randBetween;
         Integer.fromArray
         =
         function(digits,base,isNegative)
          {return parseBaseFromArray
                   (digits.map(parseValue),parseValue(base || 10),isNegative)};
         return Integer}
       ();
    function ml_z_normalize(x)
     {var y=x.toJSNumber() | 0;if(x.equals(bigInt(y)))return y;return x}
    function ml_z_shift_right(z1,amt)
     {return ml_z_normalize(bigInt(z1).shiftRight(amt))}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function integers_uint32_compare(x,y)
     {if(x.value > y.value)return 1;if(x.value < y.value)return - 1;return 0}
    function caml_pasta_fp_copy(x,y)
     {for(var i=0,l=x.length;i < l;i++)x[i] = y[i]}
    var caml_pasta_fp_square=plonk_wasm.caml_pasta_fp_square;
    function caml_pasta_fp_mut_square(x)
     {caml_pasta_fp_copy(x,caml_pasta_fp_square(x))}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_pasta_fq_plonk_verifier_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_read
                (offset,urs,caml_jsstring_of_string(path)))}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_pasta_fp_plonk_verifier_index_to_rust(x)
     {return caml_plonk_verifier_index_to_rust
              (x,
               plonk_wasm.WasmFpPlonkVerifierIndex,
               plonk_wasm.WasmFpDomain,
               plonk_wasm.WasmFpPlonkVerificationEvals,
               plonk_wasm.WasmFpPolyComm,
               plonk_wasm.caml_vesta_affine_one,
               plonk_wasm.WasmFpShifts)}
    function caml_pasta_fp_plonk_proof_verify(index,proof)
     {index = caml_pasta_fp_plonk_verifier_index_to_rust(index);
      proof = caml_pasta_fp_proof_to_rust(proof);
      return plonk_wasm.caml_pasta_fp_plonk_proof_verify(index,proof)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function ml_z_shift_left(z1,amt)
     {return ml_z_normalize(bigInt(z1).shiftLeft(amt))}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function caml_js_to_bool(x){return + x}
    function caml_pasta_fq_is_square(x)
     {return caml_js_to_bool(plonk_wasm.caml_pasta_fq_is_square(x))}
    function caml_option_of_maybe_undefined(x){return x === undefined?0:[0,x]}
    function caml_random_oracles_of_rust(x)
     {var
       joint_combiner_chal=x.joint_combiner_chal,
       joint_combiner=x.joint_combiner,
       joint_combiner_ocaml=undefined;
      if(joint_combiner_chal !== undefined && joint_combiner !== undefined)
       joint_combiner_ocaml = [0,[0,joint_combiner_chal],joint_combiner];
      return [0,
              caml_option_of_maybe_undefined(joint_combiner_ocaml),
              x.beta,
              x.gamma,
              [0,x.alpha_chal],
              x.alpha,
              x.zeta,
              x.v,
              x.u,
              [0,x.zeta_chal],
              [0,x.v_chal],
              [0,x.u_chal]]}
    function caml_oracles_of_rust(x)
     {return [0,
              caml_random_oracles_of_rust(x.o),
              [0,x.p_eval0,x.p_eval1],
              caml_u8array_vector_of_rust_flat_vector
               (x.opening_prechallenges,32),
              x.digest_before_evaluations]}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_plonk_wire_to_rust(wire)
     {return plonk_wasm.Wire.create(wire[1],wire[2])}
    function caml_plonk_wires_to_rust(wires)
     {return new
              (plonk_wasm.WasmGateWires)
              (caml_plonk_wire_to_rust(wires[1]),
               caml_plonk_wire_to_rust(wires[2]),
               caml_plonk_wire_to_rust(wires[3]),
               caml_plonk_wire_to_rust(wires[4]),
               caml_plonk_wire_to_rust(wires[5]),
               caml_plonk_wire_to_rust(wires[6]),
               caml_plonk_wire_to_rust(wires[7]))}
    function caml_fp_plonk_gate_to_rust(gate)
     {return new
              (plonk_wasm.WasmFpGate)
              (gate[1],
               caml_plonk_wires_to_rust(gate[2]),
               caml_u8array_vector_to_rust_flat_vector(gate[3]))}
    function caml_pasta_fp_plonk_gate_vector_add(v,x)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_add
              (v,caml_fp_plonk_gate_to_rust(x))}
    function core_kernel_gc_minor_words(){return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_fp_vector_get(v,i)
     {return new (joo_global_object.Uint8Array)(v[i + 1])}
    function integers_uint32_to_int(i){return i.value | 0}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function Base_hash_string(s){return caml_hash(1,1,0,s)}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_string_of_bytes(s){return s}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function core_md5_fd(fd)
     {var ic=caml_ml_open_descriptor_in(fd);
      try {return caml_md5_chan(ic,- 1)}finally {caml_ml_close_channel(ic)}}
    var caml_ephe_key_offset=3;
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function jsoo_z_of_js_string_base(base,s)
     {if(base == 0)
       {base = 10;
        var p=0,sign=1;
        if(s[p] == "-"){sign = - 1;p++}else if(s[p] == "+")p++;
        if(s[p] == "0")
         {p++;
          if(s.length == p)
           return 0;
          else
           {var bc=s[p];
            if(bc == "o" || bc == "O")
             base = 8;
            else
             if(bc == "x" || bc == "X")
              base = 16;
             else
              if(bc == "b" || bc == "B")base = 2;
            if(base != 10){s = s.substring(p + 1);if(sign == - 1)s = "-" + s}}}}
      if(s[0] == "+")s = s.substring(1);
      s = s.replace(/^0+/,"");
      if(s == "-" || s == "")s = "0";
      function digit(code)
       {if(code >= 48 && code <= 57)return code - 48;
        if(code >= 97 && code <= 102)return code - 97 + 10;
        if(code >= 65 && code <= 70)return code - 65 + 10}
      var i=0;
      if(s[i] == "-")i++;
      for(;i < s.length;i++)
       {var c=digit(s.charCodeAt(i));
        if(c == undefined || c >= base)
         caml_invalid_argument("Z.of_substring_base: invalid digit")}
      return ml_z_normalize(bigInt(s,base))}
    function ml_z_of_substring_base(base,s,pos,len)
     {if(pos != 0 || len != caml_ml_string_length(s))
       {s = caml_array_of_string(s);
        if(s.length - pos < len)
         caml_invalid_argument
          ("Z.of_substring_base: invalid offset or length");
        s = caml_string_of_array(s.slice(pos,pos + len))}
      return jsoo_z_of_js_string_base(base,caml_to_js_string(s))}
    var
     caml_pasta_fp_plonk_index_domain_d8_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d8_size;
    function caml_bytes_to_uint8array(ocaml_bytes)
     {var
       length=caml_ml_bytes_length(ocaml_bytes),
       bytes=new (joo_global_object.Uint8Array)(length);
      for(var i=0;i < length;i++)
       bytes[i] = caml_bytes_unsafe_get(ocaml_bytes,i);
      return bytes}
    function caml_pasta_fq_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_pasta_fq_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    function win_cleanup(){}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function unix_inet_addr_of_string(){return 0}
    var
     caml_pasta_fq_plonk_index_domain_d1_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d1_size;
    function ml_z_gcdext_intern(z1,z2)
     {z1 = bigInt(z1);
      z2 = bigInt(z2);
      var
       gcd=bigInt.gcd(z1,z2),
       a=z1,
       b=z2,
       x=bigInt(0),
       lastx=bigInt(1),
       y=bigInt(1),
       lasty=bigInt(1),
       q,
       t,
       r;
      if(z1.equals(bigInt(0)))caml_raise_zero_divide();
      while(! b.equals(bigInt(0)))
       {q = a.divide(b);
        r = a.subtract(q.multiply(b));
        t = x;
        x = lastx.subtract(q.multiply(x));
        lastx = t;
        t = y;
        y = lasty.subtract(q.multiply(y));
        lasty = t;
        a = b;
        b = r}
      return a.lt(bigInt(0))
              ?[0,ml_z_normalize(a.negate()),ml_z_normalize(lastx.negate()),1]
              :[0,ml_z_normalize(a),ml_z_normalize(lastx),1]}
    function integers_uint8_deserialize(reader,size)
     {size[0] = 1;return reader.read8u()}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function integers_uint32_max(unit){return new UInt32(0xFFFFFFFF)}
    function ml_z_abs(z1){return ml_z_normalize(bigInt(z1).abs())}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    var Base_internalhash_fold_float=caml_hash_mix_float;
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_int64_or(x,y){return x.or(y)}
    function integers_uint64_logor(x,y)
     {return new UInt64(caml_int64_or(x.value,y.value))}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.data2 != null)
       caml_invalid_argument("bigstring_destroy: unsupported kind");
      if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      var
       destroyed_data=new (v_bstr.data.__proto__.constructor)(0),
       destroyed_bigstring=
        caml_ba_create_from
         (destroyed_data,null,v_bstr.data_type,v_bstr.kind,v_bstr.layout,[0]);
      destroyed_bigstring.__is_deallocated = true;
      Object.assign(v_bstr,destroyed_bigstring);
      return 0}
    function bigstring_realloc(bigstring,size)
     {if(bigstring.data2 != null)
       caml_invalid_argument
        ("Bigstring.unsafe_destroy_and_resize: unsupported kind");
      if(bigstring.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_realloc: bigstring is already deallocated");
      var new_data=new (bigstring.data.__proto__.constructor)(size);
      new_data.set(bigstring.data.slice(0,size));
      var
       new_bigstring=
        caml_ba_create_from
         (new_data,
          null,
          bigstring.data_type,
          bigstring.kind,
          bigstring.layout,
          [size]);
      bigstring_destroy_stub(bigstring);
      return new_bigstring}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function integers_uint32_of_int32(i){return new UInt32(i)}
    function caml_fp_srs_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_fp_srs_write
              (append,t,caml_jsstring_of_string(path))}
    function ml_z_rem(z1,z2)
     {z2 = bigInt(z2);
      if(z2.equals(bigInt(0)))caml_raise_zero_divide();
      return ml_z_normalize(bigInt(z1).mod(z2))}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function deferred_is_determined(deferred){return deferred.isDetermined}
    function caml_vesta_of_affine(pt)
     {var
       res=
        plonk_wasm.caml_vesta_of_affine
         (rust_affine_of_caml_affine(pt,plonk_wasm.caml_vesta_affine_one));
      free_on_finalize(res);
      return res}
    function integers_uint64_div(x,y)
     {if(y.value.isZero())caml_raise_zero_divide();
      x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return new UInt64(x.value.udivmod(y.value).quotient)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_pallas_poly_comm_to_rust(x)
     {return caml_poly_comm_to_rust_poly_comm
              (x,plonk_wasm.WasmFqPolyComm,plonk_wasm.caml_pallas_affine_one)}
    function caml_pasta_fq_commitments_to_rust(x)
     {function convertArray(v)
       {var n=v.length - 1,res=new Array(n);
        for(var i=0;i < n;++i)
         res[i] = caml_pallas_poly_comm_to_rust(v[i + 1]);
        return js_class_vector_to_rust_vector(res)}
      var
       w_comm=convertArray(x[1]),
       z_comm=caml_pallas_poly_comm_to_rust(x[2]),
       t_comm=caml_pallas_poly_comm_to_rust(x[3]);
      return new (plonk_wasm.WasmFqProverCommitments)(w_comm,z_comm,t_comm)}
    function caml_pasta_fq_opening_proof_to_rust(x)
     {function convert_affines(affines)
       {return caml_array_to_rust_vector
                (affines,
                 rust_affine_of_caml_affine,
                 plonk_wasm.caml_pallas_affine_one)}
      var
       lr=x[1],
       delta=
        rust_affine_of_caml_affine(x[2],plonk_wasm.caml_pallas_affine_one),
       z1=x[3],
       z2=x[4],
       sg=rust_affine_of_caml_affine(x[5],plonk_wasm.caml_pallas_affine_one),
       len=lr.length,
       l_ocaml=new Array(len),
       r_ocaml=new Array(len);
      for(var i=1;i < len;i++){l_ocaml[i] = lr[i][1];r_ocaml[i] = lr[i][2]}
      var l=convert_affines(l_ocaml),r=convert_affines(r_ocaml);
      return new (plonk_wasm.WasmFqOpeningProof)(l,r,delta,z1,z2,sg)}
    function caml_fq_vector_to_rust(v)
     {return caml_u8array_vector_to_rust_flat_vector(v)}
    function caml_pasta_fq_proof_evaluations_to_rust(x)
     {var w=new (plonk_wasm.WasmVecVecFq)(COLUMNS);
      for(var i=0;i < COLUMNS;++i)w.push(caml_fq_vector_to_rust(x[1][i + 1]));
      var
       z=caml_fq_vector_to_rust(x[2]),
       s=new (plonk_wasm.WasmVecVecFq)(PERMUTS_MINUS_1);
      for(i = 0;i < PERMUTS_MINUS_1;++i)
       s.push(caml_fq_vector_to_rust(x[3][i + 1]));
      var
       generic_selector=caml_fq_vector_to_rust(x[4]),
       poseidon_selector=caml_fq_vector_to_rust(x[5]);
      return new
              (plonk_wasm.WasmFqProofEvaluations)
              (w,z,s,generic_selector,poseidon_selector)}
    function caml_pasta_fq_proof_to_rust(x)
     {var
       messages=caml_pasta_fq_commitments_to_rust(x[1]),
       proof=caml_pasta_fq_opening_proof_to_rust(x[2]),
       evals0=caml_pasta_fq_proof_evaluations_to_rust(x[3][1]),
       evals1=caml_pasta_fq_proof_evaluations_to_rust(x[3][2]),
       ft_eval1=x[4],
       public_=caml_fq_vector_to_rust(x[5]),
       prev_challenges=x[6],
       chals_len=prev_challenges.length,
       prev_challenges_scalars=new (plonk_wasm.WasmVecVecFq)(chals_len - 1),
       prev_challenges_comms=new Array(chals_len - 1);
      for(var i=1;i < chals_len;i++)
       {prev_challenges_scalars.push
         (caml_fq_vector_to_rust(prev_challenges[i][1]));
        prev_challenges_comms[i - 1]
        =
        caml_pallas_poly_comm_to_rust(prev_challenges[i][2])}
      prev_challenges_comms
      =
      js_class_vector_to_rust_vector(prev_challenges_comms);
      return new
              (plonk_wasm.WasmFqProverProof)
              (messages,
               proof,
               evals0,
               evals1,
               ft_eval1,
               public_,
               prev_challenges_scalars,
               prev_challenges_comms)}
    function caml_pasta_fq_plonk_proof_verify(index,proof)
     {index = caml_pasta_fq_plonk_verifier_index_to_rust(index);
      proof = caml_pasta_fq_proof_to_rust(proof);
      return plonk_wasm.caml_pasta_fq_plonk_proof_verify(index,proof)}
    function integers_uint32_logxor(x,y){return new UInt32(x.value ^ y.value)}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function deferred_create(promise_creator)
     {var
       deferred=
        {promise:
         new Promise(function(resolve){promise_creator(resolve)}).then
           (function(value)
             {deferred.value = value;deferred.isDetermined = true}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function Base_am_testing(x){return 0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    var
     caml_pasta_fp_plonk_index_public_inputs=
      plonk_wasm.caml_pasta_fp_plonk_index_public_inputs;
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_pallas_affine_deep_copy(pt)
     {return rust_affine_to_caml_affine
              (plonk_wasm.caml_pallas_affine_deep_copy
                (rust_affine_of_caml_affine
                  (pt,plonk_wasm.caml_pallas_affine_one)))}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_bigint_256_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_bigint_256_to_string(x))}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_vesta_to_affine(pt)
     {var res=plonk_wasm.caml_vesta_to_affine(pt);
      return rust_affine_to_caml_affine(res)}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function integers_uint32_add(x,y){return new UInt32(x.value + y.value)}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_pallas_double(x)
     {var res=plonk_wasm.caml_pallas_double(x);
      free_on_finalize(res);
      return res}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_vesta_add(x,y)
     {var res=plonk_wasm.caml_vesta_add(x,y);free_on_finalize(res);return res}
    function caml_bigint_256_test_bit(x,i)
     {return caml_js_to_bool(plonk_wasm.caml_bigint_256_test_bit(x,i))}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    var caml_pasta_fq_compare=plonk_wasm.caml_pasta_fq_compare;
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function integers_uint32_to_int64(i)
     {return caml_int64_create_lo_mi_hi
              (i.value & 0xffffff,
               i.value >>> 24 & 0xffffff,
               i.value >>> 31 & 0xffff)}
    function integers_uint32_mul(x,y)
     {var x_64=integers_uint32_to_int64(x),y_64=integers_uint32_to_int64(y);
      return new UInt32(caml_int64_to_int32(caml_int64_mul(x_64,y_64)))}
    function caml_pasta_fq_commitments_of_rust(x)
     {function convertArray(v)
       {var
         a=js_class_vector_of_rust_vector(v,plonk_wasm.WasmFqPolyComm),
         res=[0];
        for(var i=0;i < a.length;++i)
         res.push(caml_pallas_poly_comm_of_rust(a[i]));
        return res}
      var
       w_comm=convertArray(x.w_comm),
       z_comm=caml_pallas_poly_comm_of_rust(x.z_comm),
       t_comm=caml_pallas_poly_comm_of_rust(x.t_comm);
      x.free();
      return [0,w_comm,z_comm,t_comm]}
    function caml_pasta_fq_opening_proof_of_rust(x)
     {function convert_affines(affines)
       {return caml_array_of_rust_vector
                (affines,
                 plonk_wasm.WasmGPallas,
                 rust_affine_to_caml_affine,
                 false)}
      var
       l=convert_affines(x.lr_0),
       r=convert_affines(x.lr_1),
       delta=rust_affine_to_caml_affine(x.delta),
       z1=x.z1,
       z2=x.z2,
       sg=rust_affine_to_caml_affine(x.sg);
      x.free();
      var len=l.length;
      if(len !== r.length)throw new Error("l and r lengths don't match");
      var lr=new Array(len);
      lr[0] = 0;
      for(var i=1;i < len;i++)
       {var tuple=new Array(3);
        tuple[0] = 0;
        tuple[1] = l[i];
        tuple[2] = r[i];
        lr[i] = tuple}
      return [0,lr,delta,z1,z2,sg]}
    function caml_fq_vector_of_rust(v)
     {return caml_u8array_vector_of_rust_flat_vector(v,32)}
    function caml_pasta_fq_proof_evaluations_of_rust(x)
     {function convertArray(v,n)
       {var res=[0];
        for(var i=0;i < n;++i)res.push(caml_fq_vector_of_rust(v.get(i)));
        return res}
      var
       w=convertArray(x.w,COLUMNS),
       z=caml_fq_vector_of_rust(x.z),
       s=convertArray(x.s,PERMUTS_MINUS_1),
       generic_selector=caml_fq_vector_of_rust(x.generic_selector),
       poseidon_selector=caml_fq_vector_of_rust(x.poseidon_selector);
      x.free();
      return [0,w,z,s,generic_selector,poseidon_selector]}
    function caml_pasta_fq_proof_of_rust(x)
     {var
       messages=caml_pasta_fq_commitments_of_rust(x.commitments),
       proof=caml_pasta_fq_opening_proof_of_rust(x.proof),
       evals0=caml_pasta_fq_proof_evaluations_of_rust(x.evals0),
       evals1=caml_pasta_fq_proof_evaluations_of_rust(x.evals1),
       ft_eval1=x.ft_eval1,
       public_=caml_fq_vector_of_rust(x.public_),
       prev_challenges_scalars=x.prev_challenges_scalars,
       prev_challenges_comms=
        js_class_vector_of_rust_vector
         (x.prev_challenges_comms,plonk_wasm.WasmFqPolyComm),
       chals_len=prev_challenges_comms.length,
       prev_challenges=new Array(chals_len);
      prev_challenges[0] = 0;
      for(var i=1;i < chals_len;i++)
       {var res=new Array(3);
        res[0] = 0;
        res[1] = caml_fq_vector_of_rust(prev_challenges_scalars.get(i - 1));
        res[2] = caml_pallas_poly_comm_of_rust(prev_challenges_comms[i]);
        prev_challenges[i] = res}
      return [0,
              messages,
              proof,
              [0,evals0,evals1],
              ft_eval1,
              public_,
              prev_challenges]}
    function caml_pasta_fq_plonk_proof_create
     (index,witness_cols,prev_challenges,prev_sgs)
     {var w=new (plonk_wasm.WasmVecVecFq)(witness_cols.length - 1);
      for(var i=1;i < witness_cols.length;i++)
       w.push(caml_fq_vector_to_rust(witness_cols[i]));
      witness_cols = w;
      prev_challenges = caml_fq_vector_to_rust(prev_challenges);
      prev_sgs
      =
      caml_array_to_rust_vector
       (prev_sgs,rust_affine_of_caml_affine,plonk_wasm.caml_pallas_affine_one);
      var
       res=
        plonk_wasm.caml_pasta_fq_plonk_proof_create
         (index,witness_cols,prev_challenges,prev_sgs),
       proof=caml_pasta_fq_proof_of_rust(res);
      return proof}
    function caml_int64_is_zero(x){return + x.isZero()}
    function Base_int_math_int64_pow_stub(base,exponent)
     {var one=[255,1,0,0],mul=[one,base,one,one],res=one;
      while(! caml_int64_is_zero(exponent))
       {mul[1] = caml_int64_mul(mul[1],mul[3]);
        mul[2] = caml_int64_mul(mul[1],mul[1]);
        mul[3] = caml_int64_mul(mul[2],mul[1]);
        res = caml_int64_mul(res,mul[exponent[1] & 3]);
        exponent = caml_int64_shift_right_unsigned(exponent,2)}
      return res}
    function caml_sys_const_word_size(){return 32}
    function integers_uint64_to_int64(i)
     {i = i.value;return caml_int64_create_lo_mi_hi(i.lo,i.mi,i.hi | 0)}
    function ml_z_popcount(z)
     {z = bigInt(z);
      var zero=bigInt(0),one=bigInt(1);
      if(z.lt(zero))caml_raise_constant(caml_named_value("ml_z_overflow"));
      var i;
      for(i = 0;! z.equals(zero);i++)z = z.and(z.prev());
      if(i != (i | 0))caml_raise_constant(caml_named_value("ml_z_overflow"));
      return i | 0}
    function ml_z_hamdist(z1,z2)
     {if(bigInt(z1).isNegative() != bigInt(z2).isNegative())
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      if
       ((z1 != (z1 | 0) || z2 != (z2 | 0))
        &&
        (bigInt(z1).isNegative() || bigInt(z2).isNegative()))
       caml_invalid_argument("Z.hamdist: negative arguments");
      return ml_z_popcount(bigInt(z1).xor(bigInt(z2)))}
    function ml_z_mul(z1,z2)
     {return ml_z_normalize(bigInt(z1).multiply(bigInt(z2)))}
    function ml_z_pow(z1,i1)
     {i1 = bigInt(i1);
      if(i1.lt(bigInt(0)))
       caml_invalid_argument("Z.pow: exponent must be nonnegative");
      return ml_z_normalize(bigInt(z1).pow(i1))}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function deferred_peek(deferred)
     {if(! deferred.isDetermined || deferred.isError)return 0;
      return [0,deferred.value]}
    function ml_z_logand(z1,z2)
     {return ml_z_normalize(bigInt(z1).and(bigInt(z2)))}
    function caml_vesta_of_affine_coordinates(x,y)
     {var res=plonk_wasm.caml_vesta_of_affine_coordinates(x,y);
      free_on_finalize(res);
      return res}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function deferred_to_promise(deferred){return deferred.promise}
    var expect_test_collector_saved_stderr,expect_test_collector_saved_stdout;
    function expect_test_collector_after_test(vstdout,vstderr)
     {caml_ml_channels[vstdout] = expect_test_collector_saved_stdout;
      caml_ml_channels[vstderr] = expect_test_collector_saved_stderr;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function ml_z_fits_int(z1){return z1 == (z1 | 0)?1:0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    var Base_internalhash_fold_int=caml_hash_mix_int;
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_bigint_256_of_decimal_string(s)
     {return plonk_wasm.caml_bigint_256_of_decimal_string
              (caml_jsstring_of_string(s))}
    function Base_int_math_int32_clz(x)
     {var n=32,y;
      y = x >> 16;
      if(y != 0){n = n - 16;x = y}
      y = x >> 8;
      if(y != 0){n = n - 8;x = y}
      y = x >> 4;
      if(y != 0){n = n - 4;x = y}
      y = x >> 2;
      if(y != 0){n = n - 2;x = y}
      y = x >> 1;
      if(y != 0)return n - 2;
      return n - x}
    function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x)}
    var caml_pasta_fp_add=plonk_wasm.caml_pasta_fp_add;
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function core_kernel_time_ns_format(time,format)
     {var
       d=new Date(time * 1000),
       formatjs=caml_to_js_string(format),
       jstring=joo_global_object.strftime(formatjs,d);
      return caml_js_to_string(jstring)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_pasta_fp_plonk_verifier_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fp_plonk_verifier_index_write
              (append,
               caml_pasta_fp_plonk_verifier_index_to_rust(t),
               caml_jsstring_of_string(path))}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function integers_uint16_deserialize(reader,size)
     {size[0] = 2;return reader.read16u()}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    var internalhash_fold_bigstring=caml_hash_mix_bigstring;
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function ml_z_sign(z1){return bigInt(z1).compare(bigInt.zero)}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_fp_srs_b_poly_commitment(srs,chals)
     {var
       res=
        plonk_wasm.caml_fp_srs_b_poly_commitment
         (srs,caml_u8array_vector_to_rust_flat_vector(chals));
      return caml_vesta_poly_comm_of_rust(res)}
    function ml_z_nextprime(z1)
     {z1 = bigInt(z1);
      var one=bigInt(1),two=bigInt(2);
      if(z1.lt(one) || z1.equals(one))return 2;
      if(z1.and(one).equals(one))z1 = z1.add(two);else z1 = z1.add(one);
      while(true)
       if(z1.isProbablePrime(25))
        return ml_z_normalize(z1);
       else
        z1 = z1.add(two)}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    var caml_pasta_fq_equal=plonk_wasm.caml_pasta_fq_equal;
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function fq_oracles_create(lgr_comm,verifier_index,proof)
     {return caml_oracles_of_rust
              (plonk_wasm.fq_oracles_create
                (caml_array_to_rust_vector
                  (lgr_comm,caml_pallas_poly_comm_to_rust),
                 caml_pasta_fq_plonk_verifier_index_to_rust(verifier_index),
                 caml_pasta_fq_proof_to_rust(proof)))}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    var
     caml_pasta_fp_plonk_index_domain_d1_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d1_size;
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_vesta_negate(x)
     {var res=plonk_wasm.caml_vesta_negate(x);
      free_on_finalize(res);
      return res}
    function ml_z_div(z1,z2)
     {z2 = bigInt(z2);
      if(z2.equals(bigInt(0)))caml_raise_zero_divide();
      return ml_z_normalize(bigInt(z1).divide(bigInt(z2)))}
    function ml_z_divexact(z1,z2){return ml_z_div(z1,z2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_vesta_rng(i)
     {var res=plonk_wasm.caml_vesta_rng(i);free_on_finalize(res);return res}
    function caml_pasta_fp_plonk_verifier_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return caml_pasta_fp_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_read
                (offset,urs,caml_jsstring_of_string(path)))}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_fq_srs_read(offset,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      var
       res=
        plonk_wasm.caml_fq_srs_read(offset,caml_jsstring_of_string(path));
      return res?[0,res]:0}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_pasta_fp_mut_add(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_add(x,y))}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_zarith_marshal(writer,v,sz)
     {v = bigInt(v);
      var bits=v.toArray(Math.pow(2,32));
      writer.write(8,bits.isNegative?1:0);
      var block=bits.value.length,len=block * 4;
      writer.write(32,len);
      for(var i=block - 1;i >= 0;i--)
       {writer.write(8,bits.value[i] >>> 0 & 0xff);
        writer.write(8,bits.value[i] >>> 8 & 0xff);
        writer.write(8,bits.value[i] >>> 16 & 0xff);
        writer.write(8,bits.value[i] >>> 24 & 0xff)}
      sz[0] = 4 * (1 + ((len + 3) / 4 | 0));
      sz[1] = 8 * (1 + ((len + 7) / 8 | 0))}
    function caml_fp_vector_emplace_back(v,x){v.push(x)}
    var
     Base_internalhash_fold_int64=caml_hash_mix_int64,
     caml_vesta_endo_scalar=plonk_wasm.caml_vesta_endo_scalar;
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    function caml_fq_srs_b_poly_commitment(srs,chals)
     {var
       res=
        plonk_wasm.caml_fq_srs_b_poly_commitment
         (srs,caml_u8array_vector_to_rust_flat_vector(chals));
      return caml_pallas_poly_comm_of_rust(res)}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_js_equals(x,y){return + (x == y)}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function bigstring_to_typed_array(bs){return bs.data}
    function integers_uint16_of_string(x)
     {var y=integers_uint32_of_string(x);return y.value & 0xFFFF}
    function ml_z_fits_nativeint(z1){return ml_z_fits_int(z1)}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function integers_uint64_logxor(x,y)
     {return new UInt64(caml_int64_xor(x.value,y.value))}
    function integers_uint32_of_int(i){return new UInt32(i)}
    function caml_pallas_of_affine(pt)
     {var
       res=
        plonk_wasm.caml_pallas_of_affine
         (rust_affine_of_caml_affine(pt,plonk_wasm.caml_pallas_affine_one));
      free_on_finalize(res);
      return res}
    var caml_pasta_fp_compare=plonk_wasm.caml_pasta_fp_compare;
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_out_channel_pos_fd(chan)
     {var info=caml_ml_channels[chan];return info.offset}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function integers_uint64_to_string(i)
     {return caml_int64_format(caml_new_string("%u"),i.value)}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function integers_uint32_serialize(writer,v,size)
     {writer.write(32,v.value);size[0] = 4;size[1] = 4}
    function caml_pasta_fp_poseidon_params_create(){return [0]}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_pasta_fq_sqrt(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fq_sqrt(x))}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function ml_z_hash(z1)
     {var a=bigInt(z1).toArray(Math.pow(2,32)),acc=0;
      for(var i=0;i < a.value.length;i++)
       acc = caml_hash_mix_int(acc,a.value[i]);
      if(a.value.length % 2 != 0)acc = caml_hash_mix_int(acc,0);
      if(a.isNegative)acc = acc + 1;
      return acc | 0}
    function integers_uint64_logand(x,y)
     {return new UInt64(caml_int64_and(x.value,y.value))}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_fq_vector_emplace_back(v,x){v.push(x)}
    function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x)}
    var caml_pasta_fp_of_bigint=plonk_wasm.caml_pasta_fp_of_bigint;
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function ml_z_root(z,i)
     {var zero=bigInt(0),one=bigInt(1);
      z = bigInt(z);
      if(i % 2 === 0 && z.lt(zero))
       caml_invalid_argument("Z.root: even root of a negative number");
      if(z.equals(zero) || z.equals(one))return ml_z_normalize(z);
      var start=zero,end=z,ans=null,two=bigInt(2);
      while(start.leq(end))
       {var mid=start.add(end).divide(two),po=mid.pow(i);
        if(po.equals(z))
         return ml_z_normalize(mid);
        else
         if(po.lt(z)){start = mid.next();ans = mid}else end = mid.prev()}
      return ml_z_normalize(ans)}
    function ml_z_sqrt_rem(z)
     {z = bigInt(z);
      var zero=bigInt(0);
      if(z.lt(zero))
       caml_invalid_argument("Z.sqrt_rem: square root of a negative number");
      var
       root=bigInt(ml_z_root(z,2)),
       mul=root.multiply(root),
       diff=z.subtract(mul);
      return [0,ml_z_normalize(root),ml_z_normalize(diff)]}
    var caml_ephe_data_offset=2;
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    var
     caml_pasta_fp_plonk_index_max_degree=
      plonk_wasm.caml_pasta_fp_plonk_index_max_degree;
    function caml_raw_backtrace_next_slot(){return 0}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    var caml_pasta_fq_add=plonk_wasm.caml_pasta_fq_add;
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_vesta_affine_deep_copy(pt)
     {return rust_affine_to_caml_affine
              (plonk_wasm.caml_vesta_affine_deep_copy
                (rust_affine_of_caml_affine
                  (pt,plonk_wasm.caml_vesta_affine_one)))}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function bin_prot_blit_buf_bytes_stub
     (v_src_pos,v_buf,v_dst_pos,v_str,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {c = caml_ba_get_1(v_buf,v_src_pos + i);
        caml_string_unsafe_set(v_str,v_dst_pos + i,c)}
      return 0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function ml_z_of_bits(z1)
     {var r=bigInt.zero,base1=bigInt(256),base=bigInt.one;
      for(var i=0;i < caml_ml_string_length(z1);i++)
       {var d=caml_string_unsafe_get(z1,i);
        r = bigInt(base).multiply(d).add(r);
        base = bigInt(base).multiply(base1)}
      return ml_z_normalize(r)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_pasta_fq_plonk_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return plonk_wasm.caml_pasta_fq_plonk_index_read
              (offset,urs,caml_jsstring_of_string(path))}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_zarith_unmarshal(reader,sz)
     {var negate;
      switch(reader.read8u())
       {case 1:negate = true;break;
        case 0:negate = false;break;
        default:caml_failwith("input_value: z (malformed input)")}
      var len=reader.read32u(),x=bigInt(0);
      for(var i=0;i < len / 4;i++)
       {var y=bigInt(reader.read8u());
        y = y.add(reader.read8u() << 8);
        y = y.add(reader.read8u() << 16);
        y = y.add(reader.read8u() << 24 >>> 0);
        x = y.shiftLeft(i * 32).add(x)}
      if(negate)x = x.negate();
      sz[0] = len + 4;
      return ml_z_normalize(x)}
    function caml_get_current_callstack(){return [0]}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    var caml_pasta_fq_of_int=plonk_wasm.caml_pasta_fq_of_int;
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function integers_uint8_of_string(x)
     {var y=integers_uint32_of_string(x);return x.value & 0xFF}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function integers_uint32_sub(x,y){return new UInt32(x.value - y.value)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function caml_pasta_fq_plonk_gate_vector_create()
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fq_plonk_gate_vector_create())}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function integers_uint32_div(x,y){return new UInt32(x.value / y.value)}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function fp_oracles_create(lgr_comm,verifier_index,proof)
     {return caml_oracles_of_rust
              (plonk_wasm.fp_oracles_create
                (caml_array_to_rust_vector
                  (lgr_comm,caml_vesta_poly_comm_to_rust),
                 caml_pasta_fp_plonk_verifier_index_to_rust(verifier_index),
                 caml_pasta_fp_proof_to_rust(proof)))}
    function caml_fq_vector_get(v,i)
     {return new (joo_global_object.Uint8Array)(v[i + 1])}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function bigstring_blit_string_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1
        (v_bstr,v_dst_pos + i,caml_string_get(v_str,v_src_pos + i));
      return 0}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_fp_vector_create(){return [0]}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_pallas_to_affine(pt)
     {var res=plonk_wasm.caml_pallas_to_affine(pt);
      return rust_affine_to_caml_affine(res)}
    function caml_fq_srs_create(i)
     {return free_on_finalize(plonk_wasm.caml_fq_srs_create(i))}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    var core_array_unsafe_float_blit=caml_array_blit;
    function caml_spacetime_enabled(_unit){return 0}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function integers_uint64_marshal(writer,v,sizes)
     {caml_int64_marshal(writer,v.value,sizes)}
    function caml_bytes_of_uint8array(uint8array)
     {var length=uint8array.length,ocaml_bytes=caml_create_bytes(length);
      for(var i=0;i < length;i++)
       caml_bytes_unsafe_set(ocaml_bytes,i,uint8array[i]);
      return ocaml_bytes}
    function caml_pasta_fq_plonk_gate_vector_digest(gate_vector)
     {var
       uint8array=
        plonk_wasm.caml_pasta_fq_plonk_gate_vector_digest(gate_vector);
      return caml_bytes_of_uint8array(uint8array)}
    function core_kernel_gc_compactions(){return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    var
     caml_pasta_fq_plonk_index_domain_d4_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d4_size;
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_pasta_fp_plonk_gate_vector_digest(gate_vector)
     {var
       uint8array=
        plonk_wasm.caml_pasta_fp_plonk_gate_vector_digest(gate_vector);
      return caml_bytes_of_uint8array(uint8array)}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function fp_oracles_dummy()
     {return caml_oracles_of_rust(plonk_wasm.fp_oracles_dummy())}
    function Base_clear_caml_backtrace_pos(x){return 0}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    var caml_bigint_256_compare=plonk_wasm.caml_bigint_256_compare;
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function Core_kernel_heap_block_is_heap_block(x)
     {return + (x instanceof Array)}
    function bigstring_blit_bytes_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1(v_bstr,v_dst_pos + i,caml_bytes_get(v_str,v_src_pos + i));
      return 0}
    function ml_z_pred(z1){return ml_z_normalize(bigInt(z1).prev())}
    function ml_z_extract(z1,pos,len)
     {z1 = bigInt(z1);
      return ml_z_normalize
              (z1.shiftRight(pos).and(bigInt(2).pow(len).subtract(1)))}
    function ml_z_lognot(z1){return ml_z_normalize(bigInt(z1).not())}
    var caml_pasta_fq_rng=plonk_wasm.caml_pasta_fq_rng;
    function caml_oracles_to_rust(x,klass,roKlass)
     {return new
              klass
              (caml_random_oracles_to_rust(x[1],roKlass),
               x[2][1],
               x[2][2],
               caml_u8array_vector_to_rust_flat_vector(x[3]),
               x[4])}
    function fp_oracles_deep_copy(x)
     {return caml_oracles_of_rust
              (plonk_wasm.fp_oracles_deep_copy
                (caml_oracles_to_rust
                  (x,plonk_wasm.WasmFpOracles,plonk_wasm.WasmFpRandomOracles)))}
    function caml_pasta_fp_is_square(x)
     {return caml_js_to_bool(plonk_wasm.caml_pasta_fp_is_square(x))}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function core_kernel_gc_top_heap_words(){return 0}
    function caml_pasta_fq_poseidon_params_create(){return [0]}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_fq_srs_lagrange_commitment(t,domain_size,i)
     {var res=plonk_wasm.caml_fq_srs_lagrange_commitment(t,domain_size,i);
      return caml_pallas_poly_comm_of_rust(res)}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    var caml_pallas_endo_scalar=plonk_wasm.caml_pallas_endo_scalar;
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    var caml_bigint_256_print=plonk_wasm.caml_bigint_256_print;
    function caml_bigint_256_of_numeral(s,len,base)
     {return plonk_wasm.caml_bigint_256_of_numeral
              (caml_jsstring_of_string(s),len,base)}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    var caml_pasta_fq_square=plonk_wasm.caml_pasta_fq_square;
    function caml_pasta_fq_mut_square(x)
     {caml_pasta_fq_copy(x,caml_pasta_fq_square(x))}
    function ml_z_numbits(z1)
     {z1 = bigInt(z1).abs();
      var n=0,upperBound=bigInt.one;
      while(upperBound.leq(z1)){n += 1;upperBound = upperBound.multiply(2)}
      return n}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_pasta_fq_poseidon_block_cipher(_fake_params,fq_vector)
     {var
       wasm_flat_vector=
        plonk_wasm.caml_pasta_fq_poseidon_block_cipher
         (caml_fq_vector_to_rust(fq_vector)),
       new_fq_vector=caml_fq_vector_of_rust(wasm_flat_vector);
      new_fq_vector.forEach(function(a,i){fq_vector[i] = a})}
    function caml_lazy_make_forward(v){return [250,v]}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function integers_uint64_mul(x,y)
     {return new UInt64(caml_int64_mul(x.value,y.value))}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function ml_z_init(unit)
     {caml_custom_ops["_z"]
      =
      {serialize:caml_zarith_marshal,
       deserialize:caml_zarith_unmarshal,
       hash:ml_z_hash};
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_pasta_fp_plonk_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return plonk_wasm.caml_pasta_fp_plonk_index_read
              (offset,urs,caml_jsstring_of_string(path))}
    var caml_pasta_fp_negate=plonk_wasm.caml_pasta_fp_negate;
    function bin_prot_blit_string_buf_stub
     (v_src_pos,v_str,v_dst_pos,v_buf,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {c = caml_string_unsafe_get(v_str,v_src_pos + i);
        caml_ba_set_1(v_buf,v_dst_pos + i,c)}
      return 0}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    var caml_pasta_fp_sub=plonk_wasm.caml_pasta_fp_sub;
    function caml_pasta_fp_mut_sub(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_sub(x,y))}
    function caml_return_exn_constant(tag){return tag}
    function integers_uint64_unmarshal(reader,size)
     {return new UInt64(caml_int64_unmarshal(reader,size))}
    function ml_z_size(z1)
     {return bigInt(z1).toArray(Math.pow(2,32)).value.length}
    function ml_z_fits_int64(z1)
     {z1 = bigInt(z1);
      return z1.compare(bigInt("9223372036854775807"))
              <=
              0
              &&
              z1.compare(bigInt("-9223372036854775808"))
              >=
              0
              ?1
              :0}
    function ml_z_to_int64(z1)
     {z1 = bigInt(z1);
      if(! ml_z_fits_int64(z1))
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      var
       a=z1.and(bigInt(0xffffff)).toJSNumber() | 0,
       b=z1.shiftRight(24).and(bigInt(0xffffff)).toJSNumber() | 0,
       c=z1.shiftRight(48).and(bigInt(0xffff)).toJSNumber() | 0,
       x=[255,a,b,c];
      return x}
    function caml_backtrace_status(){return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_fp_srs_commit_evaluations(t,domain_size,fps)
     {var
       res=
        plonk_wasm.caml_fp_srs_commit_evaluations
         (t,domain_size,caml_fp_vector_to_rust(fps));
      return caml_vesta_poly_comm_of_rust(res)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_pasta_fp_plonk_proof_create
     (index,witness_cols,prev_challenges,prev_sgs)
     {var w=new (plonk_wasm.WasmVecVecFp)(witness_cols.length - 1);
      for(var i=1;i < witness_cols.length;i++)
       w.push(caml_fp_vector_to_rust(witness_cols[i]));
      witness_cols = w;
      prev_challenges = caml_fp_vector_to_rust(prev_challenges);
      prev_sgs
      =
      caml_array_to_rust_vector
       (prev_sgs,rust_affine_of_caml_affine,plonk_wasm.caml_vesta_affine_one);
      var
       res=
        plonk_wasm.caml_pasta_fp_plonk_proof_create
         (index,witness_cols,prev_challenges,prev_sgs),
       proof=caml_pasta_fp_proof_of_rust(res);
      return proof}
    var
     caml_pasta_fq_two_adic_root_of_unity=
      plonk_wasm.caml_pasta_fq_two_adic_root_of_unity;
    function caml_vesta_scale(x,y)
     {var res=plonk_wasm.caml_vesta_scale(x,y);
      free_on_finalize(res);
      return res}
    function ml_z_install_frametable(unit){return 0}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(s2,i2 + i,caml_ba_get_1(s1,i1 + i));
      return 0}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_pasta_fp_sqrt(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fp_sqrt(x))}
    function Base_int_math_int_popcount(v)
     {v = v - (v >>> 1 & 0x55555555);
      v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
      return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    var caml_pasta_fp_rng=plonk_wasm.caml_pasta_fp_rng;
    function caml_pasta_fp_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_pasta_fp_to_string(x))}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    function deferred_of_promise(promise)
     {var
       deferred=
        {promise:
         promise.then
           (function(value)
             {deferred.value = value;
              deferred.isDetermined = true;
              return value}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    var caml_pasta_fp_equal=plonk_wasm.caml_pasta_fp_equal;
    function integers_uint32_deserialize(reader,size)
     {size[0] = 4;return new UInt32(reader.read32u())}
    var caml_bigint_256_div=plonk_wasm.caml_bigint_256_div;
    function integers_uint32_to_string(i)
     {return caml_new_string(i.value.toString())}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_vesta_sub(x,y)
     {var res=plonk_wasm.caml_vesta_sub(x,y);free_on_finalize(res);return res}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function bigstringaf_memcmp_bigstring(ba1,ba1_off,ba2,ba2_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba1,ba1_off + i),caml_ba_get_1(ba2,ba2_off + i));
        if(c != 0)return c}
      return 0}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    var Base_internalhash_fold_string=caml_hash_mix_string;
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_fq_srs_batch_accumulator_check(srs,comms,chals)
     {var
       rust_comms=
        caml_array_to_rust_vector
         (comms,rust_affine_of_caml_affine,plonk_wasm.caml_pallas_affine_one),
       rust_chals=caml_fq_vector_to_rust(chals),
       ok=
        plonk_wasm.caml_fq_srs_batch_accumulator_check
         (srs,rust_comms,rust_chals);
      return ok}
    var caml_pasta_fp_deep_copy=plonk_wasm.caml_pasta_fp_deep_copy;
    function ml_z_add(z1,z2)
     {return ml_z_normalize(bigInt(z1).add(bigInt(z2)))}
    function ml_z_cdiv(z1,z2)
     {var z1_pos=ml_z_sign(z1),z2_pos=ml_z_sign(z2);
      if(z1_pos * z2_pos > 0)
       if(! bigInt(z1).mod(bigInt(z2)).equals(bigInt(0)))
        return ml_z_add(ml_z_div(z1,z2),bigInt(1));
      return ml_z_div(z1,z2)}
    function bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(dst,dst_off + i,caml_string_unsafe_get(src,src_off + i))}
    function caml_fq_srs_commit_evaluations(t,domain_size,fqs)
     {var
       res=
        plonk_wasm.caml_fq_srs_commit_evaluations
         (t,domain_size,caml_fq_vector_to_rust(fqs));
      return caml_pallas_poly_comm_of_rust(res)}
    function caml_pasta_fp_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_pasta_fp_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function integers_uint32_hash(v){return v.value}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    var caml_pasta_fq_mul=plonk_wasm.caml_pasta_fq_mul;
    function ml_z_of_int64(i64)
     {var neg=false;
      if(caml_int64_compare(i64,[255,0,0,0]) < 0)
       {neg = true;i64 = caml_int64_neg(i64)}
      var
       x=
        bigInt(i64[1]).add(bigInt(i64[2]).shiftLeft(24)).add
         (bigInt(i64[3]).shiftLeft(48));
      if(neg)x = x.negate();
      return ml_z_normalize(x)}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function integers_uint64_of_int(i)
     {return new UInt64(caml_int64_of_int32(i))}
    function ml_z_neg(z1){return ml_z_normalize(bigInt(z1).negate())}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    function expect_test_collector_before_test(voutput,vstdout,vstderr)
     {expect_test_collector_saved_stderr = caml_ml_channels[vstderr];
      expect_test_collector_saved_stdout = caml_ml_channels[vstdout];
      var output=caml_ml_channels[voutput];
      caml_ml_channels[vstdout] = output;
      caml_ml_channels[vstderr] = output;
      return 0}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function ml_z_of_int(i){return i | 0}
    function ml_z_of_int32(i32){return ml_z_of_int(i32)}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_pasta_fq_to_bytes(x)
     {var res=plonk_wasm.caml_pasta_fq_to_bytes(x);
      return caml_bytes_of_uint8array(plonk_wasm.caml_pasta_fq_to_bytes(x))}
    function caml_pallas_sub(x,y)
     {var res=plonk_wasm.caml_pallas_sub(x,y);
      free_on_finalize(res);
      return res}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function caml_pasta_fq_mut_add(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_add(x,y))}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function integers_uint64_rem(x,y)
     {if(y.value.isZero())caml_raise_zero_divide();
      x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return new UInt64(x.value.udivmod(y.value).modulus)}
    function ml_z_logor(z1,z2)
     {return ml_z_normalize(bigInt(z1).or(bigInt(z2)))}
    function ml_z_fits_int32(z1){return ml_z_fits_int(z1)}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_pasta_fq_mut_mul(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_mul(x,y))}
    var
     caml_pasta_fp_size=plonk_wasm.caml_pasta_fp_size,
     caml_bigint_256_num_limbs=plonk_wasm.caml_bigint_256_num_limbs;
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_pasta_fp_of_int=plonk_wasm.caml_pasta_fp_of_int;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function integers_ulong_size(unit){return 4}
    function caml_pasta_fp_plonk_verifier_index_deep_copy(x)
     {return caml_pasta_fp_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_deep_copy
                (caml_pasta_fp_plonk_verifier_index_to_rust(x)))}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function integers_uint32_shift_left(x,y){return new UInt32(x.value << y)}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function bin_prot_blit_float_array_buf_stub
     (v_src_pos,v_arr,v_dst_pos,v_buf,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {var
         f=caml_array_get(v_arr,v_src_pos + i),
         a=caml_int64_to_bytes(caml_int64_bits_of_float(f));
        for(var j=0;j < 8;j++)
         caml_ba_set_1(v_buf,v_dst_pos + j + i * 8,a[7 - j])}
      return 0}
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function Base_int_math_int_pow_stub(base,exponent)
     {var one=1,mul=[one,base,one,one],res=one;
      while(! exponent == 0)
       {mul[1] = mul[1] * mul[3] | 0;
        mul[2] = mul[1] * mul[1] | 0;
        mul[3] = mul[2] * mul[1] | 0;
        res = res * mul[exponent & 3] | 0;
        exponent = exponent >> 2}
      return res}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_pasta_fp_poseidon_block_cipher(_fake_params,fp_vector)
     {var
       wasm_flat_vector=
        plonk_wasm.caml_pasta_fp_poseidon_block_cipher
         (caml_fp_vector_to_rust(fp_vector)),
       new_fp_vector=caml_fp_vector_of_rust(wasm_flat_vector);
      new_fp_vector.forEach(function(a,i){fp_vector[i] = a})}
    function caml_vesta_double(x)
     {var res=plonk_wasm.caml_vesta_double(x);
      free_on_finalize(res);
      return res}
    function caml_pasta_fp_of_string(x)
     {return plonk_wasm.caml_pasta_fp_of_string(caml_jsstring_of_string(x))}
    function ml_z_testbit(z,pos)
     {z = bigInt(z);return z.shiftRight(pos).and(bigInt(1)).toJSNumber() | 0}
    function core_kernel_gc_major_plus_minor_words(){return 0}
    function caml_pasta_fp_plonk_verifier_index_shifts(log2_size)
     {return caml_plonk_verification_shifts_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_shifts(log2_size))}
    function bin_prot_blit_bytes_buf_stub
     (v_src_pos,v_str,v_dst_pos,v_buf,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {c = caml_string_unsafe_get(v_str,v_src_pos + i);
        caml_ba_set_1(v_buf,v_dst_pos + i,c)}
      return 0}
    function caml_int64_sub(x,y){return x.sub(y)}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function bin_prot_blit_buf_stub(v_src_pos,v_src,v_dst_pos,v_dst,v_len)
     {var
       v_src2=bigstring_of_array_buffer(v_src.data.buffer),
       v_dst2=bigstring_of_array_buffer(v_dst.data.buffer),
       c;
      for(var i=0;i < v_len;i++)
       {c = caml_ba_get_1(v_src2,v_src_pos + i);
        caml_ba_set_1(v_dst2,v_dst_pos + i,c)}
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_sys_const_int_size(){return 32}
    function caml_fp_srs_lagrange_commitment(t,domain_size,i)
     {var res=plonk_wasm.caml_fp_srs_lagrange_commitment(t,domain_size,i);
      return caml_vesta_poly_comm_of_rust(res)}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function ml_z_sqrt(z1)
     {var z=bigInt(z1),zero=bigInt(0);
      if(z.lt(zero))
       caml_invalid_argument("Z.sqrt: square root of a negative number");
      return ml_z_root(z,2)}
    function caml_fp_srs_batch_accumulator_check(srs,comms,chals)
     {var
       rust_comms=
        caml_array_to_rust_vector
         (comms,rust_affine_of_caml_affine,plonk_wasm.caml_vesta_affine_one),
       rust_chals=caml_fp_vector_to_rust(chals),
       ok=
        plonk_wasm.caml_fp_srs_batch_accumulator_check
         (srs,rust_comms,rust_chals);
      return ok}
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function deferred_value_exn(deferred)
     {if(! deferred.isDetermined)
       throw Error("Deferred has not returned yet.");
      if(deferred.isError)throw deferred.error;
      return deferred.value}
    function ml_z_probab_prime(z,i){return bigInt(z).isProbablePrime(i)?1:0}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    var caml_bigint_256_deep_copy=plonk_wasm.caml_bigint_256_deep_copy;
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    var caml_pasta_fq_of_bigint=plonk_wasm.caml_pasta_fq_of_bigint;
    function caml_fq_vector_length(v){return v.length - 1}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_pasta_fp_plonk_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fp_plonk_index_write
              (append,t,caml_jsstring_of_string(path))}
    function caml_fp_vector_length(v){return v.length - 1}
    function caml_pasta_fq_inv(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fq_inv(x))}
    function ml_z_to_int(z1)
     {if(z1 == (z1 | 0))return z1 | 0;
      caml_raise_constant(caml_named_value("ml_z_overflow"))}
    function bigstringaf_blit_to_bytes(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_string_unsafe_set(dst,dst_off + i,caml_ba_get_1(src,src_off + i))}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_pasta_fp_inv(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fp_inv(x))}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_const_big_endian(){return 0}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function core_kernel_gc_major_words(){return 0}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function integers_uint32_logand(x,y){return new UInt32(x.value & y.value)}
    function ml_z_succ(z1){return ml_z_normalize(bigInt(z1).next())}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_pasta_fq_plonk_proof_dummy()
     {return caml_pasta_fq_proof_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_proof_dummy())}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function integers_uint64_max(unit)
     {var x=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      x.hi = x.hi >>> 0;
      return new UInt64(x)}
    function integers_uint64_of_int64(i)
     {return new UInt64(caml_int64_create_lo_mi_hi(i.lo,i.mi,i.hi >>> 0))}
    function ml_z_gcd(z1,z2)
     {return ml_z_normalize(bigInt.gcd(bigInt(z1),bigInt(z2)).abs())}
    function caml_pasta_fp_to_bytes(x)
     {var res=plonk_wasm.caml_pasta_fp_to_bytes(x);
      return caml_bytes_of_uint8array(plonk_wasm.caml_pasta_fp_to_bytes(x))}
    function integers_size_t_size(unit){return 4}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    var
     caml_pasta_fp_plonk_index_domain_d4_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d4_size;
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function ml_z_div_rem(z1,z2){return [0,ml_z_div(z1,z2),ml_z_rem(z1,z2)]}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_pallas_rng(i)
     {var res=plonk_wasm.caml_pallas_rng(i);free_on_finalize(res);return res}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_pasta_fq_plonk_index_create(gates,public_inputs,urs)
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fq_plonk_index_create
                (gates,public_inputs,urs))}
    function caml_ml_set_channel_name(){return 0}
    var caml_pasta_fp_mul=plonk_wasm.caml_pasta_fp_mul;
    function caml_pasta_fp_mut_mul(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_mul(x,y))}
    var caml_pasta_fp_print=plonk_wasm.caml_pasta_fp_print;
    function bigstring_memset_stub(bigstring,v_pos,v_len,v_char)
     {for(var i=0;i < v_len;i++)caml_ba_set_1(bigstring,v_pos + i,v_char)}
    var
     caml_pasta_fq_plonk_index_domain_d8_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d8_size,
     caml_pasta_fp_size_in_bits=plonk_wasm.caml_pasta_fp_size_in_bits;
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_fq_plonk_gate_to_rust(gate)
     {return new
              (plonk_wasm.WasmFqGate)
              (gate[1],
               caml_plonk_wires_to_rust(gate[2]),
               caml_u8array_vector_to_rust_flat_vector(gate[3]))}
    function caml_pasta_fq_plonk_gate_vector_add(v,x)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_add
              (v,caml_fq_plonk_gate_to_rust(x))}
    function caml_vesta_one()
     {var res=plonk_wasm.caml_vesta_one();free_on_finalize(res);return res}
    function Base_int_math_int64_clz(x)
     {var n=64,y;
      y = caml_int64_shift_right_unsigned(x,32);
      if(! caml_int64_is_zero(y)){n = n - 32;x = y}
      y = caml_int64_shift_right_unsigned(x,16);
      if(! caml_int64_is_zero(y)){n = n - 16;x = y}
      y = caml_int64_shift_right_unsigned(x,8);
      if(! caml_int64_is_zero(y)){n = n - 8;x = y}
      y = caml_int64_shift_right_unsigned(x,4);
      if(! caml_int64_is_zero(y)){n = n - 4;x = y}
      y = caml_int64_shift_right_unsigned(x,2);
      if(! caml_int64_is_zero(y)){n = n - 2;x = y}
      y = caml_int64_shift_right_unsigned(x,1);
      if(! caml_int64_is_zero(y))return n - 2;
      return n - caml_int64_to_int32(x)}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    var
     caml_pallas_endo_base=plonk_wasm.caml_pallas_endo_base,
     caml_pasta_fp_div=plonk_wasm.caml_pasta_fp_div;
    function ml_z_sub(z1,z2)
     {return ml_z_normalize(bigInt(z1).subtract(bigInt(z2)))}
    function ml_z_fdiv(z1,z2)
     {var z1_pos=ml_z_sign(z1),z2_pos=ml_z_sign(z2);
      if(z1_pos * z2_pos < 0)
       if(! bigInt(z1).mod(bigInt(z2)).equals(bigInt(0)))
        return ml_z_sub(ml_z_div(z1,z2),bigInt(1));
      return ml_z_div(z1,z2)}
    function caml_fq_srs_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_fq_srs_write
              (append,t,caml_jsstring_of_string(path))}
    function ml_z_to_bits(z1)
     {z1 = bigInt(z1).abs();
      var res="";
      while(! z1.equals(bigInt(0)))
       {res += String.fromCharCode(z1.mod(bigInt(256)));
        z1 = z1.divide(bigInt(256))}
      while(res.length % 4 != 0)res += String.fromCharCode(0);
      return caml_new_string(res)}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    var
     caml_pasta_fp_domain_generator=
      plonk_wasm.caml_pasta_fp_domain_generator;
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function deferred_upon_exn(deferred,func)
     {deferred.promise.then(function(){func(deferred.value)})}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function integers_uint64_to_int(i){return caml_int64_to_int32(i.value)}
    function caml_pasta_fq_plonk_gate_vector_wrap(v,x,y)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_wrap
              (v,caml_plonk_wire_to_rust(x),caml_plonk_wire_to_rust(y))}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function core_kernel_gc_promoted_words(){return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_bigint_256_to_bytes(x)
     {return caml_bytes_of_uint8array(plonk_wasm.caml_bigint_256_to_bytes(x))}
    function core_kernel_gc_heap_chunks(){return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function ml_z_of_nativeint(z){return ml_z_of_int(z)}
    function ml_z_invert(a,n)
     {a = bigInt(a);
      n = bigInt(n);
      var zero=bigInt(0),one=bigInt(1);
      if(n.abs().equals(one))return 0;
      if(n.equals(zero) && a.abs().equals(one))return a;
      if(n.equals(zero) || a.equals(zero))caml_raise_zero_divide();
      var
       x=ml_z_gcdext_intern(a,n),
       r=bigInt(x[2]),
       tmp=bigInt(a).multiply(r).mod(n);
      if(tmp.lt(zero))tmp = tmp.add(n.abs());
      if(r.lt(zero))r = r.add(n.abs());
      if(tmp.equals(one))return ml_z_normalize(r);
      caml_raise_zero_divide()}
    function ml_z_powm(z1,z2,z3)
     {var zero=bigInt(0),one=bigInt(1);
      z1 = bigInt(z1);
      z2 = bigInt(z2);
      z3 = bigInt(z3);
      if(z3.equals(zero))caml_raise_zero_divide();
      if(z3.abs().equals(one))return 0;
      if(z2.equals(zero))return 1;
      if(z2.lt(0))
       {var inv=bigInt(ml_z_invert(z1,z3)),r=inv.modPow(z2.negate(),z3);
        if(r.lt(zero))r = r.add(z3.abs());
        return ml_z_normalize(r)}
      else
       {var r=bigInt(z1).modPow(z2,z3);
        if(r.lt(zero))r = r.add(z3.abs());
        return ml_z_normalize(r)}}
    function ml_z_powm_sec(z1,z2,z3)
     {z3 = bigInt(z3).abs();
      var one=bigInt(1);
      if(bigInt(z2).lt(one))
       caml_invalid_argument("Z.powm_sec: exponent must be positive");
      if(! bigInt(z3).and(one).equals(one))
       caml_invalid_argument("Z.powm_sec: modulus must be odd");
      return ml_z_powm(z1,z2,z3)}
    function caml_js_pure_expr(f){return f()}
    var core_array_unsafe_int_blit=caml_array_blit;
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_sigio_handler(){return 0}
    var caml_pasta_fq_to_bigint=plonk_wasm.caml_pasta_fq_to_bigint;
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_fp_srs_read(offset,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      var
       res=
        plonk_wasm.caml_fp_srs_read(offset,caml_jsstring_of_string(path));
      return res?[0,res]:0}
    function deferred_bind(deferred,func)
     {var
       newDeferred=
        {promise:
         deferred.promise.then(func).then
            (function(anotherDeferred){return anotherDeferred.promise}).then
           (function(value)
             {newDeferred.value = value;
              newDeferred.isDetermined = true;
              return value}).catch
          (function(err)
            {newDeferred.error = err;
             newDeferred.isError = true;
             newDeferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return newDeferred}
    function caml_bigint_256_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_bigint_256_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    var
     caml_pasta_fq_plonk_index_max_degree=
      plonk_wasm.caml_pasta_fq_plonk_index_max_degree;
    function core_kernel_gc_minor_collections(){return 0}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    var caml_pasta_fq_size_in_bits=plonk_wasm.caml_pasta_fq_size_in_bits;
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_get_exception_backtrace(){return 0}
    function integers_uint64_compare(x,y)
     {x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return x.value.ucompare(y.value)}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function ml_z_equal(z1,z2){return bigInt(z1).equals(bigInt(z2))}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function ml_z_perfect_square(z)
     {z = bigInt(z);
      if(z.lt(bigInt(0)))return 0;
      var root=bigInt(ml_z_root(z,2));
      return root.multiply(root).eq(z)?1:0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function ml_z_to_nativeint(z1){return ml_z_to_int(z1)}
    function bigstringaf_memcmp_string(ba,ba_off,str,str_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba,ba_off + i),
            caml_string_unsafe_get(str,str_off + i));
        if(c != 0)return c}
      return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function core_md5_digest_subbigstring(buf,ofs,len,res)
     {var bytes=caml_create_bytes(len);
      bigstring_blit_bigstring_bytes_stub(buf,ofs,bytes,0,len);
      var res2=caml_md5_string(bytes,0,len);
      caml_blit_string(res2,0,res,0,16);
      return 0}
    function caml_fp_srs_create(i)
     {return free_on_finalize(plonk_wasm.caml_fp_srs_create(i))}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_pallas_of_affine_coordinates(x,y)
     {var res=plonk_wasm.caml_pallas_of_affine_coordinates(x,y);
      free_on_finalize(res);
      return res}
    function deferred_map(deferred,func)
     {var
       newDeferred=
        {promise:
         deferred.promise.then(func).then
           (function(value)
             {newDeferred.value = value;
              newDeferred.isDetermined = true;
              return value}).catch
          (function(err)
            {newDeferred.error = err;
             newDeferred.isError = true;
             newDeferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return newDeferred}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function integers_uint64_shift_left(x,y)
     {return new UInt64(caml_int64_shift_left(x.value,y))}
    function caml_vesta_random()
     {var res=plonk_wasm.caml_vesta_random();free_on_finalize(res);return res}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_pasta_fq_div=plonk_wasm.caml_pasta_fq_div;
    function ml_z_logxor(z1,z2)
     {return ml_z_normalize(bigInt(z1).xor(bigInt(z2)))}
    var
     caml_pasta_fq_size=plonk_wasm.caml_pasta_fq_size,
     caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function ml_z_trailing_zeros(z)
     {z = bigInt(z).abs();
      var zero=bigInt(0),one=bigInt(1);
      if(z.equals(zero))return 0x7fffffff;
      var i=0;
      z = z.xor(z.prev()).shiftRight(1);
      for(i = 0;! z.equals(bigInt.zero);i++)z = z.shiftRight(1);
      return i}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_pallas_scale(x,y)
     {var res=plonk_wasm.caml_pallas_scale(x,y);
      free_on_finalize(res);
      return res}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_js_instanceof(o,c){return o instanceof c}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function integers_uint32_shift_right(x,y)
     {return new UInt32(x.value >>> y)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function integers_uint_size(unit){return 4}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_pasta_fq_plonk_proof_deep_copy(proof)
     {return caml_pasta_fq_proof_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_proof_deep_copy
                (caml_pasta_fq_proof_to_rust(proof)))}
    var caml_pasta_fq_negate=plonk_wasm.caml_pasta_fq_negate;
    function integers_ushort_size(unit){return 4}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function integers_uint32_rem(x,y)
     {if(y.value == 0)caml_raise_zero_divide();
      return new UInt32(x.value % y.value)}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_pasta_fq_plonk_verifier_index_shifts(log2_size)
     {return caml_plonk_verification_shifts_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_shifts(log2_size))}
    function integers_uint64_shift_right(x,y)
     {return new UInt64(caml_int64_shift_right_unsigned(x.value,y))}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_pasta_fp_plonk_proof_dummy()
     {return caml_pasta_fp_proof_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_proof_dummy())}
    function Base_internalhash_get_hash_value(seed)
     {var h=caml_hash_mix_final(seed);return h & 0x3FFFFFFF}
    function integers_uint64_sub(x,y)
     {return new UInt64(caml_int64_sub(x.value,y.value))}
    function caml_pasta_fq_plonk_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fq_plonk_index_write
              (append,t,caml_jsstring_of_string(path))}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    var caml_pasta_fp_random=plonk_wasm.caml_pasta_fp_random;
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_pasta_fp_plonk_gate_vector_wrap(v,x,y)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_wrap
              (v,caml_plonk_wire_to_rust(x),caml_plonk_wire_to_rust(y))}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    function caml_fq_vector_create(){return [0]}
    var caml_pasta_fq_random=plonk_wasm.caml_pasta_fq_random;
    function ml_z_to_int32(z1){return ml_z_to_int(z1)}
    function caml_pasta_fp_plonk_verifier_index_dummy()
     {var res=plonk_wasm.caml_pasta_fp_plonk_verifier_index_dummy();
      return caml_pasta_fp_plonk_verifier_index_of_rust(res)}
    function deferred_upon(deferred,func)
     {deferred.promise.then(function(){func(deferred.value)}).catch
       (function(){})}
    function deferred_run(func)
     {var
       deferred=
        {promise:
         Promise.resolve().then(func).then
           (function(value)
             {deferred.value = value;
              deferred.isDetermined = true;
              return value}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function ml_z_compare(z1,z2){return bigInt(z1).compare(bigInt(z2))}
    function caml_pasta_fp_plonk_proof_batch_verify(indexes,proofs)
     {indexes
      =
      caml_array_to_rust_vector
       (indexes,caml_pasta_fp_plonk_verifier_index_to_rust);
      proofs = caml_array_to_rust_vector(proofs,caml_pasta_fp_proof_to_rust);
      return plonk_wasm.caml_pasta_fp_plonk_proof_batch_verify(indexes,proofs)}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function core_kernel_gc_major_collections(){return 0}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function ml_z_of_float(f1)
     {if(f1 == Infinity || f1 == - Infinity || f1 != f1)
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      return ml_z_normalize(bigInt(f1 < 0?Math.ceil(f1):Math.floor(f1)))}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function fq_oracles_dummy()
     {return caml_oracles_of_rust(plonk_wasm.fq_oracles_dummy())}
    function deferred_return(value)
     {return {promise:Promise.resolve(value),
              value:value,
              isError:false,
              isDetermined:true}}
    function Base_hash_double(d){return caml_hash(1,1,0,d)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    var
     caml_pasta_fp_two_adic_root_of_unity=
      plonk_wasm.caml_pasta_fp_two_adic_root_of_unity;
    function caml_pasta_fq_of_string(x)
     {return plonk_wasm.caml_pasta_fq_of_string(caml_jsstring_of_string(x))}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function integers_uint64_hash(v){return caml_int64_hash(v.value)}
    function core_kernel_gc_heap_words(){return 0}
    function bigstringaf_blit_to_bigstring(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(dst,dst_off + i,caml_ba_get_1(src,src_off + i))}
    function caml_pallas_one()
     {var res=plonk_wasm.caml_pallas_one();free_on_finalize(res);return res}
    var ms_to_nano=caml_int64_of_int32(1000 * 1000);
    function time_now_nanoseconds_since_unix_epoch_or_zero()
     {var ms=Date.now(),ms_i63=caml_int64_of_float(ms * 2);
      return caml_int64_mul(ms_i63,ms_to_nano)}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    var
     caml_bigint_256_bytes_per_limb=
      plonk_wasm.caml_bigint_256_bytes_per_limb;
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_ba_layout(ba){return ba.layout}
    function integers_int32_of_uint32(i){return i.value | 0}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function ml_z_perfect_power(z)
     {z = bigInt(z);
      var zero=bigInt(0),one=bigInt(1);
      if(z.equals(zero) || z.equals(one) || z.equals(one.negate()))return 1;
      var log2z=ml_z_numbits(z.abs());
      for(var b=2;b <= log2z;b++)
       {if(z.lt(zero) && b % 2 == 0)continue;
        var zp=z.abs(),p=bigInt(ml_z_root(zp,b));
        if(z.lt(zero))p = p.negate();
        var r=bigInt(ml_z_pow(p,b));
        if(z.equals(r))return 1}
      return 0}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_pasta_fp_plonk_gate_vector_get(v,i)
     {return caml_plonk_gate_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_gate_vector_get(v,i))}
    function integers_uint32_logor(x,y){return new UInt32(x.value | y.value)}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    var
     caml_pasta_fq_plonk_index_public_inputs=
      plonk_wasm.caml_pasta_fq_plonk_index_public_inputs;
    function caml_pasta_fq_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_pasta_fq_to_string(x))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function ml_z_format(fmt,z1)
     {z1 = bigInt(z1);
      var
       fmt=fmt.toString(),
       base=10,
       cas=0,
       width=0,
       alt=0,
       dir=0,
       sign="",
       pad=" ",
       idx=0,
       prefix="";
      while(fmt[idx] == "%")idx++;
      for(;;idx++)
       if(fmt[idx] == "#")
        alt = 1;
       else
        if(fmt[idx] == "0")
         pad = "0";
        else
         if(fmt[idx] == "-")
          dir = 1;
         else
          if(fmt[idx] == " " || fmt[idx] == "+")sign = fmt[idx];else break;
      if(z1.lt(bigInt(0))){sign = "-";z1 = z1.negate()}
      for(;fmt[idx] >= "0" && fmt[idx] <= "9";idx++)
       width = 10 * width + + fmt[idx];
      switch(fmt[idx])
       {case "i":
        case "d":
        case "u":break;
        case "b":base = 2;if(alt)prefix = "0b";break;
        case "o":base = 8;if(alt)prefix = "0o";break;
        case "x":base = 16;if(alt)prefix = "0x";break;
        case "X":base = 16;if(alt)prefix = "0X";cas = 1;break;
        default:caml_failwith("Unsupported format '" + fmt + "'")}
      if(dir)pad = " ";
      var res=z1.toString(base);
      if(cas === 1)res = res.toUpperCase();
      var size=res.length;
      if(pad == " ")
       if(dir)
        {res = sign + prefix + res;for(;res.length < width;)res = res + pad}
       else
        {res = sign + prefix + res;for(;res.length < width;)res = pad + res}
      else
       {var pre=sign + prefix;
        for(;res.length + pre.length < width;)res = pad + res;
        res = pre + res}
      return caml_new_string(res)}
    function fq_oracles_deep_copy(x)
     {return caml_oracles_of_rust
              (plonk_wasm.fq_oracles_deep_copy
                (caml_oracles_to_rust
                  (x,plonk_wasm.WasmFqOracles,plonk_wasm.WasmFqRandomOracles)))}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function ml_z_shift_right_trunc(z1,z2)
     {return ml_z_div(bigInt(z1),bigInt(2).pow(z2))}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function integers_unsigned_init(unit)
     {caml_custom_ops["integers:uint8"]
      =
      {deserialize:integers_uint8_deserialize,fixed_length:1};
      caml_custom_ops["integers:uint16"]
      =
      {deserialize:integers_uint16_deserialize,fixed_length:2};
      caml_custom_ops["integers:uint32"]
      =
      {serialize:integers_uint32_serialize,
       deserialize:integers_uint32_deserialize,
       fixed_length:4,
       hash:integers_uint32_hash,
       compare:integers_uint32_compare};
      caml_custom_ops["integers:uint64"]
      =
      {serialize:integers_uint64_marshal,
       deserialize:integers_uint64_unmarshal,
       hash:integers_uint64_hash,
       compare:integers_uint64_compare};
      return unit}
    function integers_uint64_add(x,y)
     {return new UInt64(caml_int64_add(x.value,y.value))}
    function caml_pallas_add(x,y)
     {var res=plonk_wasm.caml_pallas_add(x,y);
      free_on_finalize(res);
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_pasta_fq_plonk_proof_batch_verify(indexes,proofs)
     {indexes
      =
      caml_array_to_rust_vector
       (indexes,caml_pasta_fq_plonk_verifier_index_to_rust);
      proofs = caml_array_to_rust_vector(proofs,caml_pasta_fq_proof_to_rust);
      return plonk_wasm.caml_pasta_fq_plonk_proof_batch_verify(indexes,proofs)}
    joo_global_object.jsoo_runtime
    =
    {plonk_wasm:plonk_wasm,
     integers_uint64_compare:integers_uint64_compare,
     integers_uint32_compare:integers_uint32_compare,
     integers_uint32_hash:integers_uint32_hash,
     integers_uint32_deserialize:integers_uint32_deserialize,
     integers_uint16_deserialize:integers_uint16_deserialize,
     integers_uint8_deserialize:integers_uint8_deserialize,
     integers_uint32_serialize:integers_uint32_serialize,
     integers_ushort_size:integers_ushort_size,
     integers_unsigned_init:integers_unsigned_init,
     integers_ulonglong_size:integers_ulonglong_size,
     integers_ulong_size:integers_ulong_size,
     integers_uint_size:integers_uint_size,
     integers_uint8_of_string:integers_uint8_of_string,
     integers_uint64_hash:integers_uint64_hash,
     integers_uint64_marshal:integers_uint64_marshal,
     integers_uint64_unmarshal:integers_uint64_unmarshal,
     integers_uint64_to_string:integers_uint64_to_string,
     integers_uint64_to_int64:integers_uint64_to_int64,
     integers_uint64_to_int:integers_uint64_to_int,
     integers_uint64_sub:integers_uint64_sub,
     integers_uint64_shift_right:integers_uint64_shift_right,
     integers_uint64_shift_left:integers_uint64_shift_left,
     integers_uint64_rem:integers_uint64_rem,
     integers_uint64_of_string:integers_uint64_of_string,
     integers_uint_of_string:integers_uint_of_string,
     integers_uint64_of_int64:integers_uint64_of_int64,
     integers_uint64_of_int:integers_uint64_of_int,
     integers_uint64_mul:integers_uint64_mul,
     integers_uint64_max:integers_uint64_max,
     integers_uint64_logxor:integers_uint64_logxor,
     integers_uint64_logor:integers_uint64_logor,
     integers_uint64_logand:integers_uint64_logand,
     integers_uint64_div:integers_uint64_div,
     integers_uint64_add:integers_uint64_add,
     UInt64:UInt64,
     integers_uint32_to_string:integers_uint32_to_string,
     integers_uint32_to_int64:integers_uint32_to_int64,
     integers_uint32_to_int:integers_uint32_to_int,
     integers_uint32_shift_right:integers_uint32_shift_right,
     integers_uint32_shift_left:integers_uint32_shift_left,
     integers_uint32_rem:integers_uint32_rem,
     integers_uint32_of_string:integers_uint32_of_string,
     integers_uint32_of_int64:integers_uint32_of_int64,
     integers_uint32_of_int32:integers_uint32_of_int32,
     integers_uint32_of_int:integers_uint32_of_int,
     integers_uint32_mul:integers_uint32_mul,
     integers_uint32_max:integers_uint32_max,
     integers_uint32_logxor:integers_uint32_logxor,
     integers_uint32_logor:integers_uint32_logor,
     integers_uint32_logand:integers_uint32_logand,
     integers_uint32_div:integers_uint32_div,
     integers_uint32_sub:integers_uint32_sub,
     integers_uint32_add:integers_uint32_add,
     integers_uint16_of_string:integers_uint16_of_string,
     integers_size_t_size:integers_size_t_size,
     integers_int32_of_uint32:integers_int32_of_uint32,
     UInt32:UInt32,
     caml_pasta_fq_poseidon_block_cipher:caml_pasta_fq_poseidon_block_cipher,
     caml_pasta_fp_poseidon_block_cipher:caml_pasta_fp_poseidon_block_cipher,
     caml_pasta_fq_poseidon_params_create:caml_pasta_fq_poseidon_params_create,
     caml_pasta_fp_poseidon_params_create:caml_pasta_fp_poseidon_params_create,
     fq_oracles_deep_copy:fq_oracles_deep_copy,
     fq_oracles_dummy:fq_oracles_dummy,
     fq_oracles_create:fq_oracles_create,
     fp_oracles_deep_copy:fp_oracles_deep_copy,
     fp_oracles_dummy:fp_oracles_dummy,
     fp_oracles_create:fp_oracles_create,
     caml_oracles_to_rust:caml_oracles_to_rust,
     caml_oracles_of_rust:caml_oracles_of_rust,
     caml_random_oracles_to_rust:caml_random_oracles_to_rust,
     caml_random_oracles_of_rust:caml_random_oracles_of_rust,
     caml_pasta_fq_plonk_proof_deep_copy:caml_pasta_fq_plonk_proof_deep_copy,
     caml_pasta_fq_plonk_proof_dummy:caml_pasta_fq_plonk_proof_dummy,
     caml_pasta_fq_plonk_proof_batch_verify:
     caml_pasta_fq_plonk_proof_batch_verify,
     caml_pasta_fq_plonk_proof_verify:caml_pasta_fq_plonk_proof_verify,
     caml_pasta_fq_plonk_proof_create:caml_pasta_fq_plonk_proof_create,
     caml_pasta_fq_proof_of_rust:caml_pasta_fq_proof_of_rust,
     caml_pasta_fq_proof_to_rust:caml_pasta_fq_proof_to_rust,
     caml_pasta_fq_commitments_of_rust:caml_pasta_fq_commitments_of_rust,
     caml_pasta_fq_commitments_to_rust:caml_pasta_fq_commitments_to_rust,
     caml_pasta_fq_opening_proof_of_rust:caml_pasta_fq_opening_proof_of_rust,
     caml_pasta_fq_opening_proof_to_rust:caml_pasta_fq_opening_proof_to_rust,
     caml_pasta_fq_proof_evaluations_of_rust:
     caml_pasta_fq_proof_evaluations_of_rust,
     caml_pasta_fq_proof_evaluations_to_rust:
     caml_pasta_fq_proof_evaluations_to_rust,
     caml_pasta_fp_plonk_proof_deep_copy:caml_pasta_fp_plonk_proof_deep_copy,
     caml_pasta_fp_plonk_proof_dummy:caml_pasta_fp_plonk_proof_dummy,
     caml_pasta_fp_plonk_proof_batch_verify:
     caml_pasta_fp_plonk_proof_batch_verify,
     caml_pasta_fp_plonk_proof_verify:caml_pasta_fp_plonk_proof_verify,
     caml_pasta_fp_plonk_proof_create:caml_pasta_fp_plonk_proof_create,
     caml_pasta_fp_proof_of_rust:caml_pasta_fp_proof_of_rust,
     caml_pasta_fp_proof_to_rust:caml_pasta_fp_proof_to_rust,
     caml_pasta_fp_commitments_of_rust:caml_pasta_fp_commitments_of_rust,
     caml_pasta_fp_commitments_to_rust:caml_pasta_fp_commitments_to_rust,
     caml_pasta_fp_opening_proof_of_rust:caml_pasta_fp_opening_proof_of_rust,
     caml_pasta_fp_opening_proof_to_rust:caml_pasta_fp_opening_proof_to_rust,
     caml_pasta_fp_proof_evaluations_of_rust:
     caml_pasta_fp_proof_evaluations_of_rust,
     caml_pasta_fp_proof_evaluations_to_rust:
     caml_pasta_fp_proof_evaluations_to_rust,
     PERMUTS_MINUS_1:PERMUTS_MINUS_1,
     COLUMNS:COLUMNS,
     caml_pasta_fq_plonk_verifier_index_deep_copy:
     caml_pasta_fq_plonk_verifier_index_deep_copy,
     caml_pasta_fq_plonk_verifier_index_dummy:
     caml_pasta_fq_plonk_verifier_index_dummy,
     caml_pasta_fq_plonk_verifier_index_shifts:
     caml_pasta_fq_plonk_verifier_index_shifts,
     caml_pasta_fq_plonk_verifier_index_write:
     caml_pasta_fq_plonk_verifier_index_write,
     caml_pasta_fq_plonk_verifier_index_read:
     caml_pasta_fq_plonk_verifier_index_read,
     caml_pasta_fq_plonk_verifier_index_create:
     caml_pasta_fq_plonk_verifier_index_create,
     caml_pasta_fq_plonk_verifier_index_to_rust:
     caml_pasta_fq_plonk_verifier_index_to_rust,
     caml_pasta_fq_plonk_verifier_index_of_rust:
     caml_pasta_fq_plonk_verifier_index_of_rust,
     caml_pasta_fp_plonk_verifier_index_deep_copy:
     caml_pasta_fp_plonk_verifier_index_deep_copy,
     caml_pasta_fp_plonk_verifier_index_dummy:
     caml_pasta_fp_plonk_verifier_index_dummy,
     caml_pasta_fp_plonk_verifier_index_shifts:
     caml_pasta_fp_plonk_verifier_index_shifts,
     caml_pasta_fp_plonk_verifier_index_write:
     caml_pasta_fp_plonk_verifier_index_write,
     caml_pasta_fp_plonk_verifier_index_read:
     caml_pasta_fp_plonk_verifier_index_read,
     caml_pasta_fp_plonk_verifier_index_create:
     caml_pasta_fp_plonk_verifier_index_create,
     caml_pasta_fp_plonk_verifier_index_to_rust:
     caml_pasta_fp_plonk_verifier_index_to_rust,
     caml_pasta_fp_plonk_verifier_index_of_rust:
     caml_pasta_fp_plonk_verifier_index_of_rust,
     caml_plonk_verifier_index_to_rust:caml_plonk_verifier_index_to_rust,
     caml_plonk_verifier_index_of_rust:caml_plonk_verifier_index_of_rust,
     None:None,
     linearization_of_rust:linearization_of_rust,
     wrap:wrap,
     index_term_of_rust:index_term_of_rust,
     polish_token_of_rust:polish_token_of_rust,
     variable_of_rust:variable_of_rust,
     column_of_rust:column_of_rust,
     caml_plonk_verification_shifts_to_rust:
     caml_plonk_verification_shifts_to_rust,
     caml_plonk_verification_shifts_of_rust:
     caml_plonk_verification_shifts_of_rust,
     caml_plonk_verification_evals_to_rust:
     caml_plonk_verification_evals_to_rust,
     caml_plonk_verification_evals_of_rust:
     caml_plonk_verification_evals_of_rust,
     caml_plonk_domain_to_rust:caml_plonk_domain_to_rust,
     caml_plonk_domain_of_rust:caml_plonk_domain_of_rust,
     caml_pasta_fq_plonk_index_write:caml_pasta_fq_plonk_index_write,
     caml_pasta_fq_plonk_index_read:caml_pasta_fq_plonk_index_read,
     caml_pasta_fq_plonk_index_domain_d8_size:
     caml_pasta_fq_plonk_index_domain_d8_size,
     caml_pasta_fq_plonk_index_domain_d4_size:
     caml_pasta_fq_plonk_index_domain_d4_size,
     caml_pasta_fq_plonk_index_domain_d1_size:
     caml_pasta_fq_plonk_index_domain_d1_size,
     caml_pasta_fq_plonk_index_public_inputs:
     caml_pasta_fq_plonk_index_public_inputs,
     caml_pasta_fq_plonk_index_max_degree:caml_pasta_fq_plonk_index_max_degree,
     caml_pasta_fq_plonk_index_create:caml_pasta_fq_plonk_index_create,
     caml_pasta_fp_plonk_index_write:caml_pasta_fp_plonk_index_write,
     caml_pasta_fp_plonk_index_read:caml_pasta_fp_plonk_index_read,
     caml_pasta_fp_plonk_index_domain_d8_size:
     caml_pasta_fp_plonk_index_domain_d8_size,
     caml_pasta_fp_plonk_index_domain_d4_size:
     caml_pasta_fp_plonk_index_domain_d4_size,
     caml_pasta_fp_plonk_index_domain_d1_size:
     caml_pasta_fp_plonk_index_domain_d1_size,
     caml_pasta_fp_plonk_index_public_inputs:
     caml_pasta_fp_plonk_index_public_inputs,
     caml_pasta_fp_plonk_index_max_degree:caml_pasta_fp_plonk_index_max_degree,
     caml_pasta_fp_plonk_index_create:caml_pasta_fp_plonk_index_create,
     caml_pasta_fq_plonk_gate_vector_digest:
     caml_pasta_fq_plonk_gate_vector_digest,
     caml_pasta_fq_plonk_gate_vector_wrap:caml_pasta_fq_plonk_gate_vector_wrap,
     caml_pasta_fq_plonk_gate_vector_get:caml_pasta_fq_plonk_gate_vector_get,
     caml_pasta_fq_plonk_gate_vector_add:caml_pasta_fq_plonk_gate_vector_add,
     caml_pasta_fq_plonk_gate_vector_create:
     caml_pasta_fq_plonk_gate_vector_create,
     caml_pasta_fp_plonk_gate_vector_digest:
     caml_pasta_fp_plonk_gate_vector_digest,
     caml_pasta_fp_plonk_gate_vector_wrap:caml_pasta_fp_plonk_gate_vector_wrap,
     caml_pasta_fp_plonk_gate_vector_get:caml_pasta_fp_plonk_gate_vector_get,
     caml_pasta_fp_plonk_gate_vector_add:caml_pasta_fp_plonk_gate_vector_add,
     caml_pasta_fp_plonk_gate_vector_create:
     caml_pasta_fp_plonk_gate_vector_create,
     caml_fq_plonk_gate_to_rust:caml_fq_plonk_gate_to_rust,
     caml_fp_plonk_gate_to_rust:caml_fp_plonk_gate_to_rust,
     caml_plonk_gate_of_rust:caml_plonk_gate_of_rust,
     caml_plonk_wires_to_rust:caml_plonk_wires_to_rust,
     caml_plonk_wires_of_rust:caml_plonk_wires_of_rust,
     caml_plonk_wire_to_rust:caml_plonk_wire_to_rust,
     caml_plonk_wire_of_rust:caml_plonk_wire_of_rust,
     caml_fq_srs_h:caml_fq_srs_h,
     caml_fq_srs_batch_accumulator_check:caml_fq_srs_batch_accumulator_check,
     caml_fq_srs_b_poly_commitment:caml_fq_srs_b_poly_commitment,
     caml_fq_srs_commit_evaluations:caml_fq_srs_commit_evaluations,
     caml_fq_srs_lagrange_commitment:caml_fq_srs_lagrange_commitment,
     caml_fq_srs_read:caml_fq_srs_read,
     caml_fq_srs_write:caml_fq_srs_write,
     caml_fq_srs_create:caml_fq_srs_create,
     caml_fp_srs_h:caml_fp_srs_h,
     caml_fp_srs_batch_accumulator_check:caml_fp_srs_batch_accumulator_check,
     caml_fp_srs_b_poly_commitment:caml_fp_srs_b_poly_commitment,
     caml_fp_srs_commit_evaluations:caml_fp_srs_commit_evaluations,
     caml_fp_srs_lagrange_commitment:caml_fp_srs_lagrange_commitment,
     caml_fp_srs_read:caml_fp_srs_read,
     caml_fp_srs_write:caml_fp_srs_write,
     caml_fp_srs_create:caml_fp_srs_create,
     caml_pallas_poly_comm_to_rust:caml_pallas_poly_comm_to_rust,
     caml_pallas_poly_comm_of_rust:caml_pallas_poly_comm_of_rust,
     caml_vesta_poly_comm_to_rust:caml_vesta_poly_comm_to_rust,
     caml_vesta_poly_comm_of_rust:caml_vesta_poly_comm_of_rust,
     caml_poly_comm_to_rust_poly_comm:caml_poly_comm_to_rust_poly_comm,
     caml_poly_comm_of_rust_poly_comm:caml_poly_comm_of_rust_poly_comm,
     caml_array_to_rust_vector:caml_array_to_rust_vector,
     caml_array_of_rust_vector:caml_array_of_rust_vector,
     caml_vesta_affine_deep_copy:caml_vesta_affine_deep_copy,
     caml_vesta_endo_scalar:caml_vesta_endo_scalar,
     caml_vesta_endo_base:caml_vesta_endo_base,
     caml_vesta_of_affine_coordinates:caml_vesta_of_affine_coordinates,
     caml_vesta_of_affine:caml_vesta_of_affine,
     caml_vesta_to_affine:caml_vesta_to_affine,
     caml_vesta_rng:caml_vesta_rng,
     caml_vesta_random:caml_vesta_random,
     caml_vesta_scale:caml_vesta_scale,
     caml_vesta_double:caml_vesta_double,
     caml_vesta_negate:caml_vesta_negate,
     caml_vesta_sub:caml_vesta_sub,
     caml_vesta_add:caml_vesta_add,
     caml_vesta_one:caml_vesta_one,
     caml_pallas_affine_deep_copy:caml_pallas_affine_deep_copy,
     caml_pallas_endo_scalar:caml_pallas_endo_scalar,
     caml_pallas_endo_base:caml_pallas_endo_base,
     caml_pallas_of_affine_coordinates:caml_pallas_of_affine_coordinates,
     caml_pallas_of_affine:caml_pallas_of_affine,
     caml_pallas_to_affine:caml_pallas_to_affine,
     caml_pallas_rng:caml_pallas_rng,
     caml_pallas_random:caml_pallas_random,
     caml_pallas_scale:caml_pallas_scale,
     caml_pallas_double:caml_pallas_double,
     caml_pallas_negate:caml_pallas_negate,
     caml_pallas_sub:caml_pallas_sub,
     caml_pallas_add:caml_pallas_add,
     caml_pallas_one:caml_pallas_one,
     rust_affine_of_caml_affine:rust_affine_of_caml_affine,
     rust_affine_to_caml_affine:rust_affine_to_caml_affine,
     free_on_finalize:free_on_finalize,
     free_finalization_registry:free_finalization_registry,
     caml_fq_vector_of_rust:caml_fq_vector_of_rust,
     caml_fq_vector_to_rust:caml_fq_vector_to_rust,
     caml_fq_vector_get:caml_fq_vector_get,
     caml_fq_vector_emplace_back:caml_fq_vector_emplace_back,
     caml_fq_vector_length:caml_fq_vector_length,
     caml_fq_vector_create:caml_fq_vector_create,
     caml_fp_vector_of_rust:caml_fp_vector_of_rust,
     caml_fp_vector_to_rust:caml_fp_vector_to_rust,
     caml_fp_vector_get:caml_fp_vector_get,
     caml_fp_vector_emplace_back:caml_fp_vector_emplace_back,
     caml_fp_vector_length:caml_fp_vector_length,
     caml_fp_vector_create:caml_fp_vector_create,
     js_class_vector_of_rust_vector:js_class_vector_of_rust_vector,
     js_class_vector_to_rust_vector:js_class_vector_to_rust_vector,
     caml_u8array_vector_of_rust_flat_vector:
     caml_u8array_vector_of_rust_flat_vector,
     caml_u8array_vector_to_rust_flat_vector:
     caml_u8array_vector_to_rust_flat_vector,
     caml_pasta_fq_deep_copy:caml_pasta_fq_deep_copy,
     caml_pasta_fq_of_bytes:caml_pasta_fq_of_bytes,
     caml_pasta_fq_to_bytes:caml_pasta_fq_to_bytes,
     caml_pasta_fq_domain_generator:caml_pasta_fq_domain_generator,
     caml_pasta_fq_two_adic_root_of_unity:caml_pasta_fq_two_adic_root_of_unity,
     caml_pasta_fq_of_bigint:caml_pasta_fq_of_bigint,
     caml_pasta_fq_to_bigint:caml_pasta_fq_to_bigint,
     caml_pasta_fq_rng:caml_pasta_fq_rng,
     caml_pasta_fq_random:caml_pasta_fq_random,
     caml_pasta_fq_equal:caml_pasta_fq_equal,
     caml_pasta_fq_compare:caml_pasta_fq_compare,
     caml_pasta_fq_mut_square:caml_pasta_fq_mut_square,
     caml_pasta_fq_mut_mul:caml_pasta_fq_mut_mul,
     caml_pasta_fq_mut_sub:caml_pasta_fq_mut_sub,
     caml_pasta_fq_mut_add:caml_pasta_fq_mut_add,
     caml_pasta_fq_print:caml_pasta_fq_print,
     caml_pasta_fq_of_string:caml_pasta_fq_of_string,
     caml_pasta_fq_to_string:caml_pasta_fq_to_string,
     caml_pasta_fq_of_int:caml_pasta_fq_of_int,
     caml_pasta_fq_sqrt:caml_pasta_fq_sqrt,
     caml_pasta_fq_is_square:caml_pasta_fq_is_square,
     caml_pasta_fq_square:caml_pasta_fq_square,
     caml_pasta_fq_inv:caml_pasta_fq_inv,
     caml_pasta_fq_div:caml_pasta_fq_div,
     caml_pasta_fq_mul:caml_pasta_fq_mul,
     caml_pasta_fq_negate:caml_pasta_fq_negate,
     caml_pasta_fq_sub:caml_pasta_fq_sub,
     caml_pasta_fq_add:caml_pasta_fq_add,
     caml_pasta_fq_size:caml_pasta_fq_size,
     caml_pasta_fq_size_in_bits:caml_pasta_fq_size_in_bits,
     caml_pasta_fq_copy:caml_pasta_fq_copy,
     caml_pasta_fp_deep_copy:caml_pasta_fp_deep_copy,
     caml_pasta_fp_of_bytes:caml_pasta_fp_of_bytes,
     caml_pasta_fp_to_bytes:caml_pasta_fp_to_bytes,
     caml_pasta_fp_domain_generator:caml_pasta_fp_domain_generator,
     caml_pasta_fp_two_adic_root_of_unity:caml_pasta_fp_two_adic_root_of_unity,
     caml_pasta_fp_of_bigint:caml_pasta_fp_of_bigint,
     caml_pasta_fp_to_bigint:caml_pasta_fp_to_bigint,
     caml_pasta_fp_rng:caml_pasta_fp_rng,
     caml_pasta_fp_random:caml_pasta_fp_random,
     caml_pasta_fp_equal:caml_pasta_fp_equal,
     caml_pasta_fp_compare:caml_pasta_fp_compare,
     caml_pasta_fp_mut_square:caml_pasta_fp_mut_square,
     caml_pasta_fp_mut_mul:caml_pasta_fp_mut_mul,
     caml_pasta_fp_mut_sub:caml_pasta_fp_mut_sub,
     caml_pasta_fp_mut_add:caml_pasta_fp_mut_add,
     caml_pasta_fp_print:caml_pasta_fp_print,
     caml_pasta_fp_of_string:caml_pasta_fp_of_string,
     caml_pasta_fp_to_string:caml_pasta_fp_to_string,
     caml_pasta_fp_of_int:caml_pasta_fp_of_int,
     caml_pasta_fp_sqrt:caml_pasta_fp_sqrt,
     caml_pasta_fp_is_square:caml_pasta_fp_is_square,
     caml_pasta_fp_square:caml_pasta_fp_square,
     caml_pasta_fp_inv:caml_pasta_fp_inv,
     caml_pasta_fp_div:caml_pasta_fp_div,
     caml_pasta_fp_mul:caml_pasta_fp_mul,
     caml_pasta_fp_negate:caml_pasta_fp_negate,
     caml_pasta_fp_sub:caml_pasta_fp_sub,
     caml_pasta_fp_add:caml_pasta_fp_add,
     caml_pasta_fp_size:caml_pasta_fp_size,
     caml_pasta_fp_size_in_bits:caml_pasta_fp_size_in_bits,
     caml_option_to_maybe_undefined:caml_option_to_maybe_undefined,
     caml_option_of_maybe_undefined:caml_option_of_maybe_undefined,
     caml_pasta_fp_copy:caml_pasta_fp_copy,
     caml_bigint_256_deep_copy:caml_bigint_256_deep_copy,
     caml_bigint_256_of_bytes:caml_bigint_256_of_bytes,
     caml_bigint_256_to_bytes:caml_bigint_256_to_bytes,
     caml_bigint_256_test_bit:caml_bigint_256_test_bit,
     caml_bigint_256_to_string:caml_bigint_256_to_string,
     caml_bigint_256_print:caml_bigint_256_print,
     caml_bigint_256_compare:caml_bigint_256_compare,
     caml_bigint_256_div:caml_bigint_256_div,
     caml_bigint_256_bytes_per_limb:caml_bigint_256_bytes_per_limb,
     caml_bigint_256_num_limbs:caml_bigint_256_num_limbs,
     caml_bigint_256_of_decimal_string:caml_bigint_256_of_decimal_string,
     caml_bigint_256_of_numeral:caml_bigint_256_of_numeral,
     caml_bytes_to_uint8array:caml_bytes_to_uint8array,
     caml_bytes_of_uint8array:caml_bytes_of_uint8array,
     deferred_of_promise:deferred_of_promise,
     deferred_to_promise:deferred_to_promise,
     deferred_create:deferred_create,
     deferred_return:deferred_return,
     deferred_value_exn:deferred_value_exn,
     deferred_peek:deferred_peek,
     deferred_is_determined:deferred_is_determined,
     deferred_upon_exn:deferred_upon_exn,
     deferred_upon:deferred_upon,
     deferred_bind:deferred_bind,
     deferred_map:deferred_map,
     deferred_run:deferred_run,
     bigstringaf_memcmp_string:bigstringaf_memcmp_string,
     bigstringaf_memcmp_bigstring:bigstringaf_memcmp_bigstring,
     bigstringaf_blit_from_bytes:bigstringaf_blit_from_bytes,
     bigstringaf_blit_to_bigstring:bigstringaf_blit_to_bigstring,
     bigstringaf_blit_to_bytes:bigstringaf_blit_to_bytes,
     caml_zarith_unmarshal:caml_zarith_unmarshal,
     caml_zarith_marshal:caml_zarith_marshal,
     ml_z_divexact:ml_z_divexact,
     ml_z_size:ml_z_size,
     ml_z_hamdist:ml_z_hamdist,
     ml_z_popcount:ml_z_popcount,
     ml_z_trailing_zeros:ml_z_trailing_zeros,
     ml_z_sqrt_rem:ml_z_sqrt_rem,
     ml_z_sqrt:ml_z_sqrt,
     ml_z_gcdext_intern:ml_z_gcdext_intern,
     ml_z_extract:ml_z_extract,
     ml_z_nextprime:ml_z_nextprime,
     ml_z_probab_prime:ml_z_probab_prime,
     ml_z_perfect_square:ml_z_perfect_square,
     ml_z_perfect_power:ml_z_perfect_power,
     ml_z_invert:ml_z_invert,
     ml_z_root:ml_z_root,
     ml_z_powm_sec:ml_z_powm_sec,
     ml_z_of_bits:ml_z_of_bits,
     ml_z_to_bits:ml_z_to_bits,
     ml_z_hash:ml_z_hash,
     ml_z_pow:ml_z_pow,
     ml_z_powm:ml_z_powm,
     ml_z_fits_nativeint:ml_z_fits_nativeint,
     ml_z_fits_int64:ml_z_fits_int64,
     ml_z_fits_int32:ml_z_fits_int32,
     ml_z_fits_int:ml_z_fits_int,
     ml_z_numbits:ml_z_numbits,
     ml_z_gcd:ml_z_gcd,
     ml_z_sign:ml_z_sign,
     ml_z_equal:ml_z_equal,
     ml_z_compare:ml_z_compare,
     ml_z_of_substring_base:ml_z_of_substring_base,
     jsoo_z_of_js_string_base:jsoo_z_of_js_string_base,
     ml_z_format:ml_z_format,
     ml_z_to_nativeint:ml_z_to_nativeint,
     ml_z_testbit:ml_z_testbit,
     ml_z_to_int64:ml_z_to_int64,
     ml_z_to_int32:ml_z_to_int32,
     ml_z_to_int:ml_z_to_int,
     ml_z_of_float:ml_z_of_float,
     ml_z_of_int64:ml_z_of_int64,
     ml_z_of_nativeint:ml_z_of_nativeint,
     ml_z_of_int32:ml_z_of_int32,
     ml_z_of_int:ml_z_of_int,
     ml_z_shift_right_trunc:ml_z_shift_right_trunc,
     ml_z_shift_right:ml_z_shift_right,
     ml_z_shift_left:ml_z_shift_left,
     ml_z_lognot:ml_z_lognot,
     ml_z_logxor:ml_z_logxor,
     ml_z_logor:ml_z_logor,
     ml_z_logand:ml_z_logand,
     ml_z_abs:ml_z_abs,
     ml_z_pred:ml_z_pred,
     ml_z_succ:ml_z_succ,
     ml_z_div_rem:ml_z_div_rem,
     ml_z_rem:ml_z_rem,
     ml_z_fdiv:ml_z_fdiv,
     ml_z_cdiv:ml_z_cdiv,
     ml_z_div:ml_z_div,
     ml_z_mul:ml_z_mul,
     ml_z_sub:ml_z_sub,
     ml_z_add:ml_z_add,
     ml_z_neg:ml_z_neg,
     ml_z_install_frametable:ml_z_install_frametable,
     ml_z_init:ml_z_init,
     ml_z_normalize:ml_z_normalize,
     bigInt:bigInt,
     bigstring_realloc:bigstring_realloc,
     bigstring_destroy_stub:bigstring_destroy_stub,
     core_md5_digest_subbigstring:core_md5_digest_subbigstring,
     core_md5_fd:core_md5_fd,
     Core_kernel_heap_block_is_heap_block:Core_kernel_heap_block_is_heap_block,
     core_kernel_gc_top_heap_words:core_kernel_gc_top_heap_words,
     core_kernel_gc_promoted_words:core_kernel_gc_promoted_words,
     core_kernel_gc_minor_words:core_kernel_gc_minor_words,
     core_kernel_gc_minor_collections:core_kernel_gc_minor_collections,
     core_kernel_gc_major_words:core_kernel_gc_major_words,
     core_kernel_gc_major_plus_minor_words:
     core_kernel_gc_major_plus_minor_words,
     core_kernel_gc_major_collections:core_kernel_gc_major_collections,
     core_kernel_gc_heap_words:core_kernel_gc_heap_words,
     core_kernel_gc_heap_chunks:core_kernel_gc_heap_chunks,
     core_kernel_gc_compactions:core_kernel_gc_compactions,
     core_kernel_time_ns_format:core_kernel_time_ns_format,
     core_array_unsafe_float_blit:core_array_unsafe_float_blit,
     core_array_unsafe_int_blit:core_array_unsafe_int_blit,
     bigstring_find:bigstring_find,
     internalhash_fold_bigstring:internalhash_fold_bigstring,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_memset_stub:bigstring_memset_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     bigstring_is_mmapped_stub:bigstring_is_mmapped_stub,
     bigstring_alloc:bigstring_alloc,
     caml_out_channel_pos_fd:caml_out_channel_pos_fd,
     expect_test_collector_after_test:expect_test_collector_after_test,
     expect_test_collector_before_test:expect_test_collector_before_test,
     expect_test_collector_saved_stderr:expect_test_collector_saved_stderr,
     expect_test_collector_saved_stdout:expect_test_collector_saved_stdout,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     bin_prot_blit_buf_stub:bin_prot_blit_buf_stub,
     bin_prot_blit_bytes_buf_stub:bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_string_buf_stub:bin_prot_blit_string_buf_stub,
     bin_prot_blit_float_array_buf_stub:bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_buf_bytes_stub:bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_buf_float_array_stub:bin_prot_blit_buf_float_array_stub,
     Base_am_testing:Base_am_testing,
     Base_hash_double:Base_hash_double,
     Base_hash_string:Base_hash_string,
     Base_int_math_int64_pow_stub:Base_int_math_int64_pow_stub,
     Base_int_math_int_pow_stub:Base_int_math_int_pow_stub,
     Base_int_math_int64_clz:Base_int_math_int64_clz,
     Base_int_math_nativeint_clz:Base_int_math_nativeint_clz,
     Base_int_math_int_clz:Base_int_math_int_clz,
     Base_int_math_int32_clz:Base_int_math_int32_clz,
     Base_clear_caml_backtrace_pos:Base_clear_caml_backtrace_pos,
     Base_int_math_int_popcount:Base_int_math_int_popcount,
     Base_internalhash_get_hash_value:Base_internalhash_get_hash_value,
     Base_internalhash_fold_string:Base_internalhash_fold_string,
     Base_internalhash_fold_float:Base_internalhash_fold_float,
     Base_internalhash_fold_int:Base_internalhash_fold_int,
     Base_internalhash_fold_int64:Base_internalhash_fold_int64,
     caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzbmFya3lfanNfY2hyb21lLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiRGVmYXVsdExvY2FsZSIsImRlZmF1bHRTdHJmdGltZSIsIlN0cmZ0aW1lIiwiaXNDb21tb25KUyIsIm1vZHVsZSIsIm5hbWVzcGFjZSIsImFkYXB0ZWRTdHJmdGltZSIsImRlcHJlY2F0ZWRTdHJmdGltZSIsImpvb19nbG9iYWxfb2JqZWN0IiwidGhpcyIsImV2YWwiLCJfcmVxdWlyZSIsIl9kZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRpb25XYXJuaW5nIiwibmFtZSIsImluc3RlYWQiLCJjb25zb2xlIiwiZGVwcmVjYXRlZFN0cmZ0aW1lVFoiLCJkZXByZWNhdGVkU3RyZnRpbWVVVEMiLCJkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQiLCJhZGFwdEZvcndhcmRzIiwiZm4iLCJmbXQiLCJkIiwibG9jYWxlIiwidW5kZWZpbmVkIiwic3RyZnRpbWUiLCJ0aW1lem9uZSIsIm51bGwiLCJ1dGNTdHJmdGltZSIsIkRhdGUiLCJjdXN0b21UaW1lem9uZU9mZnNldCIsInVzZVV0Y1RpbWV6b25lIiwiX2xvY2FsZSIsIl9jdXN0b21UaW1lem9uZU9mZnNldCIsIl91c2VVdGNCYXNlZERhdGUiLCJfY2FjaGVkRGF0ZVRpbWVzdGFtcCIsIl9jYWNoZWREYXRlIiwiX3N0cmZ0aW1lIiwiZm9ybWF0IiwiZGF0ZSIsInRpbWVzdGFtcCIsImN1cnJlbnRUaW1lc3RhbXAiLCJnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvciIsIl9wcm9jZXNzRm9ybWF0IiwicmVzdWx0U3RyaW5nIiwicGFkZGluZyIsImlzSW5TY29wZSIsImxlbmd0aCIsImV4dGVuZGVkVFoiLCJpIiwiY3VycmVudENoYXJDb2RlIiwicGFkVGlsbDIiLCJNYXRoIiwiaG91cnMxMiIsInBhZFRpbGwzIiwid2Vla051bWJlciIsInR6U3RyaW5nIiwieSIsImRheSIsIlN0cmluZyIsIm9yZGluYWwiLCJvZmYiLCJzaWduIiwic2VwIiwiaG91cnMiLCJtaW5zIiwidXNlVXRjQmFzZWREYXRlIiwidGltZXpvbmVUeXBlIiwicGFyc2VJbnQiLCJtaW51dGVzIiwibnVtYmVyVG9QYWQiLCJwYWRkaW5nQ2hhciIsImhvdXIiLCJmaXJzdFdlZWtkYXkiLCJ3ZWVrZGF5IiwiZmlyc3REYXlPZlllYXJVdGMiLCJkYXRlVXRjIiwieWRheSIsIndlZWtOdW0iLCJudW1iZXIiLCJpaSIsInBsb25rX3dhc20iLCJydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSIsInB0IiwiaW5maW5pdHkiLCJ4IiwianNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yIiwidiIsImtsYXNzIiwibGVuIiwicmVzIiwiQXJyYXkiLCJwb3MiLCJjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yIiwiY29udmVydCIsInNob3VsZF9mcmVlIiwicnVzdF92YWwiLCJjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbSIsInBvbHlfY29tbSIsInJ1c3Rfc2hpZnRlZCIsInJ1c3RfdW5zaGlmdGVkIiwiY2FtbF9zaGlmdGVkIiwiY2FtbF91bnNoaWZ0ZWQiLCJjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0IiwiY2FtbF9leHBtMV9mbG9hdCIsInoiLCJjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdCIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwicyIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsImNvbXAiLCJuY29tcCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJyIiwibCIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJmIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImpzb29faXNfYXNjaWkiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJiIiwidCIsImMiLCJjMSIsImMyIiwiaiIsIk1sQnl0ZXMiLCJ0YWciLCJjb250ZW50cyIsImNvbnRlbnQiLCJjYW1sX2lzX21sX2J5dGVzIiwiY2FtbF9pc19tbF9zdHJpbmciLCJjYW1sX2J5dGVzX29mX2FycmF5IiwiY2FtbF9ieXRlc19vZl9zdHJpbmciLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX2FyZyIsImFyZyIsImNhbWxfcmFpc2Vfd2l0aF9zdHJpbmciLCJtc2ciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiY2FtbF9ibGl0X2J5dGVzIiwiczEiLCJpMSIsInMyIiwiaTIiLCJjYW1sX2JsaXRfc3RyaW5nIiwiZSIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJvZmZzZXQiLCJidWYiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiTWxGYWtlRGV2aWNlIiwicm9vdCIsIm5hbWVfc2xhc2giLCJSZWdFeHAiLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9ieXRlcyIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmlsZSIsImZkIiwicmVxdWlyZSIsImVyciIsImJ1Zl9vZmZzZXQiLCJidWZmZXIiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJvIiwiY2FtbF9yb290IiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJqc29vX21vdW50X3BvaW50IiwicmVzb2x2ZV9mc19kZXZpY2UiLCJwYXRoIiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnkiLCJpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZSIsImZyZWVfb25fZmluYWxpemUiLCJjYW1sX3Bsb25rX2RvbWFpbl90b19ydXN0IiwicnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUiLCJqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IiLCJjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yIiwibWtfbmV3IiwiY2xhc3NfdmFsIiwiY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0iLCJwb2x5X2NvbW1fY2xhc3MiLCJta19hZmZpbmUiLCJjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc190b19ydXN0IiwiY29udmVydEFycmF5IiwiY29tbXMiLCJzaWdtYV9jb21tIiwiY29lZmZpY2llbnRzX2NvbW0iLCJnZW5lcmljX2NvbW0iLCJwc21fY29tbSIsImNvbXBsZXRlX2FkZF9jb21tIiwibXVsX2NvbW0iLCJlbXVsX2NvbW0iLCJlbmRvbXVsX3NjYWxhcl9jb21tIiwiY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QiLCJjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QiLCJkb21haW5fY2xhc3MiLCJ2ZXJpZmljYXRpb25fZXZhbHNfY2xhc3MiLCJ2ZXJpZmljYXRpb25fc2hpZnRzX2NsYXNzIiwiZG9tYWluIiwibWF4X3BvbHlfc2l6ZSIsIm1heF9xdW90X3NpemUiLCJzcnMiLCJldmFscyIsInNoaWZ0cyIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9pbnQ2NF9vZmZzZXQiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsImgiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwicSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X25lZyIsImludGVnZXJzX3VpbnRfb2Zfc3RyaW5nIiwibWF4X3ZhbCIsIm5lZ2F0aXZlIiwibm9fZGlnaXRzIiwidGVuIiwibWF4X2Jhc2VfMTAiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiVUludDMyIiwiaW50ZWdlcnNfdWludDMyX29mX2ludDY0IiwiaW50ZWdlcnNfdWludDMyX29mX3N0cmluZyIsImNhbWxfbG9nMTBfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZxX2NvcHkiLCJjYW1sX3Bhc3RhX2ZxX3N1YiIsImNhbWxfcGFzdGFfZnFfbXV0X3N1YiIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJjb2x1bW5fb2ZfcnVzdCIsImNvbCIsImdhdGVfdHlwZSIsInZhcmlhYmxlX29mX3J1c3QiLCJ2YXJpYWJsZSIsInJvdyIsInBvbGlzaF90b2tlbl9vZl9ydXN0IiwidG9rZW4iLCJpMCIsInB0ciIsIm9iaiIsIk9iamVjdCIsImluZGV4X3Rlcm1fb2ZfcnVzdCIsInRlcm0iLCJ0b2tlbl9jbGFzcyIsImNvbHVtbiIsImNvZWZmaWNpZW50IiwibGluZWFyaXphdGlvbl9vZl9ydXN0IiwibGluZWFyaXphdGlvbiIsImFmZmluZV9jbGFzcyIsIkYiLCJXYXNtUG9saXNoVG9rZW4iLCJXYXNtSW5kZXhUZXJtIiwiY29uc3RhbnRfdGVybSIsImluZGV4X3Rlcm1zIiwid2FzbUluZGV4VGVybSIsImNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QiLCJsb2dfc2l6ZV9vZl9ncm91cCIsImdyb3VwX2dlbiIsImNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3QiLCJhZmZpbmVfa2xhc3MiLCJjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdCIsIk5vbmUiLCJjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QiLCJsb29rdXBfaW5kZXgiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSIsImNhbWxfcGFzdGFfZnFfcHJpbnQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiYSIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJpbnRlZ2Vyc191bG9uZ2xvbmdfc2l6ZSIsInVuaXQiLCJjYW1sX2JhX2dldF8xIiwiYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIiLCJ2X2JzdHIiLCJ2X3NyY19wb3MiLCJ2X3N0ciIsInZfZHN0X3BvcyIsInZfbGVuIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9jcmVhdGUiLCJnYXRlcyIsInB1YmxpY19pbnB1dHMiLCJ1cnMiLCJ1bml4X2dldHRpbWVvZmRheSIsImNhbWxfdmVzdGFfZW5kb19iYXNlIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsImNhbWxfY2FsbF9nZW4iLCJhcmdzIiwiYXJnc0xlbiIsImV4dHJhX2FyZ3MiLCJhcmd1bWVudHMiLCJuYXJncyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsIndyaXRlciIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJkYXRhIiwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiTmFOIiwiY2FtbF9iYV9nZXRfc2l6ZSIsImRpbXMiLCJuX2RpbXMiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSIsImNhbWxfaW50NjRfaGkzMiIsImNhbWxfaW50NjRfbG8zMiIsImNhbWxfYmFfY3VzdG9tX25hbWUiLCJNbF9CaWdhcnJheSIsImxheW91dCIsImltIiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJzaXplcyIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2J5dGVzX2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfZ3JlYXRlcnRoYW4iLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInN0ciIsInRlbXAiLCJkb2N1bWVudCIsImNhbWxfYmFfc2V0XzIiLCJjYW1sX3Bhc3RhX2ZxX2RvbWFpbl9nZW5lcmF0b3IiLCJjYW1sX2pzX2V2YWxfc3RyaW5nIiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfZnFfc3JzX2giLCJjYW1sX3BhbGxhc19uZWdhdGUiLCJjYW1sX3N5c19leGl0IiwiY29kZSIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNoYW5pZCIsImNoYW4iLCJjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdCIsIndpcmUiLCJjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3QiLCJ3aXJlcyIsImNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvciIsImlubmVyX2xlbiIsIm91dHB1dF9sZW4iLCJpbm5lcl9yZXMiLCJjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdCIsImdhdGUiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2dldCIsImNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvciIsImNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZCIsImNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdCIsInJvS2xhc3MiLCJqb2ludF9jb21iaW5lcl9vY2FtbCIsImpvaW50X2NvbWJpbmVyX2NoYWwiLCJqb2ludF9jb21iaW5lciIsIlVJbnQ2NCIsImludGVnZXJzX3VpbnQ2NF9vZl9zdHJpbmciLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfZ3Jfc3RhdGUiLCJjYW1sX2dyX3N0YXRlX2dldCIsImNhbWxfZ3JfZmlsbF9yZWN0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwicG9zMSIsImJhMiIsInBvczIiLCJzbGljZSIsImNhbWxfZnBfc3JzX2giLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSIsInZrIiwidmtfY2FtbCIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJjYW1sX3Bhc3RhX2ZxX2RlZXBfY29weSIsImJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWIiLCJjYW1sX2FycmF5X3NldCIsImFycmF5IiwiaW5kZXgiLCJuZXd2YWwiLCJiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViIiwidl9idWYiLCJ2X2FyciIsImNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUiLCJhcHBlbmQiLCJjYW1sX3BhbGxhc19yYW5kb20iLCJjYW1sX3Bhc3RhX2ZwX3RvX2JpZ2ludCIsImNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX3RvX3J1c3QiLCJ3X2NvbW0iLCJ6X2NvbW0iLCJ0X2NvbW0iLCJjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCIsImNvbnZlcnRfYWZmaW5lcyIsImFmZmluZXMiLCJsciIsImRlbHRhIiwiejEiLCJ6MiIsInNnIiwibF9vY2FtbCIsInJfb2NhbWwiLCJjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0IiwiUEVSTVVUU19NSU5VU18xIiwiQ09MVU1OUyIsImNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCIsImdlbmVyaWNfc2VsZWN0b3IiLCJwb3NlaWRvbl9zZWxlY3RvciIsImNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdCIsImNvbW1pdG1lbnRzIiwicHJvb2YiLCJldmFsczAiLCJldmFsczEiLCJmdF9ldmFsMSIsInB1YmxpY18iLCJwcmV2X2NoYWxsZW5nZXMiLCJjaGFsc19sZW4iLCJwcmV2X2NoYWxsZW5nZXNfc2NhbGFycyIsInByZXZfY2hhbGxlbmdlc19jb21tcyIsImNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0IiwiRXJyb3IiLCJ0dXBsZSIsImNhbWxfZnBfdmVjdG9yX29mX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QiLCJtZXNzYWdlcyIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5IiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfaW50NjRfdG9fZmxvYXQiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15IiwiY2FtbF9iYV91aW50OF9nZXQzMiIsImJpZ0ludCIsIkJBU0UiLCJMT0dfQkFTRSIsIk1BWF9JTlQiLCJNQVhfSU5UX0FSUiIsInNtYWxsVG9BcnJheSIsIkRFRkFVTFRfQUxQSEFCRVQiLCJCaWdJbnQiLCJzdXBwb3J0c05hdGl2ZUJpZ0ludCIsIkludGVnZXIiLCJyYWRpeCIsImFscGhhYmV0IiwiY2FzZVNlbnNpdGl2ZSIsInBhcnNlVmFsdWUiLCJwYXJzZUJhc2UiLCJCaWdJbnRlZ2VyIiwidmFsdWUiLCJTbWFsbEludGVnZXIiLCJOYXRpdmVCaWdJbnQiLCJpc1ByZWNpc2UiLCJhcnJheVRvU21hbGwiLCJhcnIiLCJ0cmltIiwiY29tcGFyZUFicyIsImNyZWF0ZUFycmF5IiwidHJ1bmNhdGUiLCJhZGQiLCJsX2EiLCJsX2IiLCJjYXJyeSIsImJhc2UiLCJzdW0iLCJhZGRBbnkiLCJhZGRTbWFsbCIsInN1YnRyYWN0IiwiYV9sIiwiYl9sIiwiYm9ycm93IiwiZGlmZmVyZW5jZSIsInN1YnRyYWN0QW55Iiwic3VidHJhY3RTbWFsbCIsInNtYWxsIiwibXVsdGlwbHlMb25nIiwicHJvZHVjdCIsImFfaSIsImJfaiIsIm11bHRpcGx5U21hbGwiLCJzaGlmdExlZnQiLCJtdWx0aXBseUthcmF0c3ViYSIsImFjIiwiYmQiLCJhYmNkIiwidXNlS2FyYXRzdWJhIiwibDEiLCJsMiIsImFicyIsIm11bHRpcGx5U21hbGxBbmRBcnJheSIsInNxdWFyZSIsImFfaiIsImRpdk1vZDEiLCJyZXN1bHQiLCJkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQiLCJsYW1iZGEiLCJyZW1haW5kZXIiLCJxdW90aWVudERpZ2l0Iiwic2hpZnQiLCJkaXZNb2RTbWFsbCIsImRpdk1vZDIiLCJwYXJ0IiwiZ3Vlc3MiLCJ4bGVuIiwiaGlnaHgiLCJoaWdoeSIsImNoZWNrIiwiZGl2TW9kQW55Iiwic2VsZiIsImNvbXBhcmlzb24iLCJxU2lnbiIsIm1vZCIsIm1TaWduIiwiXzAiLCJfMSIsIl8yIiwiaXNCYXNpY1ByaW1lIiwibWlsbGVyUmFiaW5UZXN0IiwiblByZXYiLCJzdHJpY3QiLCJpc1ByaW1lIiwiYml0cyIsImxvZ04iLCJpdGVyYXRpb25zIiwibmV3VCIsIm5ld1IiLCJsYXN0VCIsImxhc3RSIiwicG93ZXJzT2ZUd28iLCJwb3dlcnMyTGVuZ3RoIiwiaGlnaGVzdFBvd2VyMiIsInNoaWZ0X2lzU21hbGwiLCJyZW1RdW8iLCJiaXR3aXNlIiwieFNpZ24iLCJ5U2lnbiIsInhSZW0iLCJ5UmVtIiwieERpZ2l0IiwieURpZ2l0IiwieERpdk1vZCIsInlEaXZNb2QiLCJMT0JNQVNLX0kiLCJMT0JNQVNLX0JJIiwicm91Z2hMT0IiLCJpbnRlZ2VyTG9nYXJpdGhtIiwidG1wIiwicCIsIm1heCIsIm1pbiIsImdjZCIsImxjbSIsInJhbmRCZXR3ZWVuIiwibG93IiwiaGlnaCIsInJhbmdlIiwiZGlnaXRzIiwidG9CYXNlIiwicmVzdHJpY3RlZCIsInRvcCIsImRpZ2l0IiwidGV4dCIsImFic0Jhc2UiLCJhbHBoYWJldFZhbHVlcyIsImlzTmVnYXRpdmUiLCJzdGFydCIsInBhcnNlQmFzZUZyb21BcnJheSIsInZhbCIsInBvdyIsInN0cmluZ2lmeSIsIm5lZyIsIm91dCIsImxlZnQiLCJkaXZtb2QiLCJ0b0Jhc2VTdHJpbmciLCJ6ZXJvcyIsInBhcnNlU3RyaW5nVmFsdWUiLCJzcGxpdCIsImRlY2ltYWxQbGFjZSIsImlzVmFsaWQiLCJwYXJzZU51bWJlclZhbHVlIiwibWxfel9ub3JtYWxpemUiLCJtbF96X3NoaWZ0X3JpZ2h0IiwiYW10IiwiY2FtbF9vYmpfYmxvY2siLCJiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIiwiYnMiLCJpbnRlZ2Vyc191aW50MzJfY29tcGFyZSIsImNhbWxfcGFzdGFfZnBfY29weSIsImNhbWxfcGFzdGFfZnBfc3F1YXJlIiwiY2FtbF9wYXN0YV9mcF9tdXRfc3F1YXJlIiwiY2FtbF9maW5hbF9yZWxlYXNlIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfZ3JfcGxvdCIsImNvbG9yIiwiY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkIiwiY2FtbF9ieXRlc19zZXQ2NCIsImk2NCIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfdmVyaWZ5IiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfZmlsbF9zdHJpbmciLCJjYW1sX2djX21ham9yIiwibWxfel9zaGlmdF9sZWZ0IiwiZGVjcl9uYXQiLCJjYXJyeV9pbiIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfcGFzdGFfZnFfaXNfc3F1YXJlIiwiY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkIiwiY2FtbF9yYW5kb21fb3JhY2xlc19vZl9ydXN0IiwiY2FtbF9vcmFjbGVzX29mX3J1c3QiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfcGxvbmtfd2lyZV90b19ydXN0IiwiY2FtbF9wbG9ua193aXJlc190b19ydXN0IiwiY2FtbF9mcF9wbG9ua19nYXRlX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2FkZCIsImNvcmVfa2VybmVsX2djX21pbm9yX3dvcmRzIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2ZwX3ZlY3Rvcl9nZXQiLCJpbnRlZ2Vyc191aW50MzJfdG9faW50IiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9zdHJpbmciLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2giLCJjb3VudCIsImxpbWl0Iiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImhoIiwiQmFzZV9oYXNoX3N0cmluZyIsImNhbWxfc3RkX291dHB1dCIsInNsZW4iLCJqc19wcmludF9zdGRlcnIiLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX3N5c19vcGVuX2ludGVybmFsIiwiaWR4Iiwib3V0cHV0IiwiZmxhZ3MiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwiY2hhbm5lbCIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9tZDVfYnl0ZXMiLCJ4eCIsImZmIiwiZ2ciLCJtZDUiLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX3N5c19jbG9zZSIsImNhbWxfbWxfZmx1c2giLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjb3JlX21kNV9mZCIsImljIiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfZ2V0IiwiY2FtbF9lcGhlX2dldF9rZXkiLCJjYW1sX3RvX2pzX3N0cmluZyIsImpzb29fel9vZl9qc19zdHJpbmdfYmFzZSIsImJjIiwibWxfel9vZl9zdWJzdHJpbmdfYmFzZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemUiLCJjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXkiLCJvY2FtbF9ieXRlcyIsImNhbWxfcGFzdGFfZnFfb2ZfYnl0ZXMiLCJ3aW5fY2xlYW51cCIsImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlIiwiZXhuIiwiZm9yY2UiLCJjYW1sX3N5c19pc2F0dHkiLCJfY2hhbiIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemUiLCJtbF96X2djZGV4dF9pbnRlcm4iLCJsYXN0eCIsImxhc3R5IiwiaW50ZWdlcnNfdWludDhfZGVzZXJpYWxpemUiLCJjYW1sX2xleF9hcnJheSIsImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9ub3RlcXVhbCIsImludGVnZXJzX3VpbnQzMl9tYXgiLCJtbF96X2FicyIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXQiLCJ1bml4X2xvY2FsdGltZSIsImRfbnVtIiwiamFudWFyeWZpcnN0IiwiZG95IiwiamFuIiwianVsIiwic3RkVGltZXpvbmVPZmZzZXQiLCJjYW1sX2pzX2Zyb21fYXJyYXkiLCJjYW1sX2pzX21ldGhfY2FsbCIsImNhbWxfd2Vha19jcmVhdGUiLCJjYW1sX2VwaGVfY3JlYXRlIiwiY2FtbF9pbnQ2NF9vciIsImludGVnZXJzX3VpbnQ2NF9sb2dvciIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJiaWdzdHJpbmdfZGVzdHJveV9zdHViIiwiZGVzdHJveWVkX2RhdGEiLCJkZXN0cm95ZWRfYmlnc3RyaW5nIiwiYmlnc3RyaW5nX3JlYWxsb2MiLCJiaWdzdHJpbmciLCJuZXdfZGF0YSIsIm5ld19iaWdzdHJpbmciLCJjYW1sX3RyYW1wb2xpbmUiLCJpbnRlZ2Vyc191aW50MzJfb2ZfaW50MzIiLCJjYW1sX2ZwX3Nyc193cml0ZSIsIm1sX3pfcmVtIiwiY2FtbF93ZWFrX3NldCIsImNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yIiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJkZWZlcnJlZF9pc19kZXRlcm1pbmVkIiwiZGVmZXJyZWQiLCJjYW1sX3Zlc3RhX29mX2FmZmluZSIsImludGVnZXJzX3VpbnQ2NF9kaXYiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCIsImNhbWxfZnFfdmVjdG9yX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX3ZlcmlmeSIsImludGVnZXJzX3VpbnQzMl9sb2d4b3IiLCJjYW1sX2VwaGVfdW5zZXRfa2V5IiwiZGVmZXJyZWRfY3JlYXRlIiwicHJvbWlzZV9jcmVhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJCYXNlX2FtX3Rlc3RpbmciLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9ncl9kaXNwbGF5X21vZGUiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHMiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9hcnJheV9ibGl0IiwiYTEiLCJhMiIsImNhbWxfcGFsbGFzX2FmZmluZV9kZWVwX2NvcHkiLCJjYW1sX3N5c19nZXRjd2QiLCJjYW1sX2JpZ2ludF8yNTZfdG9fc3RyaW5nIiwiY2FtbF9saXN0X3RvX2pzX2FycmF5IiwiY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUiLCJjYW1sX291dHB1dF92YWwiLCJXcml0ZXIiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJ1bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiTWxOYXQiLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImNhbWxfdmVzdGFfdG9fYWZmaW5lIiwiYmlnc3RyaW5nX21lbWNtcF9zdHViIiwidl9zMSIsInZfczFfcG9zIiwidl9zMiIsInZfczJfcG9zIiwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyIsImludGVnZXJzX3VpbnQzMl9hZGQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9wYWxsYXNfZG91YmxlIiwiY2FtbF9lcGhlX3NldF9rZXkiLCJjYW1sX3Zlc3RhX2FkZCIsImNhbWxfYmlnaW50XzI1Nl90ZXN0X2JpdCIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9ncl9zaXplX3kiLCJjYW1sX3Bhc3RhX2ZxX2NvbXBhcmUiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiaW50ZWdlcnNfdWludDMyX3RvX2ludDY0IiwiaW50ZWdlcnNfdWludDMyX211bCIsInhfNjQiLCJ5XzY0IiwiY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c19vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX29mX3J1c3QiLCJjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9jcmVhdGUiLCJ3aXRuZXNzX2NvbHMiLCJwcmV2X3NncyIsImNhbWxfaW50NjRfaXNfemVybyIsIkJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIiLCJleHBvbmVudCIsIm9uZSIsIm11bCIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImludGVnZXJzX3VpbnQ2NF90b19pbnQ2NCIsIm1sX3pfcG9wY291bnQiLCJ6ZXJvIiwibWxfel9oYW1kaXN0IiwibWxfel9tdWwiLCJtbF96X3BvdyIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImJpZ3N0cmluZ19hbGxvYyIsIl8iLCJjYW1sX3N0cmluZ19nZXQiLCJyZV9tYXRjaCIsInJlX3dvcmRfbGV0dGVycyIsIm9wY29kZXMiLCJpc193b3JkX2xldHRlciIsImluX2JpdHNldCIsInJlX21hdGNoX2ltcGwiLCJwYXJ0aWFsIiwicHJvZyIsImNwb29sIiwibm9ybXRhYmxlIiwibnVtZ3JvdXBzIiwibnVtcmVnaXN0ZXJzIiwic3RhcnRjaGFycyIsInBjIiwicXVpdCIsImdyb3VwcyIsInJlX3JlZ2lzdGVyIiwiYmFja3RyYWNrIiwiaXRlbSIsInB1c2giLCJhY2NlcHQiLCJwcmVmaXhfbWF0Y2giLCJvcCIsInNhcmciLCJ1YXJnIiwiZ3JvdXAiLCJyZV9zZWFyY2hfYmFja3dhcmQiLCJkZWZlcnJlZF9wZWVrIiwibWxfel9sb2dhbmQiLCJjYW1sX3Zlc3RhX29mX2FmZmluZV9jb29yZGluYXRlcyIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc2lnbmJpdF9mbG9hdCIsImNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZSIsImpzbmFtZSIsImNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgiLCJjYW1sX2dyX3NldF90ZXh0X3NpemUiLCJjYW1sX2dyX3NldF9mb250IiwiY2FtbF9ncl9zZXRfY29sb3IiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IiwidGEiLCJjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkiLCJjYW1sX21sX3NlZWtfb3V0IiwiY2FtbF9qc190eXBlb2YiLCJkZWZlcnJlZF90b19wcm9taXNlIiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQiLCJleHBlY3RfdGVzdF9jb2xsZWN0b3JfYWZ0ZXJfdGVzdCIsInZzdGRvdXQiLCJ2c3RkZXJyIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY3JlYXRlX25hdCIsIm1sX3pfZml0c19pbnQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfYmlnaW50XzI1Nl9vZl9kZWNpbWFsX3N0cmluZyIsIkJhc2VfaW50X21hdGhfaW50MzJfY2x6IiwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6IiwiY2FtbF9wYXN0YV9mcF9hZGQiLCJjYW1sX2pzX3RvX3N0cmluZyIsImNvcmVfa2VybmVsX3RpbWVfbnNfZm9ybWF0IiwidGltZSIsImZvcm1hdGpzIiwianN0cmluZyIsImNhbWxfb2JqX2R1cCIsImNhbWxfd2Vha19nZXRfY29weSIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwic3RyaW5nIiwianNzdHJpbmciLCJpZCIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJpbnRlZ2Vyc191aW50MTZfZGVzZXJpYWxpemUiLCJjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyIsImludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZyIsImluY3JfbmF0IiwibWxfel9zaWduIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwiLCJjYW1sX2ZwX3Nyc19iX3BvbHlfY29tbWl0bWVudCIsImNoYWxzIiwibWxfel9uZXh0cHJpbWUiLCJ0d28iLCJjYW1sX2pzX2V4cHIiLCJjYW1sX3Bhc3RhX2ZxX2VxdWFsIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJfdW5pdCIsImZxX29yYWNsZXNfY3JlYXRlIiwibGdyX2NvbW0iLCJ2ZXJpZmllcl9pbmRleCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZSIsImNhbWxfaGFzaF91bml2X3BhcmFtIiwiaGFzaF9hY2N1IiwiaGFzaF9hdXgiLCJqc2J5dGVzIiwiY2FtbF92ZXN0YV9uZWdhdGUiLCJtbF96X2RpdiIsIm1sX3pfZGl2ZXhhY3QiLCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIiLCJjYW1sX3Zlc3RhX3JuZyIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9mbG9hdF9vZl9ieXRlcyIsImNhbWxfZnFfc3JzX3JlYWQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiY2FtbF9wYXN0YV9mcF9tdXRfYWRkIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfemFyaXRoX21hcnNoYWwiLCJibG9jayIsImNhbWxfZnBfdmVjdG9yX2VtcGxhY2VfYmFjayIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQiLCJjYW1sX3Zlc3RhX2VuZG9fc2NhbGFyIiwiY2FtbF9lcXVhbCIsImNhbWxfbWxfcmVmaWxsX2lucHV0Iiwic3RyX2xlbiIsImNvbXBhcmVfbmF0IiwibGVuMiIsImNhbWxfanNfZGVsZXRlIiwiY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwidGhyZXNob2xkIiwiY2FtbF9saXN0X21vdW50X3BvaW50IiwicHJldiIsImNhbWxfZnFfc3JzX2JfcG9seV9jb21taXRtZW50IiwiY2FtbF9tYXJzaGFsX2NvbnN0YW50cyIsImNhbWxfanNfZXF1YWxzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIl9tYWdpYyIsIl9ibG9ja19sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJvYmpfY291bnRlciIsImludGVybl9yZWMiLCJoZWFkZXIiLCJleHBlY3RlZF9zaXplIiwiYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IiwiaW50ZWdlcnNfdWludDE2X29mX3N0cmluZyIsIm1sX3pfZml0c19uYXRpdmVpbnQiLCJjYW1sX2dyX2FyY19hdXgiLCJjdHgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJjYW1sX2dyX2ZpbGxfYXJjIiwiY2FtbF9pbnQ2NF94b3IiLCJpbnRlZ2Vyc191aW50NjRfbG9neG9yIiwiaW50ZWdlcnNfdWludDMyX29mX2ludCIsImNhbWxfcGFsbGFzX29mX2FmZmluZSIsImNhbWxfcGFzdGFfZnBfY29tcGFyZSIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsIk1sU3RyaW5nUmVhZGVyIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZSIsImNhbWxfYmFfa2luZCIsImNhbWxfb3V0X2NoYW5uZWxfcG9zX2ZkIiwiY2FtbF9qc19mdW5fY2FsbCIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJjYW1sX25ld19zdHJpbmciLCJpbnRlZ2Vyc191aW50NjRfdG9fc3RyaW5nIiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImludGVnZXJzX3VpbnQzMl9zZXJpYWxpemUiLCJjYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGUiLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJ1bml4X2dtdGltZSIsImNhbWxfcGFzdGFfZnFfc3FydCIsInVuaXhfdGltZSIsImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QiLCJtbF96X2hhc2giLCJhY2MiLCJpbnRlZ2Vyc191aW50NjRfbG9nYW5kIiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfZnFfdmVjdG9yX2VtcGxhY2VfYmFjayIsIkJhc2VfaW50X21hdGhfaW50X2NseiIsImNhbWxfcGFzdGFfZnBfb2ZfYmlnaW50IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImJhMSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwibWxfel9yb290IiwiZW5kIiwiYW5zIiwibWlkIiwicG8iLCJtbF96X3NxcnRfcmVtIiwiZGlmZiIsImNhbWxfZXBoZV9kYXRhX29mZnNldCIsImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9tYXhfZGVncmVlIiwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCIsImFkZF9uYXQiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwibXVsdF9uYXQiLCJsZW4zIiwic3F1YXJlX25hdCIsImNhbWxfanNfZnJvbV9mbG9hdCIsImNhbWxfZ2Nfc3RhdCIsImNhbWxfcGFzdGFfZnFfYWRkIiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfdmVzdGFfYWZmaW5lX2RlZXBfY29weSIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViIiwiY2FtbF9qc19nZXRfY29uc29sZSIsImNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYiLCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkiLCJjYW1sX3JvdW5kX2Zsb2F0IiwibWxfel9vZl9iaXRzIiwiYmFzZTEiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3JlYWQiLCJjYW1sX2xkZXhwX2Zsb2F0IiwiY2FtbF96YXJpdGhfdW5tYXJzaGFsIiwibmVnYXRlIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3Bhc3RhX2ZxX29mX2ludCIsImNhbWxfb2JqX3NldF90YWciLCJpbnRlZ2Vyc191aW50OF9vZl9zdHJpbmciLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImludGVnZXJzX3VpbnQzMl9zdWIiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYnl0ZXMyIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZSIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImludGVnZXJzX3VpbnQzMl9kaXYiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwiZnBfb3JhY2xlc19jcmVhdGUiLCJjYW1sX2ZxX3ZlY3Rvcl9nZXQiLCJjYW1sX2JhX3NldF8xIiwiYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViIiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZnBfdmVjdG9yX2NyZWF0ZSIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9wYWxsYXNfdG9fYWZmaW5lIiwiY2FtbF9mcV9zcnNfY3JlYXRlIiwiY2FtbF9tbF9wb3Nfb3V0IiwiY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdCIsImNhbWxfc3BhY2V0aW1lX2VuYWJsZWQiLCJjYW1sX2pzX29iamVjdCIsImludGVnZXJzX3VpbnQ2NF9tYXJzaGFsIiwiY2FtbF9ieXRlc19vZl91aW50OGFycmF5IiwidWludDhhcnJheSIsImNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0IiwiZ2F0ZV92ZWN0b3IiLCJjb3JlX2tlcm5lbF9nY19jb21wYWN0aW9ucyIsImNhbWxfc3RyaW5nX2dldDE2IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZSIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2VwaGVfYmxpdF9rZXkiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdCIsImNhbWxfaW5pdGlhbF90aW1lIiwiY2FtbF9zeXNfdGltZSIsIm5vdyIsImNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbiIsImZwX29yYWNsZXNfZHVtbXkiLCJCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3BvcyIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2JpZ2ludF8yNTZfY29tcGFyZSIsImNhbWxfYmFfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwiQ29yZV9rZXJuZWxfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrIiwiYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWIiLCJtbF96X3ByZWQiLCJtbF96X2V4dHJhY3QiLCJtbF96X2xvZ25vdCIsImNhbWxfcGFzdGFfZnFfcm5nIiwiY2FtbF9vcmFjbGVzX3RvX3J1c3QiLCJmcF9vcmFjbGVzX2RlZXBfY29weSIsImNhbWxfcGFzdGFfZnBfaXNfc3F1YXJlIiwiY2FtbF9zZXRfc3RhdGljX2VudiIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsIm5ld19kaW1zIiwiY29yZV9rZXJuZWxfZ2NfdG9wX2hlYXBfd29yZHMiLCJjYW1sX3Bhc3RhX2ZxX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGUiLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfb2JqX3RydW5jYXRlIiwiY2FtbF9mcV9zcnNfbGFncmFuZ2VfY29tbWl0bWVudCIsImRvbWFpbl9zaXplIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfZ3Jfc3RhdGVfc2V0IiwiY2FtbF9ncl9zdGF0ZV9jcmVhdGUiLCJjYW52YXMiLCJjb250ZXh0IiwiY2FtbF9ncl9vcGVuX2dyYXBoIiwiZ2V0Iiwic3BlY3MiLCJ0YXJnZXQiLCJzdGF0dXMiLCJ3aW4iLCJkb2MiLCJ0aXRsZSIsImJvZHkiLCJjYW1sX3BhbGxhc19lbmRvX3NjYWxhciIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9iaWdpbnRfMjU2X3ByaW50IiwiY2FtbF9iaWdpbnRfMjU2X29mX251bWVyYWwiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9wYXN0YV9mcV9zcXVhcmUiLCJjYW1sX3Bhc3RhX2ZxX211dF9zcXVhcmUiLCJtbF96X251bWJpdHMiLCJ1cHBlckJvdW5kIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9ibG9ja19jaXBoZXIiLCJfZmFrZV9wYXJhbXMiLCJmcV92ZWN0b3IiLCJ3YXNtX2ZsYXRfdmVjdG9yIiwibmV3X2ZxX3ZlY3RvciIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiaW50ZWdlcnNfdWludDY0X211bCIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZCIsInNoYXBlIiwicmVhbCIsIm1sX3pfaW5pdCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwic3RhdGUiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3JlYWQiLCJjYW1sX3Bhc3RhX2ZwX25lZ2F0ZSIsImJpbl9wcm90X2JsaXRfc3RyaW5nX2J1Zl9zdHViIiwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX3Bhc3RhX2ZwX3N1YiIsImNhbWxfcGFzdGFfZnBfbXV0X3N1YiIsImNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCIsImludGVnZXJzX3VpbnQ2NF91bm1hcnNoYWwiLCJtbF96X3NpemUiLCJtbF96X2ZpdHNfaW50NjQiLCJtbF96X3RvX2ludDY0IiwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2ZwX3Nyc19jb21taXRfZXZhbHVhdGlvbnMiLCJmcHMiLCJjYW1sX3BhcnNlX2VuZ2luZSIsInRhYmxlcyIsImVudiIsImNtZCIsIkVSUkNPREUiLCJsb29wIiwidGVzdHNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2NyZWF0ZSIsImNhbWxfcGFzdGFfZnFfdHdvX2FkaWNfcm9vdF9vZl91bml0eSIsImNhbWxfdmVzdGFfc2NhbGUiLCJtbF96X2luc3RhbGxfZnJhbWV0YWJsZSIsImJpZ3N0cmluZ19ibGl0X3N0dWIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfcGFzdGFfZnBfc3FydCIsIkJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX3JuZyIsImNhbWxfcGFzdGFfZnBfdG9fc3RyaW5nIiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImRlZmVycmVkX29mX3Byb21pc2UiLCJwcm9taXNlIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9wYXN0YV9mcF9lcXVhbCIsImludGVnZXJzX3VpbnQzMl9kZXNlcmlhbGl6ZSIsImNhbWxfYmlnaW50XzI1Nl9kaXYiLCJpbnRlZ2Vyc191aW50MzJfdG9fc3RyaW5nIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjYW1sX2djX21pbm9yIiwiY2FtbF92ZXN0YV9zdWIiLCJjYW1sX2JhX251bV9kaW1zIiwiYmlnc3RyaW5nYWZfbWVtY21wX2JpZ3N0cmluZyIsImJhMV9vZmYiLCJiYTJfb2ZmIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX3N0cmluZyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9mcV9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2siLCJydXN0X2NvbW1zIiwicnVzdF9jaGFscyIsImNhbWxfcGFzdGFfZnBfZGVlcF9jb3B5IiwibWxfel9hZGQiLCJtbF96X2NkaXYiLCJ6MV9wb3MiLCJ6Ml9wb3MiLCJiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXMiLCJzcmMiLCJzcmNfb2ZmIiwiZHN0IiwiZHN0X29mZiIsImNhbWxfZnFfc3JzX2NvbW1pdF9ldmFsdWF0aW9ucyIsImZxcyIsImNhbWxfcGFzdGFfZnBfb2ZfYnl0ZXMiLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsInNldF90b196ZXJvX25hdCIsInN1Yl9uYXQiLCJkaXZfbmF0IiwicXVvIiwiY2FtbF9iYV9ibGl0IiwiaXNfZGlnaXRfaW50IiwiaW50ZWdlcnNfdWludDMyX2hhc2giLCJiaWdzdHJpbmdfZmluZCIsImNociIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9wYXN0YV9mcV9tdWwiLCJtbF96X29mX2ludDY0IiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QiLCJsb2MiLCJ1bmRlZl9tb2R1bGUiLCJfeCIsInN0cnVjdCIsImludGVnZXJzX3VpbnQ2NF9vZl9pbnQiLCJtbF96X25lZyIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2JlZm9yZV90ZXN0Iiwidm91dHB1dCIsImNhbWxfc2V0X29vX2lkIiwibWxfel9vZl9pbnQiLCJtbF96X29mX2ludDMyIiwiaTMyIiwiY2FtbF9jb21wYXJlIiwiY2FtbF9wYXN0YV9mcV90b19ieXRlcyIsImNhbWxfcGFsbGFzX3N1YiIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiY2FtbF9wYXN0YV9mcV9tdXRfYWRkIiwibHhvcl9kaWdpdF9uYXQiLCJpbnRlZ2Vyc191aW50NjRfcmVtIiwibWxfel9sb2dvciIsIm1sX3pfZml0c19pbnQzMiIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsImJhY2t0cmsiLCJjYW1sX3N5c19maWxlX2V4aXN0cyIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX2FycmF5X3N1YiIsImNhbWxfZ3Jfc2l6ZV94IiwiY2FtbF9wYXN0YV9mcV9tdXRfbXVsIiwiY2FtbF9wYXN0YV9mcF9zaXplIiwiY2FtbF9iaWdpbnRfMjU2X251bV9saW1icyIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX29mX2ludCIsImNhbWxfd2Vha19jaGVjayIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJjYW1sX2dyX3RleHRfc2l6ZSIsInR4dCIsImNhbWxfbGV4X3J1bl9tZW0iLCJtZW0iLCJjdXJyX3BvcyIsImNhbWxfbGV4X3J1bl90YWciLCJjYW1sX25ld19sZXhfZW5naW5lIiwibGV4X21lbSIsImxleF9iYXNlX2NvZGUiLCJsZXhfYmFja3Rya19jb2RlIiwibGV4X2RlZmF1bHRfY29kZSIsImxleF90cmFuc19jb2RlIiwibGV4X2NoZWNrX2NvZGUiLCJsZXhfY29kZSIsInBjX29mZiIsInBzdGF0ZSIsImJhc2VfY29kZSIsImludGVnZXJzX3Vsb25nX3NpemUiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJpbnRlZ2Vyc191aW50MzJfc2hpZnRfbGVmdCIsImNhbWxfanNfZ2V0IiwiY2FtbF9nY19jb21wYWN0aW9uIiwiY2FtbF9hcnJheV9nZXQiLCJiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYSIsIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViIiwiaXNfZGlnaXRfemVybyIsImNhbWxfanNfc2V0IiwiY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9ibG9ja19jaXBoZXIiLCJmcF92ZWN0b3IiLCJuZXdfZnBfdmVjdG9yIiwiY2FtbF92ZXN0YV9kb3VibGUiLCJjYW1sX3Bhc3RhX2ZwX29mX3N0cmluZyIsIm1sX3pfdGVzdGJpdCIsImNvcmVfa2VybmVsX2djX21ham9yX3BsdXNfbWlub3Jfd29yZHMiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyIsImxvZzJfc2l6ZSIsImJpbl9wcm90X2JsaXRfYnl0ZXNfYnVmX3N0dWIiLCJjYW1sX2ludDY0X3N1YiIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImJpbl9wcm90X2JsaXRfYnVmX3N0dWIiLCJ2X3NyYyIsInZfZHN0Iiwidl9zcmMyIiwidl9kc3QyIiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9zeXNfY29uc3RfaW50X3NpemUiLCJjYW1sX2ZwX3Nyc19sYWdyYW5nZV9jb21taXRtZW50IiwiY2FtbF9iYV9kaW0iLCJjYW1sX2JhX2RpbV8xIiwibWxfel9zcXJ0IiwiY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2siLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwiZGVmZXJyZWRfdmFsdWVfZXhuIiwibWxfel9wcm9iYWJfcHJpbWUiLCJ1bml4X21rdGltZSIsInRtIiwidG0yIiwiY2FtbF9iaWdpbnRfMjU2X2RlZXBfY29weSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3Bhc3RhX2ZxX29mX2JpZ2ludCIsImNhbWxfZnFfdmVjdG9yX2xlbmd0aCIsImNhbWxfc3lzX3JlbW92ZSIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3dyaXRlIiwiY2FtbF9mcF92ZWN0b3JfbGVuZ3RoIiwiY2FtbF9wYXN0YV9mcV9pbnYiLCJtbF96X3RvX2ludCIsImJpZ3N0cmluZ2FmX2JsaXRfdG9fYnl0ZXMiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfcGFzdGFfZnBfaW52IiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY29yZV9rZXJuZWxfZ2NfbWFqb3Jfd29yZHMiLCJjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbiIsImludGVnZXJzX3VpbnQzMl9sb2dhbmQiLCJtbF96X3N1Y2MiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kdW1teSIsImNhbWxfbmV4dGFmdGVyX2Zsb2F0IiwiaW50ZWdlcnNfdWludDY0X21heCIsImludGVnZXJzX3VpbnQ2NF9vZl9pbnQ2NCIsIm1sX3pfZ2NkIiwiY2FtbF9wYXN0YV9mcF90b19ieXRlcyIsImludGVnZXJzX3NpemVfdF9zaXplIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsIm1sX3pfZGl2X3JlbSIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImJ0IiwiY2FtbF9ncl9saW5ldG8iLCJjYW1sX2JhX2RpbV8zIiwiY2FtbF9wYWxsYXNfcm5nIiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9jcmVhdGUiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX3Bhc3RhX2ZwX211bCIsImNhbWxfcGFzdGFfZnBfbXV0X211bCIsImNhbWxfcGFzdGFfZnBfcHJpbnQiLCJiaWdzdHJpbmdfbWVtc2V0X3N0dWIiLCJ2X3BvcyIsInZfY2hhciIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemUiLCJjYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0cyIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY2FtbF9mcV9wbG9ua19nYXRlX3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2FkZCIsImNhbWxfdmVzdGFfb25lIiwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHoiLCJjYW1sX2FycmF5X2FwcGVuZCIsImNhbWxfcGFsbGFzX2VuZG9fYmFzZSIsImNhbWxfcGFzdGFfZnBfZGl2IiwibWxfel9zdWIiLCJtbF96X2ZkaXYiLCJjYW1sX2ZxX3Nyc193cml0ZSIsIm1sX3pfdG9fYml0cyIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsImNhbWxfcHVyZV9qc19leHByIiwiYmxpdF9uYXQiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiY2FtbF9wYXN0YV9mcF9kb21haW5fZ2VuZXJhdG9yIiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJkZWZlcnJlZF91cG9uX2V4biIsImZ1bmMiLCJyZV9zZWFyY2hfZm9yd2FyZCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9qc192YXIiLCJpbnRlZ2Vyc191aW50NjRfdG9faW50IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwIiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsImNvcmVfa2VybmVsX2djX3Byb21vdGVkX3dvcmRzIiwiY2FtbF9pc19wcmludGFibGUiLCJyZV9wYXJ0aWFsX21hdGNoIiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMiIsIndpbl9oYW5kbGVfZmQiLCJjYW1sX2JhX3VpbnQ4X3NldDE2IiwiY2FtbF9iaWdpbnRfMjU2X3RvX2J5dGVzIiwiY29yZV9rZXJuZWxfZ2NfaGVhcF9jaHVua3MiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsIm1sX3pfb2ZfbmF0aXZlaW50IiwibWxfel9pbnZlcnQiLCJtbF96X3Bvd20iLCJ6MyIsImludiIsIm1sX3pfcG93bV9zZWMiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0IiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfcGFzdGFfZnFfdG9fYmlnaW50IiwiY2FtbF9zeXNfZ2V0X2NvbmZpZyIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsImNhbWxfZnBfc3JzX3JlYWQiLCJkZWZlcnJlZF9iaW5kIiwibmV3RGVmZXJyZWQiLCJhbm90aGVyRGVmZXJyZWQiLCJjYW1sX2JpZ2ludF8yNTZfb2ZfYnl0ZXMiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X21heF9kZWdyZWUiLCJjb3JlX2tlcm5lbF9nY19taW5vcl9jb2xsZWN0aW9ucyIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwiY2FtbF9wYXN0YV9mcV9zaXplX2luX2JpdHMiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIiwiaW50ZWdlcnNfdWludDY0X2NvbXBhcmUiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwibWxfel9lcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuIiwiY2FtbF9kaXYiLCJtbF96X3BlcmZlY3Rfc3F1YXJlIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX2dyX2NyZWF0ZV9pbWFnZSIsImNhbWxfZXBoZV9nZXRfa2V5X2NvcHkiLCJjYW1sX2xlc3N0aGFuIiwibWxfel90b19uYXRpdmVpbnQiLCJiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nIiwiYmFfb2ZmIiwic3RyX29mZiIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJjb3JlX21kNV9kaWdlc3Rfc3ViYmlnc3RyaW5nIiwicmVzMiIsImNhbWxfZnBfc3JzX2NyZWF0ZSIsImNhbWxfZmxvYXRhcnJheV9jcmVhdGUiLCJjYW1sX3BhbGxhc19vZl9hZmZpbmVfY29vcmRpbmF0ZXMiLCJkZWZlcnJlZF9tYXAiLCJjYW1sX29qc19uZXdfYXJyIiwiaW50ZWdlcnNfdWludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX3Zlc3RhX3JhbmRvbSIsImNvbXBsZW1lbnRfbmF0IiwiY2FtbF9wYXN0YV9mcV9kaXYiLCJtbF96X2xvZ3hvciIsImNhbWxfcGFzdGFfZnFfc2l6ZSIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2JhX2RpbV8yIiwibWxfel90cmFpbGluZ196ZXJvcyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfcGFsbGFzX3NjYWxlIiwibGFuZF9kaWdpdF9uYXQiLCJjYW1sX2ludDY0X21vZCIsImNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuIiwiY2FtbF9pbnQzMl9ic3dhcCIsIndpbl9zdGFydHVwIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiaW50ZWdlcnNfdWludDMyX3NoaWZ0X3JpZ2h0IiwiY2FtbF90YW5oX2Zsb2F0IiwiaW50ZWdlcnNfdWludF9zaXplIiwiY2FtbF9ncl9kcmF3X2NoYXIiLCJjYW1sX3VubW91bnQiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2RlZXBfY29weSIsImNhbWxfcGFzdGFfZnFfbmVnYXRlIiwiaW50ZWdlcnNfdXNob3J0X3NpemUiLCJjYW1sX21sX3Bvc19pbl82NCIsImNhbWxfZ3JfZHJhd19pbWFnZSIsImltYWdlIiwiY2FtbF9zdHJpbmdfc2V0IiwiaW50ZWdlcnNfdWludDMyX3JlbSIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzIiwiaW50ZWdlcnNfdWludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9kdW1teSIsIkJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlIiwiaW50ZWdlcnNfdWludDY0X3N1YiIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfd3JpdGUiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsIm1vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3Bhc3RhX2ZwX3JhbmRvbSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZnFfdmVjdG9yX2NyZWF0ZSIsImNhbWxfcGFzdGFfZnFfcmFuZG9tIiwibWxfel90b19pbnQzMiIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkiLCJkZWZlcnJlZF91cG9uIiwiZGVmZXJyZWRfcnVuIiwibWxfel9jb21wYXJlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnkiLCJpbmRleGVzIiwicHJvb2ZzIiwiY2FtbF9vYmpfdGFnIiwiRnVuY3Rpb24iLCJjYW1sX2pzX2V4cG9ydF92YXIiLCJjYW1sX2J5dGVzX2dldDMyIiwiY29yZV9rZXJuZWxfZ2NfbWFqb3JfY29sbGVjdGlvbnMiLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfbWxfcG9zX291dF82NCIsIm1sX3pfb2ZfZmxvYXQiLCJmMSIsImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IiwiZnFfb3JhY2xlc19kdW1teSIsImRlZmVycmVkX3JldHVybiIsIkJhc2VfaGFzaF9kb3VibGUiLCJjYW1sX2pzX25ldyIsImNhbWxfcGFzdGFfZnBfdHdvX2FkaWNfcm9vdF9vZl91bml0eSIsImNhbWxfcGFzdGFfZnFfb2Zfc3RyaW5nIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiaW50ZWdlcnNfdWludDY0X2hhc2giLCJjb3JlX2tlcm5lbF9nY19oZWFwX3dvcmRzIiwiYmlnc3RyaW5nYWZfYmxpdF90b19iaWdzdHJpbmciLCJjYW1sX3BhbGxhc19vbmUiLCJtc190b19uYW5vIiwidGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvIiwibXMiLCJtc19pNjMiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2JpZ2ludF8yNTZfYnl0ZXNfcGVyX2xpbWIiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2JhX2xheW91dCIsImludGVnZXJzX2ludDMyX29mX3VpbnQzMiIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJtbF96X3BlcmZlY3RfcG93ZXIiLCJsb2cyeiIsInpwIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0IiwiaW50ZWdlcnNfdWludDMyX2xvZ29yIiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHMiLCJjYW1sX3Bhc3RhX2ZxX3RvX3N0cmluZyIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsIm1sX3pfZm9ybWF0IiwiY2FzIiwid2lkdGgiLCJhbHQiLCJwYWQiLCJwcmVmaXgiLCJwcmUiLCJmcV9vcmFjbGVzX2RlZXBfY29weSIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2JhX2ZpbGwiLCJtbF96X3NoaWZ0X3JpZ2h0X3RydW5jIiwiY2FtbF9zdHJpbmdfc2V0MzIiLCJpbnRlZ2Vyc191bnNpZ25lZF9pbml0IiwiaW50ZWdlcnNfdWludDY0X2FkZCIsImNhbWxfcGFsbGFzX2FkZCIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX2dyX21ha2VfaW1hZ2UiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5Il0sInNvdXJjZXMiOlsiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvY29yZV9rZXJuZWwvc3RyZnRpbWUuanMiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2xpYi9jcnlwdG8va2ltY2hpX2JpbmRpbmdzL2pzL2Nocm9tZS9jaHJvbWVfYmFja2VuZC5qcyIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvbGliL2NyeXB0by9raW1jaGlfYmluZGluZ3MvanMvYmluZGluZ3MuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2xpYi9pbnRlZ2Vyc19zdHVic19qcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvYmFzZV9iaWdzdHJpbmcvcnVudGltZS5qcyIsIi9idWlsdGluLytwYXJzaW5nLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rY29tcGFyZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi9iaW5fcHJvdC9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL3phcml0aF9zdHVic19qcy9iaWdpbnRlZ2VyLmpzIiwiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvemFyaXRoX3N0dWJzX2pzL3J1bnRpbWUuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi9jb3JlX2tlcm5lbC9ydW50aW1lLmpzIiwiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvYmFzZS9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL2Jhc2UvYmFzZV9pbnRlcm5hbGhhc2hfdHlwZXMvcnVudGltZS5qcyIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvbGliL3Byb21pc2UvanMvcHJvbWlzZS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi9wcHhfZXhwZWN0L2NvbGxlY3Rvci9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy1jc3RydWN0LmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytpbnRlcm5hbE1vZC5qcyIsIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL2JpZ3N0cmluZ2FmL3J1bnRpbWUuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi90aW1lX25vdy9ydW50aW1lLmpzIl0sIm1hcHBpbmdzIjoiOztLQVdFO1FBRUU7U0FBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBcUJFLG9CQUFNRSxTQUFTRjtTQUNwQixrQkFBU0k7U0FDcEJDO1FBR0osR0FBSUY7U0FBWSxDQUNaRSxZQUFZRCxpQkFBaUJFO1VBQzdCRCxxQkFBcUJFO1VBQ3JCLEdBQUdDLGtCQUFtQkEsNkJBQTZCRjs7U0FHbEQsQ0FFREQ7O1VBQVlHOztV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QVFuN0I7TUFDM0MsT0FBTyxrREFBa0RrN0IsUUFBU0MsT0FIekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gc3RyZnRpbWVcbi8vIGdpdGh1Yi5jb20vc2Ftc29uanMvc3RyZnRpbWVcbi8vIEBfc2pzXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTAgLSAyMDE1IFNhbWkgU2FtaHVyaSA8c2FtaUBzYW1odXJpLm5ldD5cbi8vXG4vLyBNSVQgTGljZW5zZVxuLy8gaHR0cDovL3Nqcy5taXQtbGljZW5zZS5vcmdcbi8vXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgRGVmYXVsdExvY2FsZSA9IHtcbiAgICAgICAgICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIHNob3J0RGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgICAgIG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICAgICAgQU06ICdBTScsXG4gICAgICAgICAgICBQTTogJ1BNJyxcbiAgICAgICAgICAgIGFtOiAnYW0nLFxuICAgICAgICAgICAgcG06ICdwbScsXG4gICAgICAgICAgICBmb3JtYXRzOiB7XG4gICAgICAgICAgICAgICAgRDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgICAgICBGOiAnJVktJW0tJWQnLFxuICAgICAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICAgICAgVDogJyVIOiVNOiVTJyxcbiAgICAgICAgICAgICAgICBYOiAnJVQnLFxuICAgICAgICAgICAgICAgIGM6ICclYSAlYiAlZCAlWCAlWScsXG4gICAgICAgICAgICAgICAgcjogJyVJOiVNOiVTICVwJyxcbiAgICAgICAgICAgICAgICB2OiAnJWUtJWItJVknLFxuICAgICAgICAgICAgICAgIHg6ICclRCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFN0cmZ0aW1lID0gbmV3IFN0cmZ0aW1lKERlZmF1bHRMb2NhbGUsIDAsIGZhbHNlKSxcbiAgICAgICAgaXNDb21tb25KUyA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICBuYW1lc3BhY2U7XG5cbiAgICAvLyBDb21tb25KUyAvIE5vZGUgbW9kdWxlXG4gICAgaWYgKGlzQ29tbW9uSlMpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gbW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgICAgIG5hbWVzcGFjZS5zdHJmdGltZSA9IGRlcHJlY2F0ZWRTdHJmdGltZTtcbiAgICAgICAgaWYoam9vX2dsb2JhbF9vYmplY3QpIGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cbiAgICAvLyBCcm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIG9iamVjdC4gV29ya3MgaW4gRVMzLCBFUzUsIGFuZCBFUzUgc3RyaWN0IG1vZGUuXG4gICAgICAgIG5hbWVzcGFjZSA9IGpvb19nbG9iYWxfb2JqZWN0IHx8IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfHwgKDEsZXZhbCkoJ3RoaXMnKTsgfSgpKTtcbiAgICAgICAgbmFtZXNwYWNlLnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgQVBJLCB0byBiZSByZW1vdmVkIGluIHYxLjBcbiAgICB2YXIgX3JlcXVpcmUgPSBpc0NvbW1vbkpTID8gXCJyZXF1aXJlKCdzdHJmdGltZScpXCIgOiBcInN0cmZ0aW1lXCI7XG4gICAgdmFyIF9kZXByZWNhdGlvbldhcm5pbmdzID0ge307XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG5hbWUsIGluc3RlYWQpIHtcbiAgICAgICAgaWYgKCFfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gXCIgKyBuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMS4wLiBJbnN0ZWFkLCB1c2UgYFwiICsgaW5zdGVhZCArIFwiYC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc3BhY2Uuc3RyZnRpbWVUWiA9IGRlcHJlY2F0ZWRTdHJmdGltZVRaO1xuICAgIG5hbWVzcGFjZS5zdHJmdGltZVVUQyA9IGRlcHJlY2F0ZWRTdHJmdGltZVVUQztcbiAgICBuYW1lc3BhY2UubG9jYWxpemVkU3RyZnRpbWUgPSBkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQ7XG5cbiAgICAvLyBBZGFwdCB0aGUgb2xkIEFQSSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXcgQVBJLlxuICAgIGZ1bmN0aW9uIGFkYXB0Rm9yd2FyZHMoZm4pIHtcbiAgICAgICAgZm4ubG9jYWxpemUgPSBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgICAgICBmbi50aW1lem9uZSA9IGRlZmF1bHRTdHJmdGltZS50aW1lem9uZS5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgICAgIGZuLnV0YyA9IGRlZmF1bHRTdHJmdGltZS51dGMuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgIH1cblxuICAgIGFkYXB0Rm9yd2FyZHMoYWRhcHRlZFN0cmZ0aW1lKTtcbiAgICBmdW5jdGlvbiBhZGFwdGVkU3RyZnRpbWUoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgLy8gZCBhbmQgbG9jYWxlIGFyZSBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBsb2NhbGUpXG4gICAgICAgIGlmIChkICYmIGQuZGF5cykge1xuICAgICAgICAgICAgbG9jYWxlID0gZDtcbiAgICAgICAgICAgIGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIihmb3JtYXQsIFtkYXRlXSwgW2xvY2FsZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBhZGFwdEZvcndhcmRzKGRlcHJlY2F0ZWRTdHJmdGltZSk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0sIFtsb2NhbGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0pYFwiLCBfcmVxdWlyZSArIFwiKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVFooZm10LCBkLCBsb2NhbGUsIHRpbWV6b25lKSB7XG4gICAgICAgIC8vIGxvY2FsZSBpcyBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBkYXRlLCB0aW1lem9uZSlcbiAgICAgICAgaWYgKCh0eXBlb2YgbG9jYWxlID09ICdudW1iZXInIHx8IHR5cGVvZiBsb2NhbGUgPT0gJ3N0cmluZycpICYmIHRpbWV6b25lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWV6b25lID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0eilgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKS50aW1lem9uZSh0eik7IHMoZm9ybWF0LCBbZGF0ZV0pYCBvciBgdmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcy50aW1lem9uZSh0eikoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgdHopYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLnRpbWV6b25lKHR6KTsgcyhmb3JtYXQsIFtkYXRlXSlgIG9yIGBcIiArIF9yZXF1aXJlICsgXCIudGltZXpvbmUodHopKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJmdGltZSA9IChsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZSkudGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICB2YXIgdXRjU3RyZnRpbWUgPSBkZWZhdWx0U3RyZnRpbWUudXRjKCk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVVRDKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVVVEMoZm9ybWF0LCBkYXRlLCBsb2NhbGUpYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSkudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVVUQyhmb3JtYXQsIFtkYXRlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IHV0Y1N0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiB1dGNTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkKGxvY2FsZSkge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplZFN0cmZ0aW1lKGxvY2FsZSlgXCIsIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKVwiKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpO1xuICAgIH1cbiAgICAvLyBFbmQgb2YgZGVwcmVjYXRlZCBBUElcblxuICAgIC8vIFBvbHlmaWxsIERhdGUubm93IGZvciBvbGQgYnJvd3NlcnMuXG4gICAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdHJmdGltZShsb2NhbGUsIGN1c3RvbVRpbWV6b25lT2Zmc2V0LCB1c2VVdGNUaW1lem9uZSkge1xuICAgICAgICB2YXIgX2xvY2FsZSA9IGxvY2FsZSB8fCBEZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID0gY3VzdG9tVGltZXpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIF91c2VVdGNCYXNlZERhdGUgPSB1c2VVdGNUaW1lem9uZSB8fCBmYWxzZSxcblxuICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdW5peCB0aW1lc3RhbXAgdmFsdWUgaGVyZSB0byBub3QgY3JlYXRlIG5ldyBEYXRlKCkgZWFjaCBpdGVyYXRpb24gKGVhY2ggbWlsbGlzZWNvbmQpXG4gICAgICAgICAgICAvLyBEYXRlLm5vdygpIGlzIDIgdGltZXMgZmFzdGVyIHRoYW4gbmV3IERhdGUoKVxuICAgICAgICAgICAgLy8gd2hpbGUgbWlsbGlzZWNvbmQgcHJlY2lzZSBpcyBlbm91Z2ggaGVyZVxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB2ZXJ5IGhlbHBmdWwgd2hlbiBzdHJmdGltZSB0cmlnZ2VyZWQgYSBsb3Qgb2YgdGltZXMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgX2NhY2hlZERhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0cmZ0aW1lKGZvcm1hdCwgZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZXN0YW1wID4gX2NhY2hlZERhdGVUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSBjdXJyZW50VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZSA9IG5ldyBEYXRlKF9jYWNoZWREYXRlVGltZXN0YW1wKTtcblxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfY2FjaGVkRGF0ZVRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93IHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIGRhdGUgaW5zdGFudGlhdGlvbiBmb3IgdXRjIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0aWVkIHRvIGdldFRpbWV6b25lT2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlID0gbmV3IERhdGUoX2NhY2hlZERhdGVUaW1lc3RhbXAgKyBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihfY2FjaGVkRGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUgPSBfY2FjaGVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoZGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgX2xvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmb3JtYXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVFogPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyQ29kZSA9IGZvcm1hdC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5TY29wZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICdfJ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnOidcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA1OCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZFRaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gZGV0ZWN0ZWQgdXNlIG9mIHVuc3VwcG9ydGVkICU6OiBvciAlOjo6IG1vZGlmaWVycyB0byBzdHJmdGltZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUWiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlcyBmb3IgbmV3IERhdGUoMCkgaW4gR01UXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdUaHVyc2RheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW51YXJ5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxLzAxLzcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ELCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwLTAxLTAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5GLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRIb3VycygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDczOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhNYXRoLmZsb29yKHRpbWVzdGFtcCAlIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1pbnV0ZXMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBsb2NhbGUuYW0gOiBsb2NhbGUucG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuUiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0U2Vjb25kcygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwOjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ULCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIod2Vla051bWJlcihkYXRlLCAnc3VuZGF5JyksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKHdlZWtOdW1iZXIoZGF0ZSwgJ21vbmRheScpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE2OjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5YLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdHTVQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUgJiYgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBcIkdNVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4bWUgb3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR6U3RyaW5nID0gZGF0ZS50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gdHpTdHJpbmcgJiYgdHpTdHJpbmdbMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnVGh1J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnREYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnRNb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuYywgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldERhdGUoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0RGF0ZSgpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydE1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IE1hdGguY2VpbCgoZGF0ZS5nZXRUaW1lKCkgLSB5LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldEhvdXJzKCksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1vbnRoKCkgKyAxLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSArIG9yZGluYWwoZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnQU0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IGxvY2FsZS5BTSA6IGxvY2FsZS5QTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyOjAwOjAwIEFNJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuciwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXkgPT09IDAgPyA3IDogZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxIC0gNywgTW9uZGF5IGlzIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDEtSmFuLTE5NzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy52LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gMCAtIDYsIFN1bmRheSBpcyBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyLzMxLzY5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMueCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAoJycgKyBkYXRlLmdldEZ1bGxZZWFyKCkpLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnKzAwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlICYmIF9jdXN0b21UaW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZXh0ZW5kZWRUWiA/IFwiKzAwOjAwXCIgOiBcIiswMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1c3RvbVRpbWV6b25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBfY3VzdG9tVGltZXpvbmVPZmZzZXQgLyAoNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBvZmYgPCAwID8gJy0nIDogJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gZXh0ZW5kZWRUWiA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZiAvIDYwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5zID0gTWF0aC5hYnMob2ZmICUgNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gc2lnbiArIHBhZFRpbGwyKGhvdXJzKSArIHNlcCArIHBhZFRpbGwyKG1pbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAzNykge1xuICAgICAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gX3N0cmZ0aW1lO1xuXG4gICAgICAgIHN0cmZ0aW1lLmxvY2FsaXplID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKGxvY2FsZSB8fCBfbG9jYWxlLCBfY3VzdG9tVGltZXpvbmVPZmZzZXQsIF91c2VVdGNCYXNlZERhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmZ0aW1lLnRpbWV6b25lID0gZnVuY3Rpb24odGltZXpvbmUpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21UaW1lem9uZU9mZnNldCA9IF9jdXN0b21UaW1lem9uZU9mZnNldDtcbiAgICAgICAgICAgIHZhciB1c2VVdGNCYXNlZERhdGUgPSBfdXNlVXRjQmFzZWREYXRlO1xuXG4gICAgICAgICAgICB2YXIgdGltZXpvbmVUeXBlID0gdHlwZW9mIHRpbWV6b25lO1xuICAgICAgICAgICAgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicgfHwgdGltZXpvbmVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVzZVV0Y0Jhc2VkRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBJU08gODYwMSBmb3JtYXQgdGltZXpvbmUgc3RyaW5nLCBbLStdSEhNTVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGltZXpvbmVbMF0gPT09ICctJyA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gcGFyc2VJbnQodGltZXpvbmUuc2xpY2UoMSwgMyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lem9uZS5zbGljZSgzLCA1KSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gc2lnbiAqICgoNjAgKiBob3VycykgKyBtaW51dGVzKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWludXRlczogNDIwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUoX2xvY2FsZSwgY3VzdG9tVGltZXpvbmVPZmZzZXQsIHVzZVV0Y0Jhc2VkRGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZnRpbWUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKF9sb2NhbGUsIF9jdXN0b21UaW1lem9uZU9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRpbGwyKG51bWJlclRvUGFkLCBwYWRkaW5nQ2hhcikge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXIgPT09ICcnIHx8IG51bWJlclRvUGFkID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nQ2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWRkaW5nQ2hhciA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0NoYXIgKyBudW1iZXJUb1BhZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRUaWxsMyhudW1iZXJUb1BhZCkge1xuICAgICAgICBpZiAobnVtYmVyVG9QYWQgPiA5OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJUb1BhZCA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCcgKyBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzAwJyArIG51bWJlclRvUGFkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvdXJzMTIoaG91cikge1xuICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgLSAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdFdlZWtkYXk6ICdzdW5kYXknIG9yICdtb25kYXknLCBkZWZhdWx0IGlzICdzdW5kYXknXG4gICAgLy9cbiAgICAvLyBQaWxmZXJlZCAmIHBvcnRlZCBmcm9tIFJ1YnkncyBzdHJmdGltZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmdW5jdGlvbiB3ZWVrTnVtYmVyKGRhdGUsIGZpcnN0V2Vla2RheSkge1xuICAgICAgICBmaXJzdFdlZWtkYXkgPSBmaXJzdFdlZWtkYXkgfHwgJ3N1bmRheSc7XG5cbiAgICAgICAgLy8gVGhpcyB3b3JrcyBieSBzaGlmdGluZyB0aGUgd2Vla2RheSBiYWNrIGJ5IG9uZSBkYXkgaWYgd2VcbiAgICAgICAgLy8gYXJlIHRyZWF0aW5nIE1vbmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICB2YXIgd2Vla2RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChmaXJzdFdlZWtkYXkgPT09ICdtb25kYXknKSB7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA9PT0gMCkgLy8gU3VuZGF5XG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IDY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2Vla2RheS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZZZWFyVXRjID0gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICAgIGRhdGVVdGMgPSBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLFxuICAgICAgICAgICAgeWRheSA9IE1hdGguZmxvb3IoKGRhdGVVdGMgLSBmaXJzdERheU9mWWVhclV0YykgLyA4NjQwMDAwMCksXG4gICAgICAgICAgICB3ZWVrTnVtID0gKHlkYXkgKyA3IC0gd2Vla2RheSkgLyA3O1xuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHdlZWtOdW0pO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgb3JkaW5hbCBzdWZmaXggZm9yIGEgbnVtYmVyOiBzdCwgbmQsIHJkLCBvciB0aFxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHZhciBpID0gbnVtYmVyICUgMTA7XG4gICAgICAgIHZhciBpaSA9IG51bWJlciAlIDEwMDtcblxuICAgICAgICBpZiAoKGlpID49IDExICYmIGlpIDw9IDEzKSB8fCBpID09PSAwIHx8IGkgPj0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiAnc3QnO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gJ25kJztcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuICdyZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihkYXRlKSB7XG4gICAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIHx8IDApICogNjAwMDA7XG4gICAgfVxuXG59KCkpO1xuIiwiLy8gUHJvdmlkZXM6IHBsb25rX3dhc21cbnZhciBwbG9ua193YXNtID0gam9vX2dsb2JhbF9vYmplY3QucGxvbmtfd2FzbTtcbiIsIi8qIGdsb2JhbCBqb29fZ2xvYmFsX29iamVjdCwgcGxvbmtfd2FzbSwgY2FtbF9qc190b19ib29sLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuICAgIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9tbF9ieXRlc19sZW5ndGhcbiovXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbi8vIFJlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ieXRlc191bnNhZmVfc2V0XG52YXIgY2FtbF9ieXRlc19vZl91aW50OGFycmF5ID0gZnVuY3Rpb24odWludDhhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSB1aW50OGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgb2NhbWxfYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjb252ZXJ0IGhlcmU6IE9DYW1sIENoYXIudCBpcyBqdXN0IGFuIGludCB1bmRlciB0aGUgaG9vZC5cbiAgICAgICAgY2FtbF9ieXRlc191bnNhZmVfc2V0KG9jYW1sX2J5dGVzLCBpLCB1aW50OGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9jYW1sX2J5dGVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheVxuLy8gUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbnZhciBjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXkgPSBmdW5jdGlvbihvY2FtbF9ieXRlcykge1xuICAgIHZhciBsZW5ndGggPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvY2FtbF9ieXRlcyk7XG4gICAgdmFyIGJ5dGVzID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY29udmVydCBoZXJlOiBPQ2FtbCBDaGFyLnQgaXMganVzdCBhbiBpbnQgdW5kZXIgdGhlIGhvb2QuXG4gICAgICAgIGJ5dGVzW2ldID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KG9jYW1sX2J5dGVzLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9vZl9udW1lcmFsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX2JpZ2ludF8yNTZfb2ZfbnVtZXJhbCA9IGZ1bmN0aW9uIChzLCBsZW4sIGJhc2UpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfb2ZfbnVtZXJhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSwgbGVuLCBiYXNlKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfb2ZfZGVjaW1hbF9zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfYmlnaW50XzI1Nl9vZl9kZWNpbWFsX3N0cmluZyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X29mX2RlY2ltYWxfc3RyaW5nKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfbnVtX2xpbWJzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfYmlnaW50XzI1Nl9udW1fbGltYnMgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9udW1fbGltYnNcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9ieXRlc19wZXJfbGltYlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfYnl0ZXNfcGVyX2xpbWIgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9ieXRlc19wZXJfbGltYlxuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X2RpdlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfZGl2ID0gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfZGl2XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfY29tcGFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfY29tcGFyZSA9IHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X2NvbXBhcmVcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9wcmludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfcHJpbnQgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9wcmludFxuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfdG9fc3RyaW5nKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfdGVzdF9iaXRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzX3RvX2Jvb2xcbnZhciBjYW1sX2JpZ2ludF8yNTZfdGVzdF9iaXQgPSBmdW5jdGlvbih4LCBpKSB7XG4gICAgcmV0dXJuIGNhbWxfanNfdG9fYm9vbChwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl90ZXN0X2JpdCh4LCBpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X3RvX2J5dGVzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG52YXIgY2FtbF9iaWdpbnRfMjU2X3RvX2J5dGVzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXkocGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfdG9fYnl0ZXMoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9vZl9ieXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheVxudmFyIGNhbWxfYmlnaW50XzI1Nl9vZl9ieXRlcyA9IGZ1bmN0aW9uKG9jYW1sX2J5dGVzKSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X29mX2J5dGVzKGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheShvY2FtbF9ieXRlcykpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9iaWdpbnRfMjU2X2RlZXBfY29weSA9IHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X2RlZXBfY29weVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2NvcHlcbnZhciBjYW1sX3Bhc3RhX2ZwX2NvcHkgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB4W2ldID0geVtpXTtcbiAgICB9XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIE5vbmVcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIHhdOyAvLyBTb21lKHgpXG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gMCkgeyAvLyBOb25lXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHhbMV07XG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc2l6ZV9pbl9iaXRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfc2l6ZV9pbl9iaXRzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0c1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfc2l6ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zaXplXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2FkZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2FkZCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9hZGRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc3ViXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfc3ViID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3N1YlxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9uZWdhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9uZWdhdGUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfbmVnYXRlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX211bFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX211bCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9tdWxcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfZGl2XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfZGl2ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX2RpdlxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9pbnZcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWRcbnZhciBjYW1sX3Bhc3RhX2ZwX2ludiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9pbnYoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc3F1YXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfc3F1YXJlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3NxdWFyZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9pc19zcXVhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzX3RvX2Jvb2xcbnZhciBjYW1sX3Bhc3RhX2ZwX2lzX3NxdWFyZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9qc190b19ib29sKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9pc19zcXVhcmUoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc3FydFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcGFzdGFfZnBfc3FydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zcXJ0KHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX29mX2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX29mX2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9vZl9pbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfdG9fc3RyaW5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZwX3RvX3N0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3RvX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9vZl9zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnBfb2Zfc3RyaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX29mX3N0cmluZyhjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wcmludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3ByaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3ByaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX211dF9hZGRcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZwX2NvcHksIGNhbWxfcGFzdGFfZnBfYWRkXG52YXIgY2FtbF9wYXN0YV9mcF9tdXRfYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGNhbWxfcGFzdGFfZnBfY29weSh4LCBjYW1sX3Bhc3RhX2ZwX2FkZCh4LCB5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9tdXRfc3ViXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcF9jb3B5LCBjYW1sX3Bhc3RhX2ZwX3N1YlxudmFyIGNhbWxfcGFzdGFfZnBfbXV0X3N1YiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBjYW1sX3Bhc3RhX2ZwX2NvcHkoeCwgY2FtbF9wYXN0YV9mcF9zdWIoeCwgeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfbXV0X211bFxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnBfY29weSwgY2FtbF9wYXN0YV9mcF9tdWxcbnZhciBjYW1sX3Bhc3RhX2ZwX211dF9tdWwgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgY2FtbF9wYXN0YV9mcF9jb3B5KHgsIGNhbWxfcGFzdGFfZnBfbXVsKHgsIHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX211dF9zcXVhcmVcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZwX2NvcHksIGNhbWxfcGFzdGFfZnBfc3F1YXJlXG52YXIgY2FtbF9wYXN0YV9mcF9tdXRfc3F1YXJlID0gZnVuY3Rpb24oeCkge1xuICAgIGNhbWxfcGFzdGFfZnBfY29weSh4LCBjYW1sX3Bhc3RhX2ZwX3NxdWFyZSh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb21wYXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfY29tcGFyZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9jb21wYXJlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2VxdWFsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfZXF1YWwgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfZXF1YWxcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcmFuZG9tXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcmFuZG9tID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3JhbmRvbVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9ybmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9ybmcgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcm5nXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3RvX2JpZ2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3RvX2JpZ2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF90b19iaWdpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb2ZfYmlnaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfb2ZfYmlnaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX29mX2JpZ2ludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF90d29fYWRpY19yb290X29mX3VuaXR5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfdHdvX2FkaWNfcm9vdF9vZl91bml0eSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF90d29fYWRpY19yb290X29mX3VuaXR5XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2RvbWFpbl9nZW5lcmF0b3Jcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9kb21haW5fZ2VuZXJhdG9yID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX2RvbWFpbl9nZW5lcmF0b3JcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfdG9fYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfdG9fYnl0ZXMoeCk7XG4gICAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheShwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfdG9fYnl0ZXMoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb2ZfYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZwX29mX2J5dGVzID0gZnVuY3Rpb24ob2NhbWxfYnl0ZXMpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX29mX2J5dGVzKGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheShvY2FtbF9ieXRlcykpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfZGVlcF9jb3B5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX2RlZXBfY29weVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2NvcHlcbnZhciBjYW1sX3Bhc3RhX2ZxX2NvcHkgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB4W2ldID0geVtpXTtcbiAgICB9XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zaXplX2luX2JpdHNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zaXplX2luX2JpdHMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfc2l6ZV9pbl9iaXRzXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3NpemVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NpemVcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfYWRkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfYWRkID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2FkZFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zdWJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zdWIgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfc3ViXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX25lZ2F0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX25lZ2F0ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9uZWdhdGVcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfbXVsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfbXVsID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX211bFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9kaXZcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9kaXYgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfZGl2XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2ludlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcGFzdGFfZnFfaW52ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2ludih4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zcXVhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9zcXVhcmUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfc3F1YXJlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2lzX3NxdWFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNfdG9fYm9vbFxudmFyIGNhbWxfcGFzdGFfZnFfaXNfc3F1YXJlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX2pzX3RvX2Jvb2wocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2lzX3NxdWFyZSh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zcXJ0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9wYXN0YV9mcV9zcXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NxcnQoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfb2ZfaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfb2ZfaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX2ludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV90b19zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnFfdG9fc3RyaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfdG9fc3RyaW5nKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX29mX3N0cmluZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcV9vZl9zdHJpbmcgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfb2Zfc3RyaW5nKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3ByaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcHJpbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcHJpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfbXV0X2FkZFxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnFfY29weSwgY2FtbF9wYXN0YV9mcV9hZGRcbnZhciBjYW1sX3Bhc3RhX2ZxX211dF9hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgY2FtbF9wYXN0YV9mcV9jb3B5KHgsIGNhbWxfcGFzdGFfZnFfYWRkKHgsIHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX211dF9zdWJcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZxX2NvcHksIGNhbWxfcGFzdGFfZnFfc3ViXG52YXIgY2FtbF9wYXN0YV9mcV9tdXRfc3ViID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGNhbWxfcGFzdGFfZnFfY29weSh4LCBjYW1sX3Bhc3RhX2ZxX3N1Yih4LCB5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9tdXRfbXVsXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcV9jb3B5LCBjYW1sX3Bhc3RhX2ZxX211bFxudmFyIGNhbWxfcGFzdGFfZnFfbXV0X211bCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBjYW1sX3Bhc3RhX2ZxX2NvcHkoeCwgY2FtbF9wYXN0YV9mcV9tdWwoeCwgeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfbXV0X3NxdWFyZVxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnFfY29weSwgY2FtbF9wYXN0YV9mcV9zcXVhcmVcbnZhciBjYW1sX3Bhc3RhX2ZxX211dF9zcXVhcmUgPSBmdW5jdGlvbih4KSB7XG4gICAgY2FtbF9wYXN0YV9mcV9jb3B5KHgsIGNhbWxfcGFzdGFfZnFfc3F1YXJlKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2NvbXBhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9jb21wYXJlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2NvbXBhcmVcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfZXF1YWxcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9lcXVhbCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9lcXVhbFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9yYW5kb21cbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9yYW5kb20gPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcmFuZG9tXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3JuZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3JuZyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9ybmdcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfdG9fYmlnaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfdG9fYmlnaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3RvX2JpZ2ludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vZl9iaWdpbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9vZl9iaWdpbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfb2ZfYmlnaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV90d29fYWRpY19yb290X29mX3VuaXR5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHlcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfZG9tYWluX2dlbmVyYXRvclxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX2RvbWFpbl9nZW5lcmF0b3IgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfZG9tYWluX2dlbmVyYXRvclxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV90b19ieXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheVxudmFyIGNhbWxfcGFzdGFfZnFfdG9fYnl0ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV90b19ieXRlcyh4KTtcbiAgICByZXR1cm4gY2FtbF9ieXRlc19vZl91aW50OGFycmF5KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV90b19ieXRlcyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vZl9ieXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheVxudmFyIGNhbWxfcGFzdGFfZnFfb2ZfYnl0ZXMgPSBmdW5jdGlvbihvY2FtbF9ieXRlcykge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfb2ZfYnl0ZXMoY2FtbF9ieXRlc190b191aW50OGFycmF5KG9jYW1sX2J5dGVzKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9kZWVwX2NvcHkgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfZGVlcF9jb3B5XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGkgPSAxOyAvLyBUaGUgZmlyc3QgZW50cnkgaXMgdGhlIE9DYW1sIHRhZyBmb3IgYXJyYXlzXG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoIC0gaTtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIGlubmVyX2xlbiA9IHZbaV0ubGVuZ3RoO1xuICAgIHZhciByZXMgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShsZW4gKiBpbm5lcl9sZW4pO1xuICAgIGZvciAodmFyIHBvcyA9IDA7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbm5lcl9sZW47IGorKywgcG9zKyspIHtcbiAgICAgICAgICAgIHJlc1twb3NdID0gdltpXVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvciA9IGZ1bmN0aW9uICh2LCBpbm5lcl9sZW4pIHtcbiAgICB2YXIgbGVuID0gdi5sZW5ndGg7XG4gICAgdmFyIG91dHB1dF9sZW4gPSBsZW4gLyBpbm5lcl9sZW47XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheShvdXRwdXRfbGVuICsgMSlcbiAgICByZXNbMF0gPSAwIC8vIE9DYW1sIHRhZyBiZWZvcmUgYXJyYXkgY29udGVudHMsIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGlzIHdpdGggYXJyYXlzIG9yIHZlY3RvcnNcbiAgICBmb3IgKHZhciBpID0gMSwgcG9zID0gMDsgaSA8PSBvdXRwdXRfbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGlubmVyX3JlcyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGlubmVyX2xlbik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5uZXJfbGVuOyBqKyssIHBvcysrKSB7XG4gICAgICAgICAgICBpbm5lcl9yZXNbal0gPSB2W3Bvc107XG4gICAgICAgIH1cbiAgICAgICAgcmVzW2ldID0gaW5uZXJfcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczoganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yXG52YXIganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgbGVuID0gdi5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gQmV3YXJlOiBjYWxsZXIgbWF5IG5lZWQgdG8gZG8gZmluYWxpemVyIHRoaW5ncyB0byBhdm9pZCB0aGVzZVxuICAgICAgICAvLyBwb2ludGVycyBkaXNhcHBlYXJpbmcgb3V0IGZyb20gdW5kZXIgdXMuXG4gICAgICAgIHJlc1tpXSA9IHZbaV0ucHRyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvclxudmFyIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciA9IGZ1bmN0aW9uICh2LCBrbGFzcykge1xuICAgIC8vIHJldHVybiB2Lm1hcChrbGFzcy5fX3dyYXApXG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIEJld2FyZTogdGhlIGNhbGxlciBtYXkgbmVlZCB0byBhZGQgZmluYWxpemVycyB0byB0aGVzZS5cbiAgICAgICAgcmVzW2ldID0ga2xhc3MuX193cmFwKHZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9mcF92ZWN0b3JfY3JlYXRlXG52YXIgY2FtbF9mcF92ZWN0b3JfY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFswXTsgLy8gT0NhbWwgdGFnIGZvciBhcnJheXMsIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGUgc2FtZSB1dGlsaXR5IGZucyBvbiBib3RoXG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF92ZWN0b3JfbGVuZ3RoXG52YXIgY2FtbF9mcF92ZWN0b3JfbGVuZ3RoID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi5sZW5ndGggLSAxO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX2VtcGxhY2VfYmFja1xudmFyIGNhbWxfZnBfdmVjdG9yX2VtcGxhY2VfYmFjayA9IGZ1bmN0aW9uICh2LCB4KSB7XG4gICAgdi5wdXNoKHgpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9mcF92ZWN0b3JfZ2V0XG52YXIgY2FtbF9mcF92ZWN0b3JfZ2V0ID0gZnVuY3Rpb24gKHYsIGkpIHtcbiAgICByZXR1cm4gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkodltpKzFdKTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yKHYpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfZnBfdmVjdG9yX29mX3J1c3QgPSBmdW5jdGlvbiAodikge1xuICAgIC8vIFRPRE86IEhhcmRjb2RpbmcgdGhpcyBpcyBhIGxpdHRsZSBicml0dGxlXG4gICAgcmV0dXJuIGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3Rvcih2LCAzMik7XG59XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfdmVjdG9yX2NyZWF0ZVxudmFyIGNhbWxfZnFfdmVjdG9yX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbMF07IC8vIE9DYW1sIHRhZyBmb3IgYXJyYXlzLCBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlIHNhbWUgdXRpbGl0eSBmbnMgb24gYm90aFxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfdmVjdG9yX2xlbmd0aFxudmFyIGNhbWxfZnFfdmVjdG9yX2xlbmd0aCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoIC0gMTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9lbXBsYWNlX2JhY2tcbnZhciBjYW1sX2ZxX3ZlY3Rvcl9lbXBsYWNlX2JhY2sgPSBmdW5jdGlvbiAodiwgeCkge1xuICAgIHYucHVzaCh4KTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfdmVjdG9yX2dldFxudmFyIGNhbWxfZnFfdmVjdG9yX2dldCA9IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgcmV0dXJuIG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHZbaSsxXSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3Rvcih2KTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfdmVjdG9yX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAvLyBUT0RPOiBIYXJkY29kaW5nIHRoaXMgaXMgYSBsaXR0bGUgYnJpdHRsZVxuICAgIHJldHVybiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IodiwgMzIpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeVxudmFyIGZyZWVfZmluYWxpemF0aW9uX3JlZ2lzdHJ5ID1cbiAgICBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKGluc3RhbmNlX3JlcHJlc2VudGF0aXZlKSB7XG4gICAgICAgIGluc3RhbmNlX3JlcHJlc2VudGF0aXZlLmZyZWUoKTtcbiAgICB9KTtcblxuLy8gUHJvdmlkZXM6IGZyZWVfb25fZmluYWxpemVcbi8vIFJlcXVpcmVzOiBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeVxudmFyIGZyZWVfb25fZmluYWxpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgIC8vIFRoaXMgaXMgYW4gdW5mb3J0dW5hdGUgaGFjazogd2UncmUgY3JlYXRpbmcgYSBzZWNvbmQgaW5zdGFuY2Ugb2YgdGhlXG4gICAgLy8gY2xhc3MgdG8gYmUgYWJsZSB0byBjYWxsIGZyZWUgb24gaXQuIFdlIGNhbid0IHBhc3MgdGhlIHZhbHVlIGl0c2VsZixcbiAgICAvLyBzaW5jZSB0aGUgcmVnaXN0cnkgaG9sZHMgYSBzdHJvbmcgcmVmZXJlbmNlIHRvIHRoZSByZXByZXNlbnRhdGl2ZSB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHRoZSBjbGFzcyBpcyBvbmx5IHJlYWxseSBhIHdyYXBwZXIgYXJvdW5kIGEgcG9pbnRlciwgd2l0aCBhXG4gICAgLy8gcmVmZXJlbmNlIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlIGFzIGl0cyBfX3Byb3RvdHlwZV9fLlxuICAgIC8vXG4gICAgLy8gSXQgbWlnaHQgc2VlbSBjbGVhbmVyIHRvIGNhbGwgdGhlIGRlc3RydWN0b3IgaGVyZSBvbiB0aGUgcG9pbnRlclxuICAgIC8vIGRpcmVjdGx5LCBidXQgdW5mb3J0dW5hdGVseSB0aGUgZGVzdHJ1Y3RvciBuYW1lIGlzIHNvbWUgbWFuZ2xlZCBpbnRlcm5hbFxuICAgIC8vIHN0cmluZyBnZW5lcmF0ZWQgYnkgd2FzbV9iaW5kZ2VuLiBGb3Igbm93LCB0aGlzIGlzIHRoZSBiZXN0LFxuICAgIC8vIGxlYXN0LWJyaXR0bGUgd2F5IHRvIGZyZWUgb25jZSB0aGUgb3JpZ2luYWwgY2xhc3MgaW5zdGFuY2UgZ2V0cyBjb2xsZWN0ZWQuXG4gICAgdmFyIGluc3RhbmNlX3JlcHJlc2VudGF0aXZlID0geC5jb25zdHJ1Y3Rvci5fX3dyYXAoeC5wdHIpXG4gICAgZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnkucmVnaXN0ZXIoeCwgaW5zdGFuY2VfcmVwcmVzZW50YXRpdmUsIHgpO1xuICAgIHJldHVybiB4O1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSA9IGZ1bmN0aW9uKHB0KSB7XG4gICAgdmFyIGluZmluaXR5ID0gcHQuaW5maW5pdHk7XG4gICAgaWYgKGluZmluaXR5KSB7XG4gICAgICAgIHB0LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBwdC54O1xuICAgICAgICB2YXIgeSA9IHB0Lnk7XG4gICAgICAgIHB0LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIFswLCBbMCwgeCwgeV1dO1xuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZVxudmFyIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lID0gZnVuY3Rpb24ocHQsIGtsYXNzKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBrbGFzcygpO1xuICAgIGlmIChwdCA9PT0gMCkge1xuICAgICAgICByZXMuaW5maW5pdHkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExheW91dCBpcyBbMCwgWzAsIHgsIHldXVxuICAgICAgICAvLyBGaXJzdCAwIGlzIHRoZSB0YWcgKGl0J3MgdGhlIDB0aCBjb25zdHJ1Y3RvciB0aGF0IHRha2VzIGFyZ3VtZW50cylcbiAgICAgICAgLy8gU2Vjb25kIDAgaXMgdGhlIGJsb2NrIG1hcmtlciBmb3IgdGhlIGFub255bW91cyB0dXBsZSBhcmd1bWVudHNcbiAgICAgICAgcmVzLnggPSBwdFsxXVsxXTtcbiAgICAgICAgcmVzLnkgPSBwdFsxXVsyXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX29uZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19vbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19vbmUoKTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FkZCh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19zdWJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfc3ViID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3N1Yih4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19uZWdhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfbmVnYXRlID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX25lZ2F0ZSh4KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19kb3VibGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfZG91YmxlID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2RvdWJsZSh4KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19zY2FsZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19zY2FsZSh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19yYW5kb21cbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfcmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfcmFuZG9tKCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfcm5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX3JuZyA9IGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19ybmcoaSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfdG9fYWZmaW5lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX3BhbGxhc190b19hZmZpbmUgPSBmdW5jdGlvbihwdCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3RvX2FmZmluZShwdCk7XG4gICAgcmV0dXJuIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfb2ZfYWZmaW5lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19vZl9hZmZpbmUgPSBmdW5jdGlvbihwdCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX29mX2FmZmluZShydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZShwdCwgcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZmZpbmVfb25lKSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfb2ZfYWZmaW5lX2Nvb3JkaW5hdGVzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX29mX2FmZmluZV9jb29yZGluYXRlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19vZl9hZmZpbmVfY29vcmRpbmF0ZXMoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfZW5kb19iYXNlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFsbGFzX2VuZG9fYmFzZSA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfZW5kb19iYXNlO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfZW5kb19zY2FsYXJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYWxsYXNfZW5kb19zY2FsYXIgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2VuZG9fc2NhbGFyO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfYWZmaW5lX2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFsbGFzX2FmZmluZV9kZWVwX2NvcHkgPSBmdW5jdGlvbihwdCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9kZWVwX2NvcHkocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSkpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfb25lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9vbmUoKTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX2FkZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX2FkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FkZCh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3N1YlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX3N1YiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3N1Yih4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX25lZ2F0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX25lZ2F0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX25lZ2F0ZSh4KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX2RvdWJsZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX2RvdWJsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2RvdWJsZSh4KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3NjYWxlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfc2NhbGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9zY2FsZSh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3JhbmRvbVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX3JhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfcmFuZG9tKCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9ybmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9ybmcgPSBmdW5jdGlvbihpKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9ybmcoaSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV90b19hZmZpbmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfdmVzdGFfdG9fYWZmaW5lID0gZnVuY3Rpb24ocHQpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3RvX2FmZmluZShwdCk7XG4gICAgcmV0dXJuIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9vZl9hZmZpbmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfb2ZfYWZmaW5lID0gZnVuY3Rpb24ocHQpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX29mX2FmZmluZShydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZShwdCwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpKTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX29mX2FmZmluZV9jb29yZGluYXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX29mX2FmZmluZV9jb29yZGluYXRlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX29mX2FmZmluZV9jb29yZGluYXRlcyh4LCB5KTtcbiAgICBmcmVlX29uX2ZpbmFsaXplKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX2VuZG9fYmFzZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Zlc3RhX2VuZG9fYmFzZSA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9lbmRvX2Jhc2U7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX2VuZG9fc2NhbGFyXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfdmVzdGFfZW5kb19zY2FsYXIgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfZW5kb19zY2FsYXI7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX2FmZmluZV9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX3Zlc3RhX2FmZmluZV9kZWVwX2NvcHkgPSBmdW5jdGlvbihwdCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX2RlZXBfY29weShydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZShwdCwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpKSk7XG59O1xuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvclxuLy8gUmVxdWlyZXM6IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvclxudmFyIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IgPSBmdW5jdGlvbih2LCBrbGFzcywgY29udmVydCwgc2hvdWxkX2ZyZWUpIHtcbiAgICB2ID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKHYsIGtsYXNzKTtcbiAgICB2YXIgbGVuID0gdi5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgcmVzWzBdID0gMDsgLy8gT0NhbWwgdGFnIGJlZm9yZSBhcnJheSBjb250ZW50c1xuICAgIGZvciAodmFyIGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBydXN0X3ZhbCA9IHZbaV07XG4gICAgICAgIHJlc1tpKzFdID0gY29udmVydChydXN0X3ZhbCk7XG4gICAgICAgIGlmIChzaG91bGRfZnJlZSkgeyBydXN0X3ZhbC5mcmVlKCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yXG4vLyBSZXF1aXJlczoganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yLCBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeVxudmFyIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IgPSBmdW5jdGlvbih2LCBjb252ZXJ0LCBta19uZXcpIHtcbiAgICB2ID0gdi5zbGljZSgxKTsgLy8gQ29weSwgZHJvcHBpbmcgT0NhbWwgdGFnXG4gICAgZm9yICh2YXIgaT0wLCBsPXYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjbGFzc192YWwgPSBjb252ZXJ0KHZbaV0sIG1rX25ldyk7XG4gICAgICAgIHZbaV0gPSBjbGFzc192YWw7XG4gICAgICAgIC8vIERvbid0IGZyZWUgd2hlbiBHQyBydW5zOyBydXN0IHdpbGwgZnJlZSBvbiBpdHMgZW5kLlxuICAgICAgICBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeS51bnJlZ2lzdGVyKGNsYXNzX3ZhbCk7XG4gICAgfVxuICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3Iodik7XG59XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tXG4vLyBSZXF1aXJlczogcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3JcbnZhciBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbSA9IGZ1bmN0aW9uKHBvbHlfY29tbSwga2xhc3MsIHNob3VsZF9mcmVlKSB7XG4gICAgdmFyIHJ1c3Rfc2hpZnRlZCA9IHBvbHlfY29tbS5zaGlmdGVkO1xuICAgIHZhciBydXN0X3Vuc2hpZnRlZCA9IHBvbHlfY29tbS51bnNoaWZ0ZWQ7XG4gICAgdmFyIGNhbWxfc2hpZnRlZDtcbiAgICBpZiAocnVzdF9zaGlmdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FtbF9zaGlmdGVkID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW1sX3NoaWZ0ZWQgPSBbMCwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUocnVzdF9zaGlmdGVkKV07XG4gICAgfVxuICAgIHZhciBjYW1sX3Vuc2hpZnRlZCA9IGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IocnVzdF91bnNoaWZ0ZWQsIGtsYXNzLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSwgc2hvdWxkX2ZyZWUpO1xuICAgIHJldHVybiBbMCwgY2FtbF91bnNoaWZ0ZWQsIGNhbWxfc2hpZnRlZF07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW1cbi8vIFJlcXVpcmVzOiBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tID0gZnVuY3Rpb24ocG9seV9jb21tLCBwb2x5X2NvbW1fY2xhc3MsIG1rX2FmZmluZSkge1xuICAgIHZhciBjYW1sX3Vuc2hpZnRlZCA9IHBvbHlfY29tbVsxXTtcbiAgICB2YXIgY2FtbF9zaGlmdGVkID0gcG9seV9jb21tWzJdO1xuICAgIHZhciBydXN0X3NoaWZ0ZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNhbWxfc2hpZnRlZCAhPT0gMCkge1xuICAgICAgICBydXN0X3NoaWZ0ZWQgPSBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZShjYW1sX3NoaWZ0ZWRbMV0sIG1rX2FmZmluZSk7XG4gICAgfVxuICAgIHZhciBydXN0X3Vuc2hpZnRlZCA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoY2FtbF91bnNoaWZ0ZWQsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBta19hZmZpbmUpO1xuICAgIHJldHVybiBuZXcgcG9seV9jb21tX2NsYXNzKHJ1c3RfdW5zaGlmdGVkLCBydXN0X3NoaWZ0ZWQpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tXG52YXIgY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW0oeCwgcGxvbmtfd2FzbS5XYXNtR1Zlc3RhLCBmYWxzZSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW1cbnZhciBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbSh4LCBwbG9ua193YXNtLldhc21GcFBvbHlDb21tLCBwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX29uZSk7XG59XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW1cbnZhciBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW0oeCwgcGxvbmtfd2FzbS5XYXNtR1BhbGxhcywgZmFsc2UpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbVxudmFyIGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbSh4LCBwbG9ua193YXNtLldhc21GcVBvbHlDb21tLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9mcF9zcnNfY3JlYXRlID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBmcmVlX29uX2ZpbmFsaXplKHBsb25rX3dhc20uY2FtbF9mcF9zcnNfY3JlYXRlKGkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc193cml0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9mcF9zcnNfd3JpdGUgPSBmdW5jdGlvbihhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfZnBfc3JzX3dyaXRlKGFwcGVuZCwgdCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfZnBfc3JzX3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwYXRoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WzFdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc19yZWFkKG9mZnNldCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIFswLCByZXNdOyAvLyBTb21lKHJlcylcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDsgLy8gTm9uZVxuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19sYWdyYW5nZV9jb21taXRtZW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdFxudmFyIGNhbWxfZnBfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnQgPSBmdW5jdGlvbiAodCwgZG9tYWluX3NpemUsIGkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc19sYWdyYW5nZV9jb21taXRtZW50KHQsIGRvbWFpbl9zaXplLCBpKTtcbiAgICByZXR1cm4gY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdChyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX2NvbW1pdF9ldmFsdWF0aW9uc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QsIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3RcbnZhciBjYW1sX2ZwX3Nyc19jb21taXRfZXZhbHVhdGlvbnMgPSBmdW5jdGlvbiAodCwgZG9tYWluX3NpemUsIGZwcykge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnBfc3JzX2NvbW1pdF9ldmFsdWF0aW9ucyh0LCBkb21haW5fc2l6ZSwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChmcHMpKTtcbiAgICByZXR1cm4gY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdChyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX2JfcG9seV9jb21taXRtZW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCwgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcF9zcnNfYl9wb2x5X2NvbW1pdG1lbnQgPSBmdW5jdGlvbiAoc3JzLCBjaGFscykge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnBfc3JzX2JfcG9seV9jb21taXRtZW50KHNycywgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yKGNoYWxzKSk7XG4gICAgcmV0dXJuIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVja1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0XG52YXIgY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2sgPSBmdW5jdGlvbiAoc3JzLCBjb21tcywgY2hhbHMpIHtcbiAgICB2YXIgcnVzdF9jb21tcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoY29tbXMsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX29uZSk7XG4gICAgdmFyIHJ1c3RfY2hhbHMgPSBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KGNoYWxzKTtcbiAgICB2YXIgb2sgPSBwbG9ua193YXNtLmNhbWxfZnBfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrKHNycywgcnVzdF9jb21tcywgcnVzdF9jaGFscyk7XG4gICAgcmV0dXJuIG9rO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfc3JzX2hcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfZnBfc3JzX2ggPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfZnBfc3JzX2godCkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9mcV9zcnNfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfZnFfc3JzX2NyZWF0ZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfZnFfc3JzX2NyZWF0ZShpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV9zcnNfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfZnFfc3JzX3dyaXRlID0gZnVuY3Rpb24oYXBwZW5kLCB0LCBwYXRoKSB7XG4gICAgaWYgKGFwcGVuZCA9PT0gMCkge1xuICAgICAgICBhcHBlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc193cml0ZShhcHBlbmQsIHQsICBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV9zcnNfcmVhZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9mcV9zcnNfcmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnFfc3JzX3JlYWQob2Zmc2V0LCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG4gICAgaWYgKHJlcykge1xuICAgICAgICByZXR1cm4gWzAsIHJlc107IC8vIFNvbWUocmVzKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwOyAvLyBOb25lXG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdFxudmFyIGNhbWxfZnFfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnQgPSBmdW5jdGlvbiAodCwgZG9tYWluX3NpemUsIGkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19sYWdyYW5nZV9jb21taXRtZW50KHQsIGRvbWFpbl9zaXplLCBpKTtcbiAgICByZXR1cm4gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19jb21taXRfZXZhbHVhdGlvbnNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdCwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdFxudmFyIGNhbWxfZnFfc3JzX2NvbW1pdF9ldmFsdWF0aW9ucyA9IGZ1bmN0aW9uICh0LCBkb21haW5fc2l6ZSwgZnFzKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcV9zcnNfY29tbWl0X2V2YWx1YXRpb25zKHQsIGRvbWFpbl9zaXplLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KGZxcykpO1xuICAgIHJldHVybiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdChyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2JfcG9seV9jb21taXRtZW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QsIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfZnFfc3JzX2JfcG9seV9jb21taXRtZW50ID0gZnVuY3Rpb24gKHNycywgY2hhbHMpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudChzcnMsIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvcihjaGFscykpO1xuICAgIHJldHVybiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdChyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3RcbnZhciBjYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayA9IGZ1bmN0aW9uIChzcnMsIGNvbW1zLCBjaGFscykge1xuICAgIHZhciBydXN0X2NvbW1zID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3Rvcihjb21tcywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIHJ1c3RfY2hhbHMgPSBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KGNoYWxzKTtcbiAgICB2YXIgb2sgPSBwbG9ua193YXNtLmNhbWxfZnFfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrKHNycywgcnVzdF9jb21tcywgcnVzdF9jaGFscyk7XG4gICAgcmV0dXJuIG9rO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2hcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfZnFfc3JzX2ggPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShwbG9ua193YXNtLmNhbWxfZnFfc3JzX2godCkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua193aXJlX29mX3J1c3RcbnZhciBjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdCA9IGZ1bmN0aW9uKHdpcmUpIHtcbiAgICB2YXIgcmVzID0gWzAsIHdpcmUucm93LCB3aXJlLmNvbF07XG4gICAgd2lyZS5mcmVlKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCA9IGZ1bmN0aW9uKHdpcmUpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5XaXJlLmNyZWF0ZSh3aXJlWzFdLCB3aXJlWzJdKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3Bsb25rX3dpcmVfb2ZfcnVzdFxudmFyIGNhbWxfcGxvbmtfd2lyZXNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHdpcmVzKSB7XG4gICAgdmFyIHJlcyA9IFswLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbMF0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbMV0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbMl0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbM10pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbNF0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbNV0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX29mX3J1c3Qod2lyZXNbNl0pXTtcbiAgICB3aXJlcy5mcmVlKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdFxudmFyIGNhbWxfcGxvbmtfd2lyZXNfdG9fcnVzdCA9IGZ1bmN0aW9uKHdpcmVzKSB7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21HYXRlV2lyZXMoXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1sxXSksXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1syXSksXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1szXSksXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1s0XSksXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1s1XSksXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1s2XSksXG4gICAgICBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh3aXJlc1s3XSlcbiAgICApO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF9wbG9ua193aXJlc19vZl9ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdCA9IGZ1bmN0aW9uKGdhdGUpIHtcbiAgICAvLyBUT0RPOiBIYXJkY29kaW5nIDMyIGhlcmUgaXMgYSBsaXR0bGUgYnJpdHRsZVxuICAgIHZhciByZXMgPSBbMCwgZ2F0ZS50eXAsIGNhbWxfcGxvbmtfd2lyZXNfb2ZfcnVzdChnYXRlLndpcmVzKSwgY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yKGdhdGUuYywgMzIpXTtcbiAgICBnYXRlLmZyZWUoKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfcGxvbmtfZ2F0ZV90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua193aXJlc190b19ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdCA9IGZ1bmN0aW9uKGdhdGUpIHtcbiAgICByZXR1cm4gbmV3IHBsb25rX3dhc20uV2FzbUZwR2F0ZShcbiAgICAgIGdhdGVbMV0sXG4gICAgICBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QoZ2F0ZVsyXSksXG4gICAgICBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoZ2F0ZVszXSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfcGxvbmtfZ2F0ZV90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua193aXJlc190b19ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZxX3Bsb25rX2dhdGVfdG9fcnVzdCA9IGZ1bmN0aW9uKGdhdGUpIHtcbiAgICAvLyBUT0RPOiBIYXJkY29kaW5nIDMyIGhlcmUgaXMgYSBsaXR0bGUgYnJpdHRsZVxuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnFHYXRlKFxuICAgICAgZ2F0ZVsxXSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZXNfdG9fcnVzdChnYXRlWzJdKSxcbiAgICAgIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvcihnYXRlWzNdKSlcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyZWVfb25fZmluYWxpemUocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZSgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2FkZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnBfcGxvbmtfZ2F0ZV90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9hZGQgPSBmdW5jdGlvbih2LCB4KSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9hZGQodiwgY2FtbF9mcF9wbG9ua19nYXRlX3RvX3J1c3QoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua19nYXRlX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2dldCA9IGZ1bmN0aW9uKHYsIGkpIHtcbiAgICByZXR1cm4gY2FtbF9wbG9ua19nYXRlX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2dldCh2LCBpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua193aXJlX3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX3dyYXAgPSBmdW5jdGlvbih2LCB4LCB5KSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwKHYsIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0KHgpLCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdCA9IGZ1bmN0aW9uKGdhdGVfdmVjdG9yKSB7XG4gICAgdmFyIHVpbnQ4YXJyYXkgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0KGdhdGVfdmVjdG9yKTtcbiAgICByZXR1cm4gY2FtbF9ieXRlc19vZl91aW50OGFycmF5KHVpbnQ4YXJyYXkpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcmVlX29uX2ZpbmFsaXplKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZxX3Bsb25rX2dhdGVfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkID0gZnVuY3Rpb24odiwgeCkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkKHYsIGNhbWxfZnFfcGxvbmtfZ2F0ZV90b19ydXN0KHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2dldFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9nZXQgPSBmdW5jdGlvbih2LCBpKSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9nZXQodiwgaSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwID0gZnVuY3Rpb24odiwgeCwgeSkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCh2LCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh4KSwgY2FtbF9wbG9ua193aXJlX3RvX3J1c3QoeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3QgPSBmdW5jdGlvbihnYXRlX3ZlY3Rvcikge1xuICAgIHZhciB1aW50OGFycmF5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdChnYXRlX3ZlY3Rvcik7XG4gICAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheSh1aW50OGFycmF5KTtcbn1cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfY3JlYXRlID0gZnVuY3Rpb24oZ2F0ZXMsIHB1YmxpY19pbnB1dHMsIHVycykge1xuICAgIHZhciB0ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2NyZWF0ZShnYXRlcywgcHVibGljX2lucHV0cywgdXJzKTtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZSh0KTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X21heF9kZWdyZWVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9tYXhfZGVncmVlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X21heF9kZWdyZWU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHM7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q0X3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q0X3NpemU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemU7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfcmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHVycywgcGF0aCkge1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9yZWFkKG9mZnNldCwgdXJzLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF93cml0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF93cml0ZSA9IGZ1bmN0aW9uKGFwcGVuZCwgdCwgcGF0aCkge1xuICAgIGlmIChhcHBlbmQgPT09IDApIHtcbiAgICAgICAgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF93cml0ZShhcHBlbmQsIHQsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfY3JlYXRlID0gZnVuY3Rpb24oZ2F0ZXMsIHB1YmxpY19pbnB1dHMsIHVycykge1xuICAgIHJldHVybiBmcmVlX29uX2ZpbmFsaXplKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9jcmVhdGUoZ2F0ZXMsIHB1YmxpY19pbnB1dHMsIHVycykpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9tYXhfZGVncmVlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9tYXhfZGVncmVlO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcHVibGljX2lucHV0cyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDhfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9yZWFkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCB1cnMsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcmVhZChvZmZzZXQsIHVycywgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfd3JpdGUgPSBmdW5jdGlvbihhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfd3JpdGUoYXBwZW5kLCB0LCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX2RvbWFpbl9vZl9ydXN0XG52YXIgY2FtbF9wbG9ua19kb21haW5fb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbG9nX3NpemVfb2ZfZ3JvdXAgPSB4LmxvZ19zaXplX29mX2dyb3VwO1xuICAgIHZhciBncm91cF9nZW4gPSB4Lmdyb3VwX2dlbjtcbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIGxvZ19zaXplX29mX2dyb3VwLCBncm91cF9nZW5dO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfZG9tYWluX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wbG9ua19kb21haW5fdG9fcnVzdCA9IGZ1bmN0aW9uKHgsIGtsYXNzKSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyBnZXRzIGZpbmFsaXplZFxuICAgIHJldHVybiBuZXcga2xhc3MoeFsxXSwgeFsyXSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tLCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIHBsb25rX3dhc21cbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc19vZl9ydXN0ID0gZnVuY3Rpb24oeCwgYWZmaW5lX2tsYXNzKSB7XG4gICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbihwb2x5X2NvbW0pIHtcbiAgICAgICAgcmV0dXJuIGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tKHBvbHlfY29tbSwgYWZmaW5lX2tsYXNzLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8vIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbihjb21tcykge1xuICAgIC8vICAgICB2YXIgbiA9IGNvbW1zLmxlbmd0aDtcbiAgICAvLyAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShuLTEpO1xuICAgIC8vICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgIC8vICAgICAgICAgcmVzW2ktMV0gPSBjb252ZXJ0KGNvbW1zW2ldKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHJlcyk7XG4gICAgLy8gICB9O1xuXG4gICAgLy8gc2hvdWxkIGJlIGludmVyc2Ugb2YgdGhlIGFib3ZlIF5cbiAgICAvLyBUT0RPOiBtYWtlIHdvcmsgZm9yIGJvdGggV2FzbS4uUG9seUNvbW0gdHlwZXNcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24oY29tbXMpIHtcbiAgICAgICAgY29tbXMgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IoY29tbXMsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0pO1xuICAgICAgICAvLyBjb21tcyA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcihjb21tcywgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSk7XG4gICAgICAgIHJldHVybiBbMF0uY29uY2F0KGNvbW1zLm1hcChjb252ZXJ0KSk7XG4gICAgfTtcblxuICAgIHZhciBzaWdtYV9jb21tID0gY29udmVydEFycmF5KHguc2lnbWFfY29tbSk7XG4gICAgdmFyIGNvZWZmaWNpZW50c19jb21tID0gY29udmVydEFycmF5KHguY29lZmZpY2llbnRzX2NvbW0pO1xuICAgIHZhciBnZW5lcmljX2NvbW0gPSBjb252ZXJ0KHguZ2VuZXJpY19jb21tKTtcbiAgICB2YXIgcHNtX2NvbW0gPSBjb252ZXJ0KHgucHNtX2NvbW0pO1xuICAgIHZhciBjb21wbGV0ZV9hZGRfY29tbSA9IGNvbnZlcnQoeC5jb21wbGV0ZV9hZGRfY29tbSk7XG4gICAgdmFyIG11bF9jb21tID0gY29udmVydCh4Lm11bF9jb21tKTtcbiAgICB2YXIgZW11bF9jb21tID0gY29udmVydCh4LmVtdWxfY29tbSk7XG4gICAgdmFyIGVuZG9tdWxfc2NhbGFyX2NvbW0gPSBjb252ZXJ0KHguZW5kb211bF9zY2FsYXJfY29tbSk7XG5cbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gWyAwXG4gICAgICAsIHNpZ21hX2NvbW1cbiAgICAgICwgY29lZmZpY2llbnRzX2NvbW1cbiAgICAgICwgZ2VuZXJpY19jb21tXG4gICAgICAsIHBzbV9jb21tXG4gICAgICAsIGNvbXBsZXRlX2FkZF9jb21tXG4gICAgICAsIG11bF9jb21tXG4gICAgICAsIGVtdWxfY29tbVxuICAgICAgLCBlbmRvbXVsX3NjYWxhcl9jb21tXG4gICAgICAsIDAgXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc190b19ydXN0XG4vLyBSZXF1aXJlczogY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0sIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX3RvX3J1c3QgPSBmdW5jdGlvbih4LCBrbGFzcywgcG9seV9jb21tX2NsYXNzLCBta19hZmZpbmUpIHtcbiAgICB2YXIgY29udmVydCA9IGZ1bmN0aW9uKHBvbHlfY29tbSkge1xuICAgICAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0ocG9seV9jb21tLCBwb2x5X2NvbW1fY2xhc3MsIG1rX2FmZmluZSk7XG4gICAgfTtcblxuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbihjb21tcykge1xuICAgICAgdmFyIG4gPSBjb21tcy5sZW5ndGg7XG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG4tMSk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHJlc1tpLTFdID0gY29udmVydChjb21tc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHJlcyk7XG4gICAgfTtcblxuICAgIHZhciBzaWdtYV9jb21tID0gY29udmVydEFycmF5KHhbMV0pO1xuICAgIHZhciBjb2VmZmljaWVudHNfY29tbSA9IGNvbnZlcnRBcnJheSh4WzJdKTtcbiAgICB2YXIgZ2VuZXJpY19jb21tID0gY29udmVydCh4WzNdKTtcbiAgICB2YXIgcHNtX2NvbW0gPSBjb252ZXJ0KHhbNF0pO1xuICAgIHZhciBjb21wbGV0ZV9hZGRfY29tbSA9IGNvbnZlcnQoeFs1XSk7XG4gICAgdmFyIG11bF9jb21tID0gY29udmVydCh4WzZdKTtcbiAgICB2YXIgZW11bF9jb21tID0gY29udmVydCh4WzddKTtcbiAgICB2YXIgZW5kb211bF9zY2FsYXJfY29tbSA9IGNvbnZlcnQoeFs4XSk7XG4gICAgLy8gVE9ETzogQ2hhY2hhXG5cbiAgICByZXR1cm4gbmV3IGtsYXNzKFxuICAgICAgc2lnbWFfY29tbSxcbiAgICAgIGNvZWZmaWNpZW50c19jb21tLFxuICAgICAgZ2VuZXJpY19jb21tLFxuICAgICAgcHNtX2NvbW0sXG4gICAgICBjb21wbGV0ZV9hZGRfY29tbSxcbiAgICAgIG11bF9jb21tLFxuICAgICAgZW11bF9jb21tLFxuICAgICAgZW5kb211bF9zY2FsYXJfY29tbSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3RcbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcmVzID0gWzAsIHguczAsIHguczEsIHguczIsIHguczMsIHguczQsIHguczUsIHguczZdOyBcbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c190b19ydXN0XG52YXIgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QgPSBmdW5jdGlvbih4LCBrbGFzcykge1xuICAgIHJldHVybiBuZXcga2xhc3MoeFsxXSwgeFsyXSwgeFszXSwgeFs0XSwgeFs1XSwgeFs2XSwgeFs3XSk7XG59O1xuXG4vLyBQcm92aWRlczogY29sdW1uX29mX3J1c3RcbmZ1bmN0aW9uIGNvbHVtbl9vZl9ydXN0KGNvbCkge1xuICAgIC8vIHR5cGUgbm9ucmVjIGNvbHVtbiA9IFdpdG5lc3Mgb2YgaW50IHwgWiB8IExvb2t1cFNvcnRlZCBvZiBpbnQgfCBMb29rdXBBZ2dyZWcgfCBMb29rdXBUYWJsZSB8IExvb2t1cEtpbmRJbmRleCBvZiBpbnQgfCBJbmRleCBvZiBnYXRlX3R5cGUgfCBDb2VmZmljaWVudCBvZiBpbnRcbiAgICB2YXIgdGFnID0gY29sLnRhZztcbiAgICB2YXIgZ2F0ZV90eXBlID0gY29sLmdhdGVfdHlwZTtcbiAgICB2YXIgaSA9IGNvbC5pO1xuICAgIGNvbC5mcmVlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgMDogW3RhZywgaV0sXG4gICAgICAgIDI6IFt0YWcsIGldLFxuICAgICAgICA1OiBbdGFnLCBpXSxcbiAgICAgICAgNjogW3RhZywgZ2F0ZV90eXBlXSxcbiAgICAgICAgNzogW3RhZywgaV1cbiAgICB9W3RhZ10gfHwgdGFnO1xufVxuXG4vLyBQcm92aWRlczogdmFyaWFibGVfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNvbHVtbl9vZl9ydXN0XG5mdW5jdGlvbiB2YXJpYWJsZV9vZl9ydXN0KHZhcmlhYmxlKSB7XG4gICAgLy8gY29sICogcm93XG4gICAgdmFyIGNvbCA9IHZhcmlhYmxlLmNvbDtcbiAgICB2YXIgcm93ID0gdmFyaWFibGUucm93OyAvLyAwLCAxXG4gICAgdmFyaWFibGUuZnJlZSgpO1xuICAgIHJldHVybiBbMCwgY29sdW1uX29mX3J1c3QoY29sKSwgcm93XTtcbn1cblxuLy8gUHJvdmlkZXM6IHBvbGlzaF90b2tlbl9vZl9ydXN0XG4vLyBSZXF1aXJlczogdmFyaWFibGVfb2ZfcnVzdFxuZnVuY3Rpb24gcG9saXNoX3Rva2VuX29mX3J1c3QodG9rZW4pIHtcbiAgICB2YXIgdGFnID0gdG9rZW4udGFnO1xuICAgIHZhciBpMCA9IHRva2VuLmkwO1xuICAgIHZhciBpMSA9IHRva2VuLmkxO1xuICAgIHZhciBmID0gdG9rZW4uZjtcbiAgICB2YXIgdiA9IHZhcmlhYmxlX29mX3J1c3QodG9rZW4udik7XG4gICAgdG9rZW4uZnJlZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIDU6IFs1LCBpMCwgaTFdLFxuICAgICAgICA2OiBbNiwgZl0sXG4gICAgICAgIDc6IFs3LCB2XSxcbiAgICAgICAgOTogWzksIGkwXSxcbiAgICAgICAgMTQ6IFsxNCwgaTBdLFxuICAgICAgICAxNjogWzE2LCBpMF1cbiAgICB9W3RhZ10gfHwgdGFnO1xufVxuXG4vLyBQcm92aWRlczogaW5kZXhfdGVybV9vZl9ydXN0XG4vLyBSZXF1aXJlczogY29sdW1uX29mX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgcG9saXNoX3Rva2VuX29mX3J1c3RcbmZ1bmN0aW9uIGluZGV4X3Rlcm1fb2ZfcnVzdCh0ZXJtLCB0b2tlbl9jbGFzcykge1xuICAgIC8vIHB1YiBjb2x1bW46IFdhc21Db2x1bW4sXG4gICAgLy8gcHViIGNvZWZmaWNpZW50OiBXYXNtVmVjdG9yPFdhc21Qb2xpc2hUb2tlbj4sXG4gICAgdmFyIGNvbHVtbiA9IGNvbHVtbl9vZl9ydXN0KHRlcm0uY29sdW1uKTtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IodGVybS5jb2VmZmljaWVudCwgdG9rZW5fY2xhc3MpO1xuICAgIGNvZWZmaWNpZW50ID0gY29lZmZpY2llbnQubWFwKHBvbGlzaF90b2tlbl9vZl9ydXN0KVxuICAgIGNvZWZmaWNpZW50ID0gWzBdLmNvbmNhdChjb2VmZmljaWVudCk7XG4gICAgdGVybS5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCBjb2x1bW4sIGNvZWZmaWNpZW50XTtcbn1cblxuLy8gUHJvdmlkZXM6IHdyYXBcbmZ1bmN0aW9uIHdyYXAocHRyLCBrbGFzcykge1xuICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKGtsYXNzLnByb3RvdHlwZSk7XG4gICAgb2JqLnB0ciA9IHB0cjtcbiAgICByZXR1cm4gb2JqO1xufVxuXG4vLyBQcm92aWRlczogbGluZWFyaXphdGlvbl9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yLCBwb2xpc2hfdG9rZW5fb2ZfcnVzdCwgd3JhcCwgaW5kZXhfdGVybV9vZl9ydXN0XG5mdW5jdGlvbiBsaW5lYXJpemF0aW9uX29mX3J1c3QobGluZWFyaXphdGlvbiwgYWZmaW5lX2NsYXNzKSB7XG4gICAgdmFyIEYgPSBhZmZpbmVfY2xhc3MgPT09IHBsb25rX3dhc20uV2FzbUdWZXN0YSA/ICdGcScgOiAnRnAnO1xuICAgIHZhciBXYXNtUG9saXNoVG9rZW4gPSBwbG9ua193YXNtWydXYXNtJyArIEYgKyAnUG9saXNoVG9rZW4nXTtcbiAgICB2YXIgV2FzbUluZGV4VGVybSA9IHBsb25rX3dhc21bJ1dhc20nICsgRiArICdJbmRleFRlcm0nXTtcbiAgICBcbiAgICB2YXIgY29uc3RhbnRfdGVybSA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvcihsaW5lYXJpemF0aW9uLmNvbnN0YW50X3Rlcm0sIFdhc21Qb2xpc2hUb2tlbik7XG4gICAgY29uc3RhbnRfdGVybSA9IGNvbnN0YW50X3Rlcm0ubWFwKHBvbGlzaF90b2tlbl9vZl9ydXN0KVxuICAgIGNvbnN0YW50X3Rlcm0gPSBbMF0uY29uY2F0KGNvbnN0YW50X3Rlcm0pO1xuICAgIFxuICAgIHZhciBpbmRleF90ZXJtcyA9IEFycmF5LmZyb20obGluZWFyaXphdGlvbi5pbmRleF90ZXJtcylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocHRyKSB7XG4gICAgICAgICAgICB2YXIgd2FzbUluZGV4VGVybSA9IHdyYXAocHRyLCBXYXNtSW5kZXhUZXJtKTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleF90ZXJtX29mX3J1c3Qod2FzbUluZGV4VGVybSwgV2FzbVBvbGlzaFRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgaW5kZXhfdGVybXMgPSBbMF0uY29uY2F0KGluZGV4X3Rlcm1zKTtcbiAgICBcbiAgICBsaW5lYXJpemF0aW9uLmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIGNvbnN0YW50X3Rlcm0sIGluZGV4X3Rlcm1zXTtcbn1cblxuLy8gUHJvdmlkZXM6IE5vbmVcbnZhciBOb25lID0gMDtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGxpbmVhcml6YXRpb25fb2ZfcnVzdCwgY2FtbF9wbG9ua19kb21haW5fb2ZfcnVzdCwgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfb2ZfcnVzdCwgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3QsIGZyZWVfb25fZmluYWxpemUsIE5vbmVcbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QgPSBmdW5jdGlvbih4LCBhZmZpbmVfY2xhc3MpIHtcbiAgICB2YXIgZG9tYWluID0gY2FtbF9wbG9ua19kb21haW5fb2ZfcnVzdCh4LmRvbWFpbik7XG4gICAgdmFyIG1heF9wb2x5X3NpemUgPSB4Lm1heF9wb2x5X3NpemU7XG4gICAgdmFyIG1heF9xdW90X3NpemUgPSB4Lm1heF9xdW90X3NpemU7XG4gICAgdmFyIHNycyA9IGZyZWVfb25fZmluYWxpemUoeC5zcnMpO1xuICAgIHZhciBldmFscyA9IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3QoeC5ldmFscywgYWZmaW5lX2NsYXNzKTtcbiAgICB2YXIgc2hpZnRzID0gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3QoeC5zaGlmdHMpO1xuICAgIC8vIFRPRE86IEhhbmRsZSBsaW5lYXJpemF0aW9uIGNvcnJlY3RseSFcbiAgICAvLyB2YXIgbGluZWFyaXphdGlvbiA9IGxpbmVhcml6YXRpb25fb2ZfcnVzdCh4LmxpbmVhcml6YXRpb24sIGFmZmluZV9jbGFzcyk7XG4gICAgdmFyIGxvb2t1cF9pbmRleCA9IE5vbmU7XG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCBkb21haW4sIG1heF9wb2x5X3NpemUsIG1heF9xdW90X3NpemUsIHNycywgZXZhbHMsIHNoaWZ0cywgTm9uZV07XG59O1xuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcGxvbmtfZG9tYWluX3RvX3J1c3QsIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX3RvX3J1c3QsIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c190b19ydXN0LCBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeVxudmFyIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCA9IGZ1bmN0aW9uKHgsIGtsYXNzLCBkb21haW5fY2xhc3MsIHZlcmlmaWNhdGlvbl9ldmFsc19jbGFzcywgcG9seV9jb21tX2NsYXNzLCBta19hZmZpbmUsIHZlcmlmaWNhdGlvbl9zaGlmdHNfY2xhc3MpIHtcbiAgICB2YXIgZG9tYWluID0gY2FtbF9wbG9ua19kb21haW5fdG9fcnVzdCh4WzFdLCBkb21haW5fY2xhc3MpO1xuICAgIHZhciBtYXhfcG9seV9zaXplID0geFsyXTtcbiAgICB2YXIgbWF4X3F1b3Rfc2l6ZSA9IHhbM107XG4gICAgdmFyIHNycyA9IHhbNF07XG4gICAgdmFyIGV2YWxzID0gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfdG9fcnVzdCh4WzVdLCB2ZXJpZmljYXRpb25fZXZhbHNfY2xhc3MsIHBvbHlfY29tbV9jbGFzcywgbWtfYWZmaW5lKTtcbiAgICB2YXIgc2hpZnRzID0gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QoeFs2XSwgdmVyaWZpY2F0aW9uX3NoaWZ0c19jbGFzcyk7XG4gICAgcmV0dXJuIG5ldyBrbGFzcyhkb21haW4sIG1heF9wb2x5X3NpemUsIG1heF9xdW90X3NpemUsIHNycywgZXZhbHMsIHNoaWZ0cyk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCh4LCBwbG9ua193YXNtLldhc21HVmVzdGEpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KHgsIHBsb25rX3dhc20uV2FzbUZwUGxvbmtWZXJpZmllckluZGV4LCBwbG9ua193YXNtLldhc21GcERvbWFpbiwgcGxvbmtfd2FzbS5XYXNtRnBQbG9ua1ZlcmlmaWNhdGlvbkV2YWxzLCBwbG9ua193YXNtLldhc21GcFBvbHlDb21tLCBwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX29uZSwgcGxvbmtfd2FzbS5XYXNtRnBTaGlmdHMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHZrID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSh4KTtcbiAgICB2YXIgdmtfY2FtbCA9IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCh2ayk7XG4gICAgcmV0dXJuIHZrX2NhbWw7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHVycywgcGF0aCkge1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZChvZmZzZXQsIHVycywgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUgPSBmdW5jdGlvbiAoYXBwZW5kLCB0LCBwYXRoKSB7XG4gICAgaWYgKGFwcGVuZCA9PT0gMCkge1xuICAgICAgICBhcHBlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlKGFwcGVuZCwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KHQpLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzID0gZnVuY3Rpb24obG9nMl9zaXplKSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHMobG9nMl9zaXplKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15KCk7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChyZXMpO1xuICAgIC8vIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHkoY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KHgpKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCh4LCBwbG9ua193YXNtLldhc21HUGFsbGFzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh4LCBwbG9ua193YXNtLldhc21GcVBsb25rVmVyaWZpZXJJbmRleCwgcGxvbmtfd2FzbS5XYXNtRnFEb21haW4sIHBsb25rX3dhc20uV2FzbUZxUGxvbmtWZXJpZmljYXRpb25FdmFscywgcGxvbmtfd2FzbS5XYXNtRnFQb2x5Q29tbSwgcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZmZpbmVfb25lLCBwbG9ua193YXNtLldhc21GcVNoaWZ0cyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGUoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCB1cnMsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQob2Zmc2V0LCB1cnMsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlID0gZnVuY3Rpb24gKGFwcGVuZCwgdCwgcGF0aCkge1xuICAgIGlmIChhcHBlbmQgPT09IDApIHtcbiAgICAgICAgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZShhcHBlbmQsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh0KSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyA9IGZ1bmN0aW9uKGxvZzJfc2l6ZSkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzKGxvZzJfc2l6ZSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZGVlcF9jb3B5ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weShjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoeCkpKTtcbn07XG5cblxuLy8gUHJvdmlkZXM6IENPTFVNTlNcbnZhciBDT0xVTU5TID0gMTU7XG4vLyBQcm92aWRlczogUEVSTVVUU19NSU5VU18xXG52YXIgUEVSTVVUU19NSU5VU18xID0gNjtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QsIFBFUk1VVFNfTUlOVVNfMSwgQ09MVU1OU1xudmFyIGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgdyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcChDT0xVTU5TKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENPTFVNTlM7ICsraSkge1xuICAgICAgdy5wdXNoKGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoeFsxXVtpICsgMV0pKTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoeFsyXSk7XG5cbiAgICB2YXIgcyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcChQRVJNVVRTX01JTlVTXzEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBQRVJNVVRTX01JTlVTXzE7ICsraSkge1xuICAgICAgcy5wdXNoKGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoeFszXVtpICsgMV0pKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJpY19zZWxlY3RvciA9IGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoeFs0XSk7XG4gICAgdmFyIHBvc2VpZG9uX3NlbGVjdG9yID0gY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCh4WzVdKTtcblxuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnBQcm9vZkV2YWx1YXRpb25zKHcsIHosIHMsIGdlbmVyaWNfc2VsZWN0b3IsIHBvc2VpZG9uX3NlbGVjdG9yKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0LCBDT0xVTU5TLCBQRVJNVVRTX01JTlVTXzFcbnZhciBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGNhbWxfZnBfdmVjdG9yX29mX3J1c3Qodi5nZXQoaSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICB2YXIgdyA9IGNvbnZlcnRBcnJheSh4LncsIENPTFVNTlMpO1xuICAgIHZhciB6ID0gY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCh4LnopO1xuICAgIHZhciBzID0gY29udmVydEFycmF5KHgucywgUEVSTVVUU19NSU5VU18xKTtcbiAgICB2YXIgZ2VuZXJpY19zZWxlY3RvciA9IGNhbWxfZnBfdmVjdG9yX29mX3J1c3QoeC5nZW5lcmljX3NlbGVjdG9yKTtcbiAgICB2YXIgcG9zZWlkb25fc2VsZWN0b3IgPSBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0KHgucG9zZWlkb25fc2VsZWN0b3IpO1xuXG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCB3LCB6LCBzLCBnZW5lcmljX3NlbGVjdG9yLCBwb3NlaWRvbl9zZWxlY3Rvcl07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0X2FmZmluZXMgPSBmdW5jdGlvbihhZmZpbmVzKSB7XG4gICAgICAgIHJldHVybiBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGFmZmluZXMsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX29uZSk7XG4gICAgfVxuICAgIHZhciBsciA9IHhbMV07XG4gICAgdmFyIGRlbHRhID0gcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUoeFsyXSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIHZhciB6MSA9IHhbM107XG4gICAgdmFyIHoyID0geFs0XTtcbiAgICB2YXIgc2cgPSBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSh4WzVdLCBwbG9ua193YXNtLmNhbWxfdmVzdGFfYWZmaW5lX29uZSk7XG4gICAgdmFyIGxlbiA9IGxyLmxlbmd0aDtcbiAgICAvLyBXZSBwYXNzIGwgYW5kIHIgYXMgc2VwYXJhdGUgdmVjdG9ycyBvdmVyIHRoZSBGRklcbiAgICB2YXIgbF9vY2FtbCA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciByX29jYW1sID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsX29jYW1sW2ldID0gbHJbaV1bMV07XG4gICAgICAgIHJfb2NhbWxbaV0gPSBscltpXVsyXTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMobF9vY2FtbCk7XG4gICAgdmFyIHIgPSBjb252ZXJ0X2FmZmluZXMocl9vY2FtbCk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcE9wZW5pbmdQcm9vZihsLCByLCBkZWx0YSwgejEsIHoyLCBzZyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0X2FmZmluZXMgPSBmdW5jdGlvbihhZmZpbmVzKSB7XG4gICAgICAgIHJldHVybiBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yKGFmZmluZXMsIHBsb25rX3dhc20uV2FzbUdWZXN0YSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMoeC5scl8wKTtcbiAgICB2YXIgciA9IGNvbnZlcnRfYWZmaW5lcyh4LmxyXzEpO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHguZGVsdGEpO1xuICAgIHZhciB6MSA9IHguejE7XG4gICAgdmFyIHoyID0geC56MjtcbiAgICB2YXIgc2cgPSBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSh4LnNnKTtcbiAgICB4LmZyZWUoKTtcbiAgICB2YXIgbGVuID0gbC5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gci5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibCBhbmQgciBsZW5ndGhzIGRvbid0IG1hdGNoXCIpOyB9XG4gICAgdmFyIGxyID0gbmV3IEFycmF5KGxlbik7XG4gICAgbHJbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHR1cGxlID0gbmV3IEFycmF5KDMpO1xuICAgICAgICB0dXBsZVswXSA9IDA7XG4gICAgICAgIHR1cGxlWzFdID0gbFtpXTtcbiAgICAgICAgdHVwbGVbMl0gPSByW2ldO1xuICAgICAgICBscltpXSA9IHR1cGxlO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIGxyLCBkZWx0YSwgejEsIHoyLCBzZ107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCwganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yXG52YXIgY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c190b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID0gY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCh2W2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBuZWVkIHRvIGRvIGZpbmFsaXplciB0aGluZ3M/XG4gICAgICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IocmVzKTtcbiAgICB9O1xuXG4gICAgdmFyIHdfY29tbSA9IGNvbnZlcnRBcnJheSh4WzFdKTtcbiAgICB2YXIgel9jb21tID0gY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCh4WzJdKTtcbiAgICB2YXIgdF9jb21tID0gY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCh4WzNdKTtcbiAgICByZXR1cm4gbmV3IHBsb25rX3dhc20uV2FzbUZwUHJvdmVyQ29tbWl0bWVudHMod19jb21tLCB6X2NvbW0sIHRfY29tbSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCwganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yLCBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBhID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKHYsIHBsb25rX3dhc20uV2FzbUZwUG9seUNvbW0pO1xuICAgICAgICB2YXIgcmVzID0gWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gQ2hlY2sgdGhpcy4gQ291bGQgYmUgb2ZmIGJ5IDFcbiAgICAgICAgICAgIHJlcy5wdXNoKGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QoYVtpXSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgdmFyIHdfY29tbSA9IGNvbnZlcnRBcnJheSh4LndfY29tbSk7XG4gICAgdmFyIHpfY29tbSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QoeC56X2NvbW0pO1xuICAgIHZhciB0X2NvbW0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KHgudF9jb21tKTtcbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIHdfY29tbSwgel9jb21tLCB0X2NvbW1dO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCwganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yXG52YXIgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb21taXRtZW50cyA9IGNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfdG9fcnVzdCh4WzFdKTtcbiAgICB2YXIgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCh4WzJdKTtcbiAgICB2YXIgZXZhbHMwID0gY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0KHhbM11bMV0pO1xuICAgIHZhciBldmFsczEgPSBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QoeFszXVsyXSk7XG4gICAgdmFyIGZ0X2V2YWwxID0geFs0XTtcbiAgICB2YXIgcHVibGljXyA9IGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoeFs1XSk7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlcyA9IHhbNl07XG4gICAgdmFyIGNoYWxzX2xlbiA9IHByZXZfY2hhbGxlbmdlcy5sZW5ndGg7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzID0gbmV3IHBsb25rX3dhc20uV2FzbVZlY1ZlY0ZwKGNoYWxzX2xlbiAtIDEpO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfY29tbXMgPSBuZXcgQXJyYXkoY2hhbHNfbGVuLTEpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hhbHNfbGVuOyBpKyspIHtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMucHVzaChjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHByZXZfY2hhbGxlbmdlc1tpXVsxXSkpO1xuICAgICAgICBwcmV2X2NoYWxsZW5nZXNfY29tbXNbaS0xXSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QocHJldl9jaGFsbGVuZ2VzW2ldWzJdKTtcbiAgICB9XG4gICAgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHByZXZfY2hhbGxlbmdlc19jb21tcyk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcFByb3ZlclByb29mKGNvbW1pdG1lbnRzLCBwcm9vZiwgZXZhbHMwLCBldmFsczEsIGZ0X2V2YWwxLCBwdWJsaWNfLCBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycywgcHJldl9jaGFsbGVuZ2VzX2NvbW1zKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX29mX3J1c3QsIGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QsIGNhbWxfZnBfdmVjdG9yX29mX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbWVzc2FnZXMgPSBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX29mX3J1c3QoeC5jb21taXRtZW50cyk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX29mX3J1c3QoeC5wcm9vZik7XG4gICAgdmFyIGV2YWxzMCA9IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCh4LmV2YWxzMCk7XG4gICAgdmFyIGV2YWxzMSA9IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCh4LmV2YWxzMSk7XG4gICAgdmFyIGZ0X2V2YWwxID0geC5mdF9ldmFsMTtcbiAgICB2YXIgcHVibGljXyA9IGNhbWxfZnBfdmVjdG9yX29mX3J1c3QoeC5wdWJsaWNfKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMgPSB4LnByZXZfY2hhbGxlbmdlc19zY2FsYXJzO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfY29tbXMgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IoeC5wcmV2X2NoYWxsZW5nZXNfY29tbXMsIHBsb25rX3dhc20uV2FzbUZwUG9seUNvbW0pO1xuICAgIHZhciBjaGFsc19sZW4gPSBwcmV2X2NoYWxsZW5nZXNfY29tbXMubGVuZ3RoO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXMgPSBuZXcgQXJyYXkoY2hhbHNfbGVuKTtcbiAgICBwcmV2X2NoYWxsZW5nZXNbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hhbHNfbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgcmVzWzBdID0gMDtcbiAgICAgICAgcmVzWzFdID0gY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdChwcmV2X2NoYWxsZW5nZXNfc2NhbGFycy5nZXQoaS0xKSk7XG4gICAgICAgIC8vIFRPRE8gQ2hlY2sgdGhpcy4gQ291bGQgYmUgb2ZmIGJ5IDFcbiAgICAgICAgcmVzWzJdID0gY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdChwcmV2X2NoYWxsZW5nZXNfY29tbXNbaV0pO1xuICAgICAgICBwcmV2X2NoYWxsZW5nZXNbaV0gPSByZXM7XG4gICAgfVxuICAgIHJldHVybiBbMCwgbWVzc2FnZXMsIHByb29mLCBbMCwgZXZhbHMwLCBldmFsczFdLCBmdF9ldmFsMSwgcHVibGljXywgcHJldl9jaGFsbGVuZ2VzXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2NyZWF0ZSA9IGZ1bmN0aW9uKGluZGV4LCB3aXRuZXNzX2NvbHMsIHByZXZfY2hhbGxlbmdlcywgcHJldl9zZ3MpIHtcbiAgICB2YXIgdyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcCh3aXRuZXNzX2NvbHMubGVuZ3RoLTEpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgd2l0bmVzc19jb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3LnB1c2goY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCh3aXRuZXNzX2NvbHNbaV0pKTtcbiAgICB9XG4gICAgd2l0bmVzc19jb2xzID0gdztcbiAgICBwcmV2X2NoYWxsZW5nZXMgPSBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHByZXZfY2hhbGxlbmdlcyk7XG4gICAgcHJldl9zZ3MgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKHByZXZfc2dzLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfY3JlYXRlKGluZGV4LCB3aXRuZXNzX2NvbHMsIHByZXZfY2hhbGxlbmdlcywgcHJldl9zZ3MpO1xuICAgIHZhciBwcm9vZiA9IGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdChyZXMpO1xuICAgIHJldHVybiBwcm9vZjtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX3ZlcmlmeVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl92ZXJpZnkgPSBmdW5jdGlvbihpbmRleCwgcHJvb2YpIHtcbiAgICBpbmRleCA9IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdChpbmRleCk7XG4gICAgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3QocHJvb2YpO1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfdmVyaWZ5KGluZGV4LCBwcm9vZik7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5ID0gZnVuY3Rpb24oaW5kZXhlcywgcHJvb2ZzKSB7XG4gICAgaW5kZXhlcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoaW5kZXhlcywgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KTtcbiAgICBwcm9vZnMgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKHByb29mcywgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0KTtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeShpbmRleGVzLCBwcm9vZnMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2R1bW15ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZHVtbXkoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5ID0gZnVuY3Rpb24ocHJvb2YpIHtcbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcF9wcm9vZl9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9kZWVwX2NvcHkoY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0KHByb29mKSkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCwgUEVSTVVUU19NSU5VU18xLCBDT0xVTU5TXG52YXIgY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciB3ID0gbmV3IHBsb25rX3dhc20uV2FzbVZlY1ZlY0ZxKENPTFVNTlMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ09MVU1OUzsgKytpKSB7XG4gICAgICB3LnB1c2goY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCh4WzFdW2kgKyAxXSkpO1xuICAgIH1cblxuICAgIHZhciB6ID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCh4WzJdKTtcblxuICAgIHZhciBzID0gbmV3IHBsb25rX3dhc20uV2FzbVZlY1ZlY0ZxKFBFUk1VVFNfTUlOVVNfMSk7XG4gICAgZm9yIChpID0gMDsgaSA8IFBFUk1VVFNfTUlOVVNfMTsgKytpKSB7XG4gICAgICBzLnB1c2goY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCh4WzNdW2kgKyAxXSkpO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmljX3NlbGVjdG9yID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCh4WzRdKTtcbiAgICB2YXIgcG9zZWlkb25fc2VsZWN0b3IgPSBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KHhbNV0pO1xuXG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcVByb29mRXZhbHVhdGlvbnModywgeiwgcywgZ2VuZXJpY19zZWxlY3RvciwgcG9zZWlkb25fc2VsZWN0b3IpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnFfdmVjdG9yX29mX3J1c3QsIENPTFVNTlMsIFBFUk1VVFNfTUlOVVNfMVxudmFyIGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24odiwgbikge1xuICAgICAgICB2YXIgcmVzID0gWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCh2LmdldChpKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciB3ID0gY29udmVydEFycmF5KHgudywgQ09MVU1OUyk7XG4gICAgdmFyIHogPSBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0KHgueik7XG4gICAgdmFyIHMgPSBjb252ZXJ0QXJyYXkoeC5zLCBQRVJNVVRTX01JTlVTXzEpO1xuICAgIHZhciBnZW5lcmljX3NlbGVjdG9yID0gY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCh4LmdlbmVyaWNfc2VsZWN0b3IpO1xuICAgIHZhciBwb3NlaWRvbl9zZWxlY3RvciA9IGNhbWxfZnFfdmVjdG9yX29mX3J1c3QoeC5wb3NlaWRvbl9zZWxlY3Rvcik7XG5cbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIHcsIHosIHMsIGdlbmVyaWNfc2VsZWN0b3IsIHBvc2VpZG9uX3NlbGVjdG9yXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2ZfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lXG52YXIgY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX3RvX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGNvbnZlcnRfYWZmaW5lcyA9IGZ1bmN0aW9uKGFmZmluZXMpIHtcbiAgICAgICAgcmV0dXJuIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoYWZmaW5lcywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgfVxuICAgIHZhciBsciA9IHhbMV07XG4gICAgdmFyIGRlbHRhID0gcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUoeFsyXSwgcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZmZpbmVfb25lKTtcbiAgICB2YXIgejEgPSB4WzNdO1xuICAgIHZhciB6MiA9IHhbNF07XG4gICAgdmFyIHNnID0gcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUoeFs1XSwgcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZmZpbmVfb25lKTtcbiAgICB2YXIgbGVuID0gbHIubGVuZ3RoO1xuICAgIC8vIFdlIHBhc3MgbCBhbmQgciBhcyBzZXBhcmF0ZSB2ZWN0b3JzIG92ZXIgdGhlIEZGSVxuICAgIHZhciBsX29jYW1sID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIHJfb2NhbWwgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxfb2NhbWxbaV0gPSBscltpXVsxXTtcbiAgICAgICAgcl9vY2FtbFtpXSA9IGxyW2ldWzJdO1xuICAgIH1cbiAgICB2YXIgbCA9IGNvbnZlcnRfYWZmaW5lcyhsX29jYW1sKTtcbiAgICB2YXIgciA9IGNvbnZlcnRfYWZmaW5lcyhyX29jYW1sKTtcbiAgICByZXR1cm4gbmV3IHBsb25rX3dhc20uV2FzbUZxT3BlbmluZ1Byb29mKGwsIHIsIGRlbHRhLCB6MSwgejIsIHNnKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGNvbnZlcnRfYWZmaW5lcyA9IGZ1bmN0aW9uKGFmZmluZXMpIHtcbiAgICAgICAgcmV0dXJuIGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3IoYWZmaW5lcywgcGxvbmtfd2FzbS5XYXNtR1BhbGxhcywgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMoeC5scl8wKTtcbiAgICB2YXIgciA9IGNvbnZlcnRfYWZmaW5lcyh4LmxyXzEpO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHguZGVsdGEpO1xuICAgIHZhciB6MSA9IHguejE7XG4gICAgdmFyIHoyID0geC56MjtcbiAgICB2YXIgc2cgPSBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSh4LnNnKTtcbiAgICB4LmZyZWUoKTtcbiAgICB2YXIgbGVuID0gbC5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gci5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKFwibCBhbmQgciBsZW5ndGhzIGRvbid0IG1hdGNoXCIpOyB9XG4gICAgdmFyIGxyID0gbmV3IEFycmF5KGxlbik7XG4gICAgbHJbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHR1cGxlID0gbmV3IEFycmF5KDMpO1xuICAgICAgICB0dXBsZVswXSA9IDA7XG4gICAgICAgIHR1cGxlWzFdID0gbFtpXTtcbiAgICAgICAgdHVwbGVbMl0gPSByW2ldO1xuICAgICAgICBscltpXSA9IHR1cGxlO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIGxyLCBkZWx0YSwgejEsIHoyLCBzZ107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgcmVzW2ldID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QodltpICsgMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvcihyZXMpO1xuICAgIH07XG5cbiAgICB2YXIgd19jb21tID0gY29udmVydEFycmF5KHhbMV0pO1xuICAgIHZhciB6X2NvbW0gPSBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCh4WzJdKTtcbiAgICB2YXIgdF9jb21tID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QoeFszXSk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcVByb3ZlckNvbW1pdG1lbnRzKHdfY29tbSwgel9jb21tLCB0X2NvbW0pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0LCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBhID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKHYsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0pO1xuICAgICAgdmFyIHJlcyA9IFswXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAvLyBUT0RPIENoZWNrIHRoaXMuIENvdWxkIGJlIG9mZiBieSAxXG4gICAgICAgIHJlcy5wdXNoKGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KGFbaV0pKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgdmFyIHdfY29tbSA9IGNvbnZlcnRBcnJheSh4LndfY29tbSk7XG4gICAgdmFyIHpfY29tbSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KHguel9jb21tKTtcbiAgICB2YXIgdF9jb21tID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QoeC50X2NvbW0pO1xuICAgIHguZnJlZSgpO1xuICAgIHJldHVybiBbMCwgd19jb21tLCB6X2NvbW0sIHRfY29tbV07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c190b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0LCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0LCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCwganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yXG52YXIgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBtZXNzYWdlcyA9IGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfdG9fcnVzdCh4WzFdKTtcbiAgICB2YXIgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCh4WzJdKTtcbiAgICB2YXIgZXZhbHMwID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0KHhbM11bMV0pO1xuICAgIHZhciBldmFsczEgPSBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QoeFszXVsyXSk7XG4gICAgdmFyIGZ0X2V2YWwxID0geFs0XTtcbiAgICB2YXIgcHVibGljXyA9IGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoeFs1XSk7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlcyA9IHhbNl07XG4gICAgdmFyIGNoYWxzX2xlbiA9IHByZXZfY2hhbGxlbmdlcy5sZW5ndGg7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzID0gbmV3IHBsb25rX3dhc20uV2FzbVZlY1ZlY0ZxKGNoYWxzX2xlbiAtIDEpO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfY29tbXMgPSBuZXcgQXJyYXkoY2hhbHNfbGVuLTEpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hhbHNfbGVuOyBpKyspIHtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMucHVzaChjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KHByZXZfY2hhbGxlbmdlc1tpXVsxXSkpO1xuICAgICAgICBwcmV2X2NoYWxsZW5nZXNfY29tbXNbaS0xXSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0KHByZXZfY2hhbGxlbmdlc1tpXVsyXSk7XG4gICAgfVxuICAgIHByZXZfY2hhbGxlbmdlc19jb21tcyA9IGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvcihwcmV2X2NoYWxsZW5nZXNfY29tbXMpO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnFQcm92ZXJQcm9vZihtZXNzYWdlcywgcHJvb2YsIGV2YWxzMCwgZXZhbHMxLCBmdF9ldmFsMSwgcHVibGljXywgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMsIHByZXZfY2hhbGxlbmdlc19jb21tcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c19vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0LCBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0LCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBtZXNzYWdlcyA9IGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfb2ZfcnVzdCh4LmNvbW1pdG1lbnRzKTtcbiAgICB2YXIgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZxX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdCh4LnByb29mKTtcbiAgICB2YXIgZXZhbHMwID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0KHguZXZhbHMwKTtcbiAgICB2YXIgZXZhbHMxID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0KHguZXZhbHMxKTtcbiAgICB2YXIgZnRfZXZhbDEgPSB4LmZ0X2V2YWwxO1xuICAgIHZhciBwdWJsaWNfID0gY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCh4LnB1YmxpY18pO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycyA9IHgucHJldl9jaGFsbGVuZ2VzX3NjYWxhcnM7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlc19jb21tcyA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih4LnByZXZfY2hhbGxlbmdlc19jb21tcywgcGxvbmtfd2FzbS5XYXNtRnFQb2x5Q29tbSk7XG4gICAgdmFyIGNoYWxzX2xlbiA9IHByZXZfY2hhbGxlbmdlc19jb21tcy5sZW5ndGg7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlcyA9IG5ldyBBcnJheShjaGFsc19sZW4pO1xuICAgIHByZXZfY2hhbGxlbmdlc1swXSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGFsc19sZW47IGkrKykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KDMpO1xuICAgICAgICByZXNbMF0gPSAwO1xuICAgICAgICByZXNbMV0gPSBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0KHByZXZfY2hhbGxlbmdlc19zY2FsYXJzLmdldChpLTEpKTtcbiAgICAgICAgcmVzWzJdID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocHJldl9jaGFsbGVuZ2VzX2NvbW1zW2ldKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzW2ldID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIG1lc3NhZ2VzLCBwcm9vZiwgWzAsIGV2YWxzMCwgZXZhbHMxXSwgZnRfZXZhbDEsIHB1YmxpY18sIHByZXZfY2hhbGxlbmdlc107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0LCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9jcmVhdGUgPSBmdW5jdGlvbihpbmRleCwgd2l0bmVzc19jb2xzLCBwcmV2X2NoYWxsZW5nZXMsIHByZXZfc2dzKSB7XG4gICAgdmFyIHcgPSBuZXcgcGxvbmtfd2FzbS5XYXNtVmVjVmVjRnEod2l0bmVzc19jb2xzLmxlbmd0aC0xKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHdpdG5lc3NfY29scy5sZW5ndGg7IGkrKykge1xuICAgICAgdy5wdXNoKGNhbWxfZnFfdmVjdG9yX3RvX3J1c3Qod2l0bmVzc19jb2xzW2ldKSk7XG4gICAgfVxuICAgIHdpdG5lc3NfY29scyA9IHc7XG4gICAgcHJldl9jaGFsbGVuZ2VzID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXMpO1xuICAgIHByZXZfc2dzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihwcmV2X3NncywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9jcmVhdGUoaW5kZXgsIHdpdG5lc3NfY29scywgcHJldl9jaGFsbGVuZ2VzLCBwcmV2X3Nncyk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0KHJlcyk7XG4gICAgcmV0dXJuIHByb29mO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfdmVyaWZ5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl92ZXJpZnkgPSBmdW5jdGlvbihpbmRleCwgcHJvb2YpIHtcbiAgICBpbmRleCA9IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdChpbmRleCk7XG4gICAgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QocHJvb2YpO1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfdmVyaWZ5KGluZGV4LCBwcm9vZik7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeSA9IGZ1bmN0aW9uKGluZGV4ZXMsIHByb29mcykge1xuICAgIGluZGV4ZXMgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGluZGV4ZXMsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCk7XG4gICAgcHJvb2ZzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3Rvcihwcm9vZnMsIGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdCk7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnkoaW5kZXhlcywgcHJvb2ZzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2R1bW15XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kdW1teSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2RlZXBfY29weSA9IGZ1bmN0aW9uKHByb29mKSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5KGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdChwcm9vZikpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcmFuZG9tX29yYWNsZXNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvciwgY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9yYW5kb21fb3JhY2xlc19vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBqb2ludF9jb21iaW5lcl9jaGFsID0geC5qb2ludF9jb21iaW5lcl9jaGFsO1xuICAgIHZhciBqb2ludF9jb21iaW5lciA9IHguam9pbnRfY29tYmluZXI7XG4gICAgdmFyIGpvaW50X2NvbWJpbmVyX29jYW1sID0gdW5kZWZpbmVkO1xuICAgIGlmIChqb2ludF9jb21iaW5lcl9jaGFsICE9PSB1bmRlZmluZWQgJiYgam9pbnRfY29tYmluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBqb2ludF9jb21iaW5lcl9vY2FtbCA9IFswLCBbMCwgam9pbnRfY29tYmluZXJfY2hhbF0sIGpvaW50X2NvbWJpbmVyXTtcbiAgICB9XG4gICAgcmV0dXJuIFswLFxuICAgICAgY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkKGpvaW50X2NvbWJpbmVyX29jYW1sKSxcbiAgICAgIHguYmV0YSxcbiAgICAgIHguZ2FtbWEsXG4gICAgICBbMCwgeC5hbHBoYV9jaGFsXSxcbiAgICAgIHguYWxwaGEsXG4gICAgICB4LnpldGEsXG4gICAgICB4LnYsXG4gICAgICB4LnUsXG4gICAgICBbMCwgeC56ZXRhX2NoYWxdLFxuICAgICAgWzAsIHgudl9jaGFsXSxcbiAgICAgIFswLCB4LnVfY2hhbF1dO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvciwgY2FtbF9vcHRpb25fdG9fbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9yYW5kb21fb3JhY2xlc190b19ydXN0ID0gZnVuY3Rpb24oeCwgcm9LbGFzcykge1xuICAgIC8vIHZhciBjYW1sX3ZlY3RvciA9IFswLCB4WzFdLCB4WzJdLCB4WzNdWzFdLCB4WzRdLCB4WzVdLCB4WzZdLCB4WzddLCB4WzhdWzFdLCB4WzldWzFdLCB4WzEwXVsxXV07XG4gICAgdmFyIGpvaW50X2NvbWJpbmVyX29jYW1sID0gY2FtbF9vcHRpb25fdG9fbWF5YmVfdW5kZWZpbmVkKHhbMV0pO1xuICAgIHZhciBqb2ludF9jb21iaW5lcl9jaGFsID0gdW5kZWZpbmVkO1xuICAgIHZhciBqb2ludF9jb21iaW5lciA9IHVuZGVmaW5lZDtcbiAgICBpZiAoam9pbnRfY29tYmluZXJfb2NhbWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBqb2ludF9jb21iaW5lcl9jaGFsID0gam9pbnRfY29tYmluZXJfb2NhbWxbMV1bMV07XG4gICAgICAgIGpvaW50X2NvbWJpbmVyID0gam9pbnRfY29tYmluZXJfb2NhbWxbMl07XG4gICAgfVxuICAgIHJldHVybiBuZXcgcm9LbGFzcyhcbiAgICAgIGpvaW50X2NvbWJpbmVyX2NoYWwsXG4gICAgICBqb2ludF9jb21iaW5lcixcbiAgICAgIHhbMl0sXG4gICAgICB4WzNdLFxuICAgICAgeFs0XVsxXSxcbiAgICAgIHhbNV0sXG4gICAgICB4WzZdLFxuICAgICAgeFs3XSxcbiAgICAgIHhbOF0sXG4gICAgICB4WzldWzFdLFxuICAgICAgeFsxMF1bMV0sXG4gICAgICB4WzExXVsxXSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9vcmFjbGVzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IsIGNhbWxfcmFuZG9tX29yYWNsZXNfb2ZfcnVzdFxudmFyIGNhbWxfb3JhY2xlc19vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBbMCwgY2FtbF9yYW5kb21fb3JhY2xlc19vZl9ydXN0KHgubyksIFswLCB4LnBfZXZhbDAsIHgucF9ldmFsMV0sIGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3Rvcih4Lm9wZW5pbmdfcHJlY2hhbGxlbmdlcywgMzIgLyogVE9ETzogRG9uJ3QgaGFyZGNvZGUgKi8pLCB4LmRpZ2VzdF9iZWZvcmVfZXZhbHVhdGlvbnNdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfb3JhY2xlc190b19ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yLCBjYW1sX3JhbmRvbV9vcmFjbGVzX3RvX3J1c3RcbnZhciBjYW1sX29yYWNsZXNfdG9fcnVzdCA9IGZ1bmN0aW9uKHgsIGtsYXNzLCByb0tsYXNzKSB7XG4gICAgcmV0dXJuIG5ldyBrbGFzcyhcbiAgICAgICAgY2FtbF9yYW5kb21fb3JhY2xlc190b19ydXN0KHhbMV0sIHJvS2xhc3MpLFxuICAgICAgICB4WzJdWzFdLFxuICAgICAgICB4WzJdWzJdLFxuICAgICAgICBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoeFszXSksXG4gICAgICAgIHhbNF1cbiAgICApO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogZnBfb3JhY2xlc19jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29yYWNsZXNfb2ZfcnVzdCwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3RcbnZhciBmcF9vcmFjbGVzX2NyZWF0ZSA9IGZ1bmN0aW9uKGxncl9jb21tLCB2ZXJpZmllcl9pbmRleCwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcF9vcmFjbGVzX2NyZWF0ZShcbiAgICAgICAgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihsZ3JfY29tbSwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCksXG4gICAgICAgIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh2ZXJpZmllcl9pbmRleCksXG4gICAgICAgIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdChwcm9vZilcbiAgICApKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBmcF9vcmFjbGVzX2R1bW15XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcmFjbGVzX29mX3J1c3RcbnZhciBmcF9vcmFjbGVzX2R1bW15ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbWxfb3JhY2xlc19vZl9ydXN0KHBsb25rX3dhc20uZnBfb3JhY2xlc19kdW1teSgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBmcF9vcmFjbGVzX2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3JhY2xlc19vZl9ydXN0LCBjYW1sX29yYWNsZXNfdG9fcnVzdFxudmFyIGZwX29yYWNsZXNfZGVlcF9jb3B5ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX29yYWNsZXNfb2ZfcnVzdChwbG9ua193YXNtLmZwX29yYWNsZXNfZGVlcF9jb3B5KFxuICAgICAgY2FtbF9vcmFjbGVzX3RvX3J1c3QoeCwgcGxvbmtfd2FzbS5XYXNtRnBPcmFjbGVzLCBwbG9ua193YXNtLldhc21GcFJhbmRvbU9yYWNsZXMpKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBmcV9vcmFjbGVzX2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3JhY2xlc19vZl9ydXN0LCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3RcbnZhciBmcV9vcmFjbGVzX2NyZWF0ZSA9IGZ1bmN0aW9uKGxncl9jb21tLCB2ZXJpZmllcl9pbmRleCwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcV9vcmFjbGVzX2NyZWF0ZShcbiAgICAgICAgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihsZ3JfY29tbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QodmVyaWZpZXJfaW5kZXgpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QocHJvb2YpXG4gICAgKSk7XG59O1xuXG4vLyBQcm92aWRlczogZnFfb3JhY2xlc19kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3JhY2xlc19vZl9ydXN0XG52YXIgZnFfb3JhY2xlc19kdW1teSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX29yYWNsZXNfb2ZfcnVzdChwbG9ua193YXNtLmZxX29yYWNsZXNfZHVtbXkoKSk7XG59O1xuXG4vLyBQcm92aWRlczogZnFfb3JhY2xlc19kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29yYWNsZXNfb2ZfcnVzdCwgY2FtbF9vcmFjbGVzX3RvX3J1c3RcbnZhciBmcV9vcmFjbGVzX2RlZXBfY29weSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QoXG4gICAgICBwbG9ua193YXNtLmZxX29yYWNsZXNfZGVlcF9jb3B5KFxuICAgICAgICBjYW1sX29yYWNsZXNfdG9fcnVzdCh4LCBwbG9ua193YXNtLldhc21GcU9yYWNsZXMsIHBsb25rX3dhc20uV2FzbUZxUmFuZG9tT3JhY2xlcykpKTtcbn07XG5cblxuLy8gVGhpcyBpcyBmYWtlIC0tIHBhcmFtZXRlcnMgYXJlIG9ubHkgbmVlZGVkIG9uIHRoZSBSdXN0IHNpZGUsIHNvIG5vIG5lZWQgdG8gcmV0dXJuIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9wYXJhbXNfY3JlYXRlXG5mdW5jdGlvbiBjYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGUoKSB7XG4gICAgcmV0dXJuIFswXTtcbn1cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGVcbmZ1bmN0aW9uIGNhbWxfcGFzdGFfZnFfcG9zZWlkb25fcGFyYW1zX2NyZWF0ZSgpIHtcbiAgICByZXR1cm4gWzBdO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9ibG9ja19jaXBoZXJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0LCBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0XG5mdW5jdGlvbiBjYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX2Jsb2NrX2NpcGhlcihfZmFrZV9wYXJhbXMsIGZwX3ZlY3Rvcikge1xuICAgIC8vIDEuIGdldCBwZXJtdXRlZCBmaWVsZCB2ZWN0b3IgZnJvbSBydXN0XG4gICAgdmFyIHdhc21fZmxhdF92ZWN0b3IgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcG9zZWlkb25fYmxvY2tfY2lwaGVyKGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoZnBfdmVjdG9yKSk7XG4gICAgdmFyIG5ld19mcF92ZWN0b3IgPSBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0KHdhc21fZmxhdF92ZWN0b3IpO1xuICAgIC8vIDIuIHdyaXRlIGJhY2sgbW9kaWZpZWQgZmllbGQgdmVjdG9yIHRvIG9yaWdpbmFsIG9uZVxuICAgIG5ld19mcF92ZWN0b3IuZm9yRWFjaChmdW5jdGlvbiAoYSwgaSkge1xuICAgICAgICBmcF92ZWN0b3JbaV0gPSBhO1xuICAgIH0pO1xufVxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcG9zZWlkb25fYmxvY2tfY2lwaGVyXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCwgY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdFxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9ibG9ja19jaXBoZXIoX2Zha2VfcGFyYW1zLCBmcV92ZWN0b3IpIHtcbiAgICAvLyAxLiBnZXQgcGVybXV0ZWQgZmllbGQgdmVjdG9yIGZyb20gcnVzdFxuICAgIHZhciB3YXNtX2ZsYXRfdmVjdG9yID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bvc2VpZG9uX2Jsb2NrX2NpcGhlcihjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KGZxX3ZlY3RvcikpO1xuICAgIHZhciBuZXdfZnFfdmVjdG9yID0gY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCh3YXNtX2ZsYXRfdmVjdG9yKTtcbiAgICAvLyAyLiB3cml0ZSBiYWNrIG1vZGlmaWVkIGZpZWxkIHZlY3RvciB0byBvcmlnaW5hbCBvbmVcbiAgICBuZXdfZnFfdmVjdG9yLmZvckVhY2goZnVuY3Rpb24gKGEsIGkpIHtcbiAgICAgICAgZnFfdmVjdG9yW2ldID0gYTtcbiAgICB9KTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDEsIDAsIDB4N2ZmMCk7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4N2ZmMClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHhmZmYwKVxuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MHg4MDAwOih4Pj0wKT8wOjB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwtMTAyNik7XG4gIH0gZWxzZSB7XG4gICAgeCAvPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgICBpZiAoeCA8IDE2KSB7XG4gICAgICB4ICo9IDI7IGV4cCAtPTE7IH1cbiAgICBpZiAoZXhwID09IDApIHtcbiAgICAgIHggLz0gMjsgfVxuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwyNCk7XG4gIHZhciByMyA9IHh8MDtcbiAgeCA9ICh4IC0gcjMpICogaztcbiAgdmFyIHIyID0geHwwO1xuICB4ID0gKHggLSByMikgKiBrO1xuICB2YXIgcjEgPSB4fDA7XG4gIHIzID0gKHIzICYweGYpIHwgc2lnbiB8IGV4cCA8PCA0O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoZmxvYXQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGludDMyYVswXSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0ICh4LCBwcmVjLCBzdHlsZSkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nICgoeCA+IDApP1wiaW5maW5pdHlcIjpcIi1pbmZpbml0eVwiKTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzE6KHg+PTApPzA6MTtcbiAgaWYoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT0gMCkgeyB9XG4gIGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSAgeyB4ICo9IDI7IGV4cC0tIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA+PSAyKSB7IHggLz0gMjsgZXhwKysgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyAnJyA6ICcrJztcbiAgdmFyIHNpZ25fc3RyID0gJyc7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9ICctJ1xuICBlbHNlIHtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgIGNhc2UgNDMgLyogJysnICovOiBzaWduX3N0ciA9ICcrJzsgYnJlYWs7XG4gICAgY2FzZSAzMiAvKiAnICcgKi86IHNpZ25fc3RyID0gJyAnOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLHByZWMgKiA0KTtcbiAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZignLicpO1xuICAgIGlmKGlkeDwwKSB7XG4gICAgICB4X3N0ciArPSAnLicgKyBjYW1sX3N0cl9yZXBlYXQocHJlYywgJzAnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGlkeCsxK3ByZWM7XG4gICAgICBpZih4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgJzAnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeF9zdHIgPSB4X3N0ci5zdWJzdHIoMCxzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzaWduX3N0ciArICcweCcgKyB4X3N0ciArICdwJyArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBsbyA9IHgubG87XG4gIHZhciBtaSA9IHgubWk7XG4gIHZhciBoaSA9IHguaGk7XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgobG98bWl8KGhpJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKGhpICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKGxvKmsrbWkpKmsrKGhpJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoaGkgJiAweDgwMDApIHJlcyA9IC0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCAoeCx5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gTmFOO1xuICBpZih4PT15KSByZXR1cm4geTtcbiAgaWYoeD09MCl7XG4gICAgaWYoeSA8IDApXG4gICAgICByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NClcbiAgfVxuICB2YXIgYml0cyA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh4KTtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMSk7XG4gIGlmICgoeDx5KSA9PSAoeD4wKSlcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKVxuICBlbHNlXG4gICAgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSlcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KXtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSgxKTtcbiAgaW50MzJhWzBdID0geDtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0geSAtIDE7XG4gIHJldHVybiAoTWF0aC5hYnMoeCk+MT96Oih6PT0wP3g6eCp6L01hdGgubG9nKHkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSAxICsgeCwgeiA9IHkgLSAxO1xuICByZXR1cm4gKHo9PTA/eDp4Kk1hdGgubG9nKHkpL3opO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7XG4gIHZhciB4ID0gTWF0aC5hYnMoeCksIHkgPSBNYXRoLmFicyh5KTtcbiAgdmFyIGEgPSBNYXRoLm1heCh4LCB5KSwgYiA9IE1hdGgubWluKHgseSkgLyAoYT9hOjEpO1xuICByZXR1cm4gKGEgKiBNYXRoLnNxcnQoMSArIGIqYikpO1xufVxuXG4vLyBGSVg6IHRoZXNlIGZpdmUgZnVuY3Rpb25zIG9ubHkgZ2l2ZSBhcHByb3hpbWF0ZSByZXN1bHRzLlxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5MT0cxMEUgKiBNYXRoLmxvZyh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSBNYXRoLmV4cCgteCk7XG4gIHJldHVybiAoeSAtIHopIC8gKHkgKyB6KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopcChbKy1dP1swLTldKykvaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDRcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNF18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MzJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkge1xuICAgIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ZpbGxfYnl0ZXNcbnZhciBjYW1sX2ZpbGxfc3RyaW5nID0gY2FtbF9maWxsX2J5dGVzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSBpZiAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT0gczIuYy5sZW5ndGgpIHtcbiAgICBzMi5jICs9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzMik7XG4gICAgdmFyIGMxID0gczEuYywgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09IDQgLyogQVJSQVkgKi8pIHtcbiAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluIChsZW4sIGMxLmxlbmd0aCAtIGkxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxLmNoYXJDb2RlQXQoaTEgKyBpKTtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSxiLGMsZCxlKSB7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICAgIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIHMuY2hhckNvZGVBdChpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgaWYgKChzLnQgJiA2KSAhPSAwIC8qIEJZVEVTICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKXtcbiAgcmV0dXJuIHMudG9VdGYxNigpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbmlmKGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5pZihjYW1sX2N1cnJlbnRfZGlyLnNsaWNlKC0xKSAhPT0gXCIvXCIpIGNhbWxfY3VycmVudF9kaXIgKz0gXCIvXCJcblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG52YXIgY2FtbF9yb290ID0gY2FtbF9jdXJyZW50X2Rpci5tYXRjaCgvW15cXC9dKlxcLy8pWzBdO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYobmFtZS5jaGFyQ29kZUF0KDApICE9IDQ3KVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBpZihuY29tcC5sZW5ndGggPT0gMCkgbmNvbXAucHVzaChcIlwiKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCtcInN0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290K1wic3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IG5hbWUgKyBcIi9cIjtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aCArIHJvb3QucmVzdCArIFwiL1wiO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKVxuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wKSBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9am9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNhbWxfY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlID0gY2FtbF9jcmVhdGVfZmlsZTtcbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciBjb250ZW50ID0gKHR5cGVvZiBjb250ZW50ID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk6Y29udGVudDtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYyhuYW1lX29wdCk7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYoZy5xdWl0KSBnLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3MuZXhpdClcbiAgICBnLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZigham9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52KVxuICAgIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gMTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiVW5peFwiKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIE1sRmFrZURldmljZSAocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQ9e307XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMubG9va3VwRnVuID0gZjtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkgdGhpcy5jb250ZW50W25hbWVdPW5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHJlc1sxXSkpO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2gpO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgaWYgKG4ubWF0Y2gocikpIHJldHVybiAxXG4gIH1cbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10qKVwiKTtcbiAgdmFyIHNlZW4gPSB7fVxuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0gJiYgIXNlZW5bbVsxXV0pIHtzZWVuW21bMV1dID0gdHJ1ZTsgYS5wdXNoKG1bMV0pfVxuICB9XG4gIHJldHVybiBhO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10qKVwiKTtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtKSByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB2YXIgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgaWYoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShieXRlcyk7XG4gIH1cbiAgZWxzZSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXRcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHZhciBvbGQgPSB0aGlzLmRhdGE7XG4gIHRoaXMuZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgodGhpcy5kYXRhKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIHZhciBuZXdfc3RyID0gY2FtbF9jcmVhdGVfYnl0ZXMob2Zmc2V0ICsgbGVuKTtcbiAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbmV3X3N0cjtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkX2RhdGEsIDAsIHRoaXMuZGF0YSwgMCwgY2xlbik7XG4gIH1cbiAgY2FtbF9ibGl0X3N0cmluZyhidWYsIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19nZXQodGhpcy5kYXRhLCBvZmZzZXQpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnBsYXRmb3JtICE9PSBcImJyb3dzZXJcIilcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZpbGUsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2Uocm9vdCkge1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBiXG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICAgIHJldHVybiBuZXcgTWxOb2RlRmlsZShmZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sbikge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVEZXZpY2VcblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX2FycmF5X29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGaWxlKGZkKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcblxuTWxOb2RlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0cnkge1xuICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLGxlbnwwKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCkuc2l6ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGNhbWxfYnl0ZXNfc2V0KGJ1ZixidWZfb2Zmc2V0ICsgaSxidWZmZXJbYnVmX29mZnNldCtpXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgdmFyIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSgxKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCAwLCAxLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclswXTtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmlsZTtcbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wc1tcIl9uYXRcIl0gPVxuICAgIHsgZGVzZXJpYWxpemUgOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgICBzZXJpYWxpemUgOiBzZXJpYWxpemVfbmF0LFxuICAgICAgaGFzaCA6IGNhbWxfaGFzaF9uYXRcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5mdW5jdGlvbiBNbE5hdCh4KXtcbiAgdGhpcy5kYXRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoeCk7XG4gIC8vIGxlbmd0aF9uYXQgaXNuJ3QgZXh0ZXJuYWwsIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGUgT2JqLnNpemVcbiAgLy8gd29yayBvdXQgcmlnaHQuIFRoZSArMiB0byBhcnJheSBsZW5ndGggc2VlbXMgdG8gd29yay5cbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoICsgMlxufVxuXG5NbE5hdC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9uYXRcIjtcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX25hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbmF0KHgpIHtcbiAgdmFyIGxlbiA9IG51bV9kaWdpdHNfbmF0KHgsIDAsIHguZGF0YS5sZW5ndGgpO1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgeC5kYXRhW2ldKTtcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBuYXRfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBuYXRfb2ZfYXJyYXkobCl7XG4gIHJldHVybiBuZXcgTWxOYXQobCk7XG59XG5cbi8vUHJvdmlkZXM6IGNyZWF0ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBjcmVhdGVfbmF0KHNpemUpIHtcbiAgdmFyIGFyciA9IG5ldyBNbE5hdChzaXplKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGFyci5kYXRhW2ldID0gLTE7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLy9Qcm92aWRlczogc2V0X3RvX3plcm9fbmF0XG5mdW5jdGlvbiBzZXRfdG9femVyb19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAwO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBibGl0X25hdFxuZnVuY3Rpb24gYmxpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMiwgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gbmF0Mi5kYXRhW29mczIraV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXQobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXQobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gbnVtX2RpZ2l0c19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmKG5hdC5kYXRhW29mcytpXSAhPSAwKSByZXR1cm4gaSsxO1xuICB9XG4gIHJldHVybiAxOyAvLyAwIGNvdW50cyBhcyAxIGRpZ2l0XG59XG5cbi8vUHJvdmlkZXM6IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdFxuZnVuY3Rpb24gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdCwgb2ZzKSB7XG4gIHZhciBhID0gbmF0LmRhdGFbb2ZzXTtcbiAgdmFyIGIgPSAwO1xuICBpZihhICYgMHhGRkZGMDAwMCkgeyBiICs9MTY7IGEgPj4+PTE2OyB9XG4gIGlmKGEgJiAweEZGMDApICAgICB7IGIgKz0gODsgYSA+Pj49IDg7IH1cbiAgaWYoYSAmIDB4RjApICAgICAgIHsgYiArPSA0OyBhID4+Pj0gNDsgfVxuICBpZihhICYgMTIpICAgICAgICAgeyBiICs9IDI7IGEgPj4+PSAyOyB9XG4gIGlmKGEgJiAyKSAgICAgICAgICB7IGIgKz0gMTsgYSA+Pj49IDE7IH1cbiAgaWYoYSAmIDEpICAgICAgICAgIHsgYiArPSAxOyB9XG4gIHJldHVybiAzMiAtIGI7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X2ludFxuZnVuY3Rpb24gaXNfZGlnaXRfaW50KG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdID49IDApIHJldHVybiAxXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF96ZXJvXG5mdW5jdGlvbiBpc19kaWdpdF96ZXJvKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gPT0gMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9vZGRcbmZ1bmN0aW9uIGlzX2RpZ2l0X29kZChuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdICYgMSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbmNyX25hdFxuZnVuY3Rpb24gaW5jcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoeCB8IDApO1xuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogYWRkX25hdFxuLy9SZXF1aXJlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5jcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIGNhcnJ5KTtcbn1cblxuLy9Qcm92aWRlczogY29tcGxlbWVudF9uYXRcbmZ1bmN0aW9uIGNvbXBsZW1lbnRfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKC0xID4+PiAwKSAtIChuYXQuZGF0YVtvZnMraV0gPj4+IDApO1xuICB9XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vL1Byb3ZpZGVzOiBkZWNyX25hdFxuZnVuY3Rpb24gZGVjcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+MCkgLSBib3Jyb3c7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAoYm9ycm93ID09IDEpID8gMCA6IDE7XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IHN1Yl9uYXRcbi8vUmVxdWlyZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBzdWJfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSAtIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgLSBib3Jyb3c7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgKGJvcnJvdz09MSk/MDoxKTtcbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1tvZnMzXVxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBtdWx0X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogYWRkX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBhID0gKG5hdDMuZGF0YVtvZnMzXSA+Pj4gMCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeDEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhICYgMHgwMDAwRkZGRikgKyBjYXJyeTtcbiAgICB2YXIgeDIgPSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgPj4+IDE2KTtcbiAgICBjYXJyeSA9IE1hdGguZmxvb3IoeDIvNjU1MzYpO1xuICAgIHZhciB4MyA9IHgxICsgKHgyICUgNjU1MzYpICogNjU1MzY7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4MztcbiAgICBjYXJyeSArPSBNYXRoLmZsb29yKHgzLzQyOTQ5NjcyOTYpO1xuICB9XG5cbiAgaWYobGVuMiA8IGxlbjEgJiYgY2FycnkpIHtcbiAgICByZXR1cm4gYWRkX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgbmF0X29mX2FycmF5KFtjYXJyeV0pLCAwLCAxLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2Fycnk7XG4gIH1cbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1xuLy8gbGVuMSA+PSBsZW4yICsgbGVuMy5cbi8vUHJvdmlkZXM6IG11bHRfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X2RpZ2l0X25hdFxuZnVuY3Rpb24gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMywgbGVuMykge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMzsgaSsrKSB7XG4gICAgY2FycnkgKz0gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMStpLCBsZW4xLWksIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMraSk7XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBuYXQxID0gMiAqIG5hdDEgKyBuYXQyICogbmF0MlxuLy8gbGVuMSA+PSAyICogbGVuMlxuLy9Qcm92aWRlczogc3F1YXJlX25hdFxuLy9SZXF1aXJlczogbXVsdF9uYXQsIGFkZF9uYXRcbmZ1bmN0aW9uIHNxdWFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgY2FycnkgPSAwO1xuICBjYXJyeSArPSBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDEsIG9mczEsIGxlbjEsIDApO1xuICBjYXJyeSArPSBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKTtcbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfbGVmdF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIHZhciBhID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhIDw8IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPj4+ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy8gQXNzdW1pbmcgYyA+IGEsIHJldHVybnMgW3F1b3RpZW50LCByZW1haW5kZXJdIG9mIChhPDwzMiArIGIpL2Ncbi8vUHJvdmlkZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9oZWxwZXIoYSwgYiwgYykge1xuICB2YXIgeCA9IGEgKiA2NTUzNiArIChiPj4+MTYpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IoeC9jKSAqIDY1NTM2O1xuICB2YXIgeiA9ICh4ICUgYykgKiA2NTUzNjtcbiAgdmFyIHcgPSB6ICsgKGIgJiAweDAwMDBGRkZGKTtcbiAgcmV0dXJuIFt5ICsgTWF0aC5mbG9vcih3L2MpLCB3ICUgY107XG59XG5cbi8vIG5hdDFbb2ZzMStsZW5dIDwgbmF0MltvZnMyXVxuLy9Qcm92aWRlczogZGl2X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2RpZ2l0X25hdChuYXRxLCBvZnNxLCBuYXRyLCBvZnNyLCBuYXQxLCBvZnMxLCBsZW4sIG5hdDIsIG9mczIpIHtcbiAgdmFyIHJlbSA9IChuYXQxLmRhdGFbb2ZzMStsZW4tMV0gPj4+MCk7XG4gIC8vIG5hdHFbb2ZzcStsZW4tMV0gaXMgZ3VhcmFudGVlZCB0byBiZSB6ZXJvIChkdWUgdG8gdGhlIE1TRCByZXF1aXJlbWVudCksXG4gIC8vIGFuZCBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8uXG4gIGZvcih2YXIgaSA9IGxlbi0yOyBpID49IDA7IGktLSkge1xuICAgIHZhciB4ID0gZGl2X2hlbHBlcihyZW0sIChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQyLmRhdGFbb2ZzMl0gPj4+IDApKTtcbiAgICBuYXRxLmRhdGFbb2ZzcStpXSA9IHhbMF07XG4gICAgcmVtID0geFsxXTtcbiAgfVxuICBuYXRyLmRhdGFbb2Zzcl0gPSByZW07XG4gIHJldHVybiAwO1xufVxuXG4vLyBuYXQxW25hdDI6XSA6PSBuYXQxIC8gbmF0MlxuLy8gbmF0MVs6bmF0Ml0gOj0gbmF0MSAlIG5hdDJcbi8vIGxlbjEgPiBsZW4yLCBuYXQyW29mczIrbGVuMi0xXSA+IG5hdDFbb2ZzMStsZW4xLTFdXG4vL1Byb3ZpZGVzOiBkaXZfbmF0XG4vL1JlcXVpcmVzOiBkaXZfZGlnaXRfbmF0LCBkaXZfaGVscGVyLCBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQsIHNoaWZ0X2xlZnRfbmF0LCBzaGlmdF9yaWdodF9uYXQsIGNyZWF0ZV9uYXQsIHNldF90b196ZXJvX25hdCwgbXVsdF9kaWdpdF9uYXQsIHN1Yl9uYXQsIGNvbXBhcmVfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIGRpdl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICBpZihsZW4yID09IDEpIHtcbiAgICBkaXZfZGlnaXRfbmF0KG5hdDEsIG9mczErMSwgbmF0MSwgb2ZzMSwgbmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMik7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcyA9IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQyLCBvZnMyK2xlbjItMSk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuXG4gIHZhciBkID0gKG5hdDIuZGF0YVtvZnMyK2xlbjItMV0gPj4+IDApICsgMTtcbiAgdmFyIGEgPSBjcmVhdGVfbmF0KGxlbjIrMSk7XG4gIGZvciAodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSBsZW4yOyBpLS0pIHtcbiAgICAvLyBEZWNlbnQgbG93ZXIgYm91bmQgb24gcXVvXG4gICAgdmFyIHF1byA9IGQgPT0gNDI5NDk2NzI5NiA/IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgOiBkaXZfaGVscGVyKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQxLmRhdGFbb2ZzMStpLTFdID4+PjApLCBkKVswXTtcbiAgICBzZXRfdG9femVyb19uYXQoYSwgMCwgbGVuMisxKTtcbiAgICBtdWx0X2RpZ2l0X25hdChhLCAwLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbcXVvXSksIDApO1xuICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgYSwgMCwgbGVuMisxLCAxKTtcblxuICAgIHdoaWxlIChuYXQxLmRhdGFbb2ZzMStpXSAhPSAwIHx8IGNvbXBhcmVfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKSA+PSAwKSB7XG4gICAgICBxdW8gPSBxdW8gKyAxO1xuICAgICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCAxKTtcbiAgICB9XG5cbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHF1bztcbiAgfVxuXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHNoaWZ0IHJlbWFpbmRlclxuICBzaGlmdF9yaWdodF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyByZXN0b3JlXG4gIHJldHVybiAwO1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfcmlnaHRfbmF0XG5mdW5jdGlvbiBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSBsZW4xLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGEgPSBuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMDtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhID4+PiBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhIDw8ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPiBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAxO1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPCBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0XG4vL1JlcXVpcmVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgYSA9IG51bV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIGxlbjEpO1xuICB2YXIgYiA9IG51bV9kaWdpdHNfbmF0KG5hdDIsIG9mczIsIGxlbjIpO1xuICBpZihhID4gYikgcmV0dXJuIDE7XG4gIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gIGZvcih2YXIgaSA9IGxlbjEgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApID4gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIDE7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPCAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0X3JlYWxcbi8vUmVxdWlyZXM6IGNvbXBhcmVfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdF9yZWFsKG5hdDEsbmF0Mil7XG4gIHJldHVybiBjb21wYXJlX25hdChuYXQxLDAsbmF0MS5kYXRhLmxlbmd0aCxuYXQyLDAsbmF0Mi5kYXRhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGxhbmRfZGlnaXRfbmF0XG5mdW5jdGlvbiBsYW5kX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSAmPSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBsb3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBsb3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIHw9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGx4b3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBseG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSBePSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IHNlcmlhbGl6ZV9uYXRcbmZ1bmN0aW9uIHNlcmlhbGl6ZV9uYXQod3JpdGVyLCBuYXQsIHN6KXtcbiAgdmFyIGxlbiA9IG5hdC5kYXRhLmxlbmd0aDtcbiAgd3JpdGVyLndyaXRlKDMyLCBsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIHdyaXRlci53cml0ZSgzMiwgbmF0LmRhdGFbaV0pO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgc3pbMV0gPSBsZW4gKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBkZXNlcmlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZV9uYXQocmVhZGVyLCBzeil7XG4gIHZhciBsZW4gPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIgbmF0ID0gbmV3IE1sTmF0KGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgbmF0LmRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgcmV0dXJuIG5hdDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyYXlcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyMDJcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycjAyXCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5cbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgdmFyIF9tYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHZhciBfYmxvY2tfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKCkge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgICAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gVGhpcyBjb2RlIHN1cHBvcnRzIGJvdGggQXJyYXkgYW5kIE1sSW50NjQgaW1wbGVtZW50YXRpb25zIG9mIGludDY0IGluXG4vLyBqc19vZl9vY2FtbCAocHJlLSB2cyBwb3N0LTg4NzUwN2RiMWViOGVmZDc3OTA3MGNiZWRhYjM3NzQwOThhNTI5MzkpLlxuLy9cbi8vIENvbXBpbGF0aW9uIGlzIGN1cnJlbnRseSBicm9rZW4gb24gdGhlIE1sSW50NjQgaW1wbGVtZW50YXRpb24sIGR1ZSB0b1xuLy8gcmVtb3ZlZCBpbnRlcm5hbCBqc19vZl9vY2FtbCBwcmltaXRpdmVzLiBSZW1vdmluZyB0aGVzZSAoYW5kIHRoZSBBcnJheVxuLy8gaW1wbGVtZW50YXRpb25zLCBzaWduYWxsZWQgYnkgW2luc3RhbmNlb2YgQXJyYXldIGNoZWNrcykgd2lsbCBjYXVzZVxuLy8gY29tcGlsYXRpb24gdG8gc3VjY2VlZC5cbi8vXG4vLyBUT0RPOiBidWlsZC10aW1lIG1hZ2ljIHRvIHN0dWIgdGhlIHVuYXZhaWxhYmxlIHByaW1pdGl2ZXMgb24gbGF0ZXIgdmVyc2lvbnMuXG5cbi8vUHJvdmlkZXM6IFVJbnQzMiBjb25zdFxudmFyIFVJbnQzMiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgVUludDMyID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLnZhbHVlID0geCA+Pj4gMDtcbiAgICB9O1xuICAgIFVJbnQzMi5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcImludGVnZXJzOnVpbnQzMlwiO1xuICAgIHJldHVybiBVSW50MzI7XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc19pbnQzMl9vZl91aW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX2ludDMyX29mX3VpbnQzMihpKSB7XG4gICAgcmV0dXJuIChpLnZhbHVlIHwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3NpemVfdF9zaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc19zaXplX3Rfc2l6ZSh1bml0KSB7XG4gICAgcmV0dXJuIDQ7IC8vIFNldCBzaXplX3QgPSB1MzJcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDE2X29mX3N0cmluZ1xuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludDMyX29mX3N0cmluZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludDE2X29mX3N0cmluZyh4KSB7XG4gICAgdmFyIHkgPSBpbnRlZ2Vyc191aW50MzJfb2Zfc3RyaW5nKHgpO1xuICAgIHJldHVybiAoeS52YWx1ZSAmIDB4RkZGRik7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9hZGRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2FkZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSArIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfc3ViXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9zdWIoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgLSB5LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX2RpdlxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfZGl2KHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMih4LnZhbHVlIC8geS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9sb2dhbmRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2xvZ2FuZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSAmIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbG9nb3Jcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2xvZ29yKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMih4LnZhbHVlIHwgeS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9sb2d4b3Jcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2xvZ3hvcih4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSBeIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbWF4XG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9tYXgodW5pdCkge1xuICAgIHJldHVybiBuZXcgVUludDMyKDB4RkZGRkZGRkYpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbXVsXG4vL1JlcXVpcmVzOiBpbnRlZ2Vyc191aW50MzJfdG9faW50NjQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X3RvX2ludDMyLCBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9tdWwoeCwgeSkge1xuICAgIC8vIENvbnZlcnQgdG8gNjQtYml0IGFuZCBjb21wdXRlIHRoZXJlLlxuICAgIHZhciB4XzY0ID0gaW50ZWdlcnNfdWludDMyX3RvX2ludDY0KHgpO1xuICAgIHZhciB5XzY0ID0gaW50ZWdlcnNfdWludDMyX3RvX2ludDY0KHkpO1xuICAgIHJldHVybiBuZXcgVUludDMyIChjYW1sX2ludDY0X3RvX2ludDMyKGNhbWxfaW50NjRfbXVsKHhfNjQsIHlfNjQpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9vZl9pbnRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX29mX2ludChpKSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9vZl9pbnQzMlxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfb2ZfaW50MzIoaSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfb2ZfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9faW50MzIsIFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX29mX2ludDY0KGkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMihjYW1sX2ludDY0X3RvX2ludDMyKGkpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX29mX3N0cmluZ1xuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludF9vZl9zdHJpbmcsIGludGVnZXJzX3VpbnQzMl9vZl9pbnQ2NCwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmcocykge1xuICAgIC8vIFRvIG1hdGNoIHRoZSBDIGltcGxlbWVudGF0aW9uLCB3ZSBzaG91bGQgcGFyc2UgdGhlIHN0cmluZyBhcyBhbiB1aW50NjRcbiAgICAvLyBhbmQgdGhlbiBkb3duY2FzdC5cbiAgICB2YXIgbWF4X3ZhbCA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4ZmZmZmZmLCAweGZmZmZmZiwgMHhmZmZmKTtcbiAgICByZXR1cm4gaW50ZWdlcnNfdWludDMyX29mX2ludDY0KGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nKHMsIG1heF92YWwpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3JlbVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSwgVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfcmVtKHgsIHkpIHtcbiAgICBpZiAoeS52YWx1ZSA9PSAwKSB7XG4gICAgICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSAlIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfc2hpZnRfbGVmdFxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfc2hpZnRfbGVmdCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSA8PCB5KTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3NoaWZ0X3JpZ2h0XG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9zaGlmdF9yaWdodCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSA+Pj4geSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl90b19pbnRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl90b19pbnQoaSkge1xuICAgIHJldHVybiAoaS52YWx1ZSB8IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfdG9faW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfdG9faW50NjQoaSkge1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShpLnZhbHVlICYgMHhmZmZmZmYsIChpLnZhbHVlID4+PiAyNCkgJiAweGZmZmZmZiwgKGkudmFsdWUgPj4+IDMxKSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl90b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX3RvX3N0cmluZyhpKSB7XG4gICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKGkudmFsdWUudG9TdHJpbmcoKSk7XG59XG5cbi8vUHJvdmlkZXM6IFVJbnQ2NCBjb25zdFxudmFyIFVJbnQ2NCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFVJbnQ2NCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnZhbHVlID0geDsgLy8geCBpcyBhbiBNbEludDY0XG4gICAgfTtcbiAgICBVSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJpbnRlZ2Vyczp1aW50NjRcIjtcbiAgICByZXR1cm4gVUludDY0O1xufSkoKTtcblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2FkZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2FkZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9hZGQoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9kaXYoeCwgeSkge1xuICAgIGlmICh5LnZhbHVlLmlzWmVybygpKSB7XG4gICAgICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgICB9XG4gICAgLy8gQ29lcmNlIHRoZSBoaWdoIHBhcnRzIHRvIGJlIHVuc2lnbmVkIGJlZm9yZSBkaXZpc2lvbi5cbiAgICB4LnZhbHVlLmhpID0geC52YWx1ZS5oaSA+Pj4gMDtcbiAgICB5LnZhbHVlLmhpID0geS52YWx1ZS5oaSA+Pj4gMDtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NCh4LnZhbHVlLnVkaXZtb2QoeS52YWx1ZSkucXVvdGllbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbG9nYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FuZCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbG9nYW5kKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X2FuZCh4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9sb2dvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vciwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbG9nb3IoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfb3IoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbG9neG9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvciwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbG9neG9yKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X3hvcih4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9tYXhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9tYXgodW5pdCkge1xuICAgIHZhciB4ID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMHhmZmZmZmYsIDB4ZmZmZmZmLCAweGZmZmYpO1xuICAgIHguaGkgPSB4LmhpID4+PiAwO1xuICAgIHJldHVybiBuZXcgVUludDY0KHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbXVsKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X211bCh4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9vZl9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X29mX2ludChpKSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9vZl9pbnQzMihpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9vZl9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGksIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X29mX2ludDY0KGkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShpLmxvLCBpLm1pLCBpLmhpID4+PiAwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfZmFpbHdpdGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ludDY0X3VsdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludF9vZl9zdHJpbmcocywgbWF4X3ZhbCkge1xuICAgIC8vIE5vdGU6IFRoaXMgY29kZSBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiB0aGUgQyBmdW5jdGlvbi5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLFxuICAgIC8vIC0gb25seSBiYXNlLTEwIG51bWJlcnMgYXJlIGFjY2VwdGVkXG4gICAgLy8gLSBuZWdhdGl2ZSBudW1iZXJzIGFyZSBhY2NlcHRlZCBhbmQgY29lcmNlZCB0byAyJ3MtY29tcGxlbWVudCB1aW50NjRcbiAgICAvLyAtIHRoZSBsb25nZXN0IG51bWVyaWMgcHJlZml4IGlzIGFjY2VwdGVkLCBvbmx5IHJhaXNpbmcgYW4gZXJyb3Igd2hlbiB0aGVyZVxuICAgIC8vICAgaXNuJ3QgYSBudW1lcmljIHByZWZpeFxuICAgIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBuZWdhdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpID49IGxlbikge1xuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICB9XG4gICAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09PSA0NSkgeyAvLyBNaW51cyBzaWduXG4gICAgICAgIGkrKztcbiAgICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDMpIHsgLy8gUGx1cyBzaWduXG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgdmFyIG5vX2RpZ2l0cyA9IHRydWU7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIGhpZ2ggYnl0ZSBpcyB1bnNpZ25lZCBiZWZvcmUgZGl2aXNpb24uXG4gICAgbWF4X3ZhbC5oaSA9IG1heF92YWwuaGkgPj4+IDA7XG4gICAgdmFyIHRlbiA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMTApO1xuICAgIHZhciBtYXhfYmFzZV8xMCA9IG1heF92YWwudWRpdm1vZCh0ZW4pLnF1b3RpZW50O1xuICAgIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKDApO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgICAgICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub19kaWdpdHMgPSBmYWxzZTtcbiAgICAgICAgLy8gQW55IGRpZ2l0IGhlcmUgd291bGQgb3ZlcmZsb3cuIFBpbiB0byB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgICAgaWYgKGNhbWxfaW50NjRfdWx0KG1heF9iYXNlXzEwLCByZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4X3ZhbDtcbiAgICAgICAgfVxuICAgICAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICAgICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwodGVuLCByZXMpLCBkKTtcbiAgICAgICAgLy8gVGhlIGdpdmVuIGRpZ2l0IHdhcyB0b28gbGFyZ2UuIFBpbiB0byB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXhfdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub19kaWdpdHMpIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgfVxuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICAgIH1cbiAgICAvLyBTZXQgdGhlIGhpZ2ggYnl0ZSBhcyB1bnNpZ25lZC5cbiAgICByZXMuaGkgPSByZXMuaGkgPj4+IDA7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludF9vZl9zdHJpbmcsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgbWF4X3ZhbCA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4ZmZmZmZmLCAweGZmZmZmZiwgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBVSW50NjQoaW50ZWdlcnNfdWludF9vZl9zdHJpbmcocywgbWF4X3ZhbCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfcmVtXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBjYW1sX2ludDY0X2lzX3plcm8sIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3JlbSh4LCB5KSB7XG4gICAgaWYgKHkudmFsdWUuaXNaZXJvKCkpIHtcbiAgICAgICAgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICAgIH1cbiAgICAvLyBDb2VyY2UgdGhlIGhpZ2ggcGFydHMgdG8gYmUgdW5zaWduZWQgYmVmb3JlIGRpdmlzaW9uLlxuICAgIHgudmFsdWUuaGkgPSB4LnZhbHVlLmhpID4+PiAwO1xuICAgIHkudmFsdWUuaGkgPSB5LnZhbHVlLmhpID4+PiAwO1xuICAgIHJldHVybiBuZXcgVUludDY0KHgudmFsdWUudWRpdm1vZCh5LnZhbHVlKS5tb2R1bHVzKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3NoaWZ0X2xlZnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfc2hpZnRfbGVmdCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgudmFsdWUsIHkpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3NoaWZ0X3JpZ2h0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9zaGlmdF9yaWdodCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LnZhbHVlLCB5KSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc3ViLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9zdWIoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfc3ViKHgudmFsdWUsIHkudmFsdWUpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3RvX2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19pbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3RvX2ludChpKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfdG9faW50MzIoaS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF90b19pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF90b19pbnQ2NChpKSB7XG4gICAgaSA9IGkudmFsdWU7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGkubG8sIGkubWksIGkuaGkgfCAwKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3RvX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mb3JtYXQsIGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3RvX3N0cmluZyhpKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfZm9ybWF0KGNhbWxfbmV3X3N0cmluZyhcIiV1XCIpLCBpLnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSkpO1xufVxuICBcbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X21hcnNoYWxcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgICBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LnZhbHVlLCBzaXplcyk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2hhc2hcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9oYXNoKHYpIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9oYXNoKHYudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50OF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ4X29mX3N0cmluZyh4KSB7XG4gICAgdmFyIHkgPSBpbnRlZ2Vyc191aW50MzJfb2Zfc3RyaW5nKHgpO1xuICAgIHJldHVybiAoeC52YWx1ZSAmIDB4RkYpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50X3NpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnRfc2l6ZSh1bml0KSB7XG4gICAgcmV0dXJuIDQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3Vsb25nX3NpemVcbmZ1bmN0aW9uIGludGVnZXJzX3Vsb25nX3NpemUodW5pdCkge1xuICAgIHJldHVybiA0O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191bG9uZ2xvbmdfc2l6ZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWxvbmdsb25nX3NpemUodW5pdCkge1xuICAgIHJldHVybiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191bnNpZ25lZF9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHMsIGludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplLCBpbnRlZ2Vyc191aW50MTZfZGVzZXJpYWxpemUsIGludGVnZXJzX3VpbnQzMl9zZXJpYWxpemUsIGludGVnZXJzX3VpbnQzMl9kZXNlcmlhbGl6ZSwgaW50ZWdlcnNfdWludDMyX2hhc2gsIGludGVnZXJzX3VpbnQzMl9jb21wYXJlLCBpbnRlZ2Vyc191aW50NjRfY29tcGFyZSwgaW50ZWdlcnNfdWludDY0X2hhc2gsIGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsLCBpbnRlZ2Vyc191aW50NjRfdW5tYXJzaGFsXG5mdW5jdGlvbiBpbnRlZ2Vyc191bnNpZ25lZF9pbml0KHVuaXQpIHtcbiAgICBjYW1sX2N1c3RvbV9vcHNbXCJpbnRlZ2Vyczp1aW50OFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDhfZGVzZXJpYWxpemVcbiAgICAsIGZpeGVkX2xlbmd0aDogMSB9O1xuICAgIGNhbWxfY3VzdG9tX29wc1tcImludGVnZXJzOnVpbnQxNlwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDE2X2Rlc2VyaWFsaXplXG4gICAgLCBmaXhlZF9sZW5ndGg6IDIgfTtcbiAgICBjYW1sX2N1c3RvbV9vcHNbXCJpbnRlZ2Vyczp1aW50MzJcIl0gPVxuICAgIHsgc2VyaWFsaXplOiBpbnRlZ2Vyc191aW50MzJfc2VyaWFsaXplXG4gICAgLCBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDMyX2Rlc2VyaWFsaXplXG4gICAgLCBmaXhlZF9sZW5ndGg6IDRcbiAgICAsIGhhc2g6IGludGVnZXJzX3VpbnQzMl9oYXNoXG4gICAgLCBjb21wYXJlOiBpbnRlZ2Vyc191aW50MzJfY29tcGFyZSB9O1xuICAgIGNhbWxfY3VzdG9tX29wc1tcImludGVnZXJzOnVpbnQ2NFwiXSA9XG4gICAgeyBzZXJpYWxpemU6IGludGVnZXJzX3VpbnQ2NF9tYXJzaGFsXG4gICAgLCBkZXNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbFxuICAgICwgaGFzaDogaW50ZWdlcnNfdWludDY0X2hhc2hcbiAgICAsIGNvbXBhcmU6IGludGVnZXJzX3VpbnQ2NF9jb21wYXJlIH07XG4gICAgcmV0dXJuIHVuaXQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VzaG9ydF9zaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc191c2hvcnRfc2l6ZSh1bml0KSB7XG4gICAgcmV0dXJuIDQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9zZXJpYWxpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9zZXJpYWxpemUod3JpdGVyLCB2LCBzaXplKSB7XG4gICAgd3JpdGVyLndyaXRlKDMyLCB2LnZhbHVlKTtcbiAgICBzaXplWzBdID0gNDtcbiAgICBzaXplWzFdID0gNDtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDhfZGVzZXJpYWxpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSkge1xuICAgIHNpemVbMF0gPSAxO1xuICAgIHJldHVybiByZWFkZXIucmVhZDh1KCk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQxNl9kZXNlcmlhbGl6ZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDE2X2Rlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSkge1xuICAgIHNpemVbMF0gPSAyO1xuICAgIHJldHVybiByZWFkZXIucmVhZDE2dSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2Rlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSkge1xuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiBuZXcgVUludDMyKHJlYWRlci5yZWFkMzJ1KCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfaGFzaFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2hhc2godikge1xuICAgIHJldHVybiB2LnZhbHVlO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfY29tcGFyZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2NvbXBhcmUoeCwgeSkge1xuICAgIGlmICh4LnZhbHVlID4geS52YWx1ZSkgeyByZXR1cm4gMTsgfVxuICAgIGlmICh4LnZhbHVlIDwgeS52YWx1ZSkgeyByZXR1cm4gLTE7IH1cbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY29tcGFyZVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2NvbXBhcmUoeCwgeSkge1xuICAgIHgudmFsdWUuaGkgPSB4LnZhbHVlLmhpID4+PiAwO1xuICAgIHkudmFsdWUuaGkgPSB5LnZhbHVlLmhpID4+PiAwO1xuICAgIHJldHVybiB4LnZhbHVlLnVjb21wYXJlKHkudmFsdWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBnLkludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gZy5JbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IGcuVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIga2luZDtcbiAgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDhBcnJheSkga2luZCA9IDI7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDE2QXJyYXkpIGtpbmQgPSA0O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICByZXR1cm4ga2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2FsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2FsbG9jKF8sc2l6ZSl7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZSgxMiwgMCwgWzAsc2l6ZV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViXG5mdW5jdGlvbiBiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViKHgpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMSwgY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3R1YihzMSwgaTEsIHMyLCBpMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgY2FtbF9iYV9zZXRfMShzMixpMiArIGksY2FtbF9iYV9nZXRfMShzMSxpMSArIGkpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldCwgY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWIodl9zdHIsIHZfc3JjX3Bvcywgdl9ic3RyLCB2X2RzdF9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSBjYW1sX2JhX3NldF8xKHZfYnN0cix2X2RzdF9wb3MgKyBpLGNhbWxfYnl0ZXNfZ2V0KHZfc3RyLHZfc3JjX3BvcyArIGkpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldCwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIodl9ic3RyLCB2X3NyY19wb3MsIHZfc3RyLCB2X2RzdF9wb3MsIHZfbGVuKXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspe1xuICAgIHZhciBjID0gY2FtbF9iYV9nZXRfMSh2X2JzdHIsdl9zcmNfcG9zICsgaSk7XG4gICAgY2FtbF9ieXRlc19zZXQodl9zdHIsdl9kc3RfcG9zICsgaSxjKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXQsIGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1Yih2X3N0ciwgdl9zcmNfcG9zLCB2X2JzdHIsIHZfZHN0X3Bvcywgdl9sZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIGNhbWxfYmFfc2V0XzEodl9ic3RyLHZfZHN0X3BvcyArIGksY2FtbF9zdHJpbmdfZ2V0KHZfc3RyLHZfc3JjX3BvcyArIGkpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tZW1zZXRfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbXNldF9zdHViKGJpZ3N0cmluZywgdl9wb3MsIHZfbGVuLCB2X2NoYXIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgY2FtbF9iYV9zZXRfMShiaWdzdHJpbmcsIHZfcG9zICsgaSwgdl9jaGFyKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtY21wX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tZW1jbXBfc3R1Yih2X3MxLCB2X3MxX3Bvcywgdl9zMiwgdl9zMl9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHZfczEsdl9zMV9wb3MgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEodl9zMix2X3MyX3BvcyArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbnZhciBpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmcgPSBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZmluZFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2ZpbmQoYnMsIGNociwgcG9zLCBsZW4pe1xuICB3aGlsZShsZW4gPiAwKXtcbiAgICBpZihjYW1sX2JhX2dldF8xKGJzLHBvcykgPT0gY2hyKSByZXR1cm4gcG9zO1xuICAgIHBvcysrO1xuICAgIGxlbi0tO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2xleF9hcnJheVxuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIC8vIHZhciBfdGJsX25hbWVzX2NvbnN0ID0gMTU7XG4gIC8vIHZhciBfdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIHN3aXRjaChjbWQpIHtcbiAgICBjYXNlIDA6Ly9TVEFSVDpcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGVycmZsYWcgPSAwO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDY6Ly9sb29wOlxuICAgICAgbiA9IHRhYmxlcy5kZWZyZWRbc3RhdGVdO1xuICAgICAgaWYgKG4gIT0gMCkgeyBjbWQgPSByZWR1Y2U7IGJyZWFrOyB9XG4gICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID49IDApIHsgY21kID0gdGVzdHNoaWZ0OyBicmVhazsgfVxuICAgICAgcmVzID0gUkVBRF9UT0tFTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgbGV4ZXIgYW5kIHVwZGF0ZXMgKi9cbiAgICAgIC8qIHN5bWJfc3RhcnQgYW5kIHN5bWJfZW5kICovXG4gICAgY2FzZSAxOi8vVE9LRU5fUkVBRDpcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9ibG9ja11bYXJnWzBdICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSBhcmdbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9jb25zdF1bYXJnICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGNtZCA9IHNoaWZ0X3JlY292ZXI7IGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3AgPD0gZW52W2Vudl9zdGFja2Jhc2VdKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID09IDApIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBzcCsrO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDI6Ly9TVEFDS1NfR1JPV05fMTpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9sdmFsXTtcbiAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9zdGFydF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF07XG4gICAgICBjbWQgPSBsb29wO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDEwOi8vcmVkdWNlOlxuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vRHVtbXkgZnVuY3Rpb24hXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGYpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA+IDApe1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW3VuZGVmaW5lZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkgJiYgZi5sZW5ndGggPT0gYXJpdHkpIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLGFyZ3MpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBbMV0pXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHBvcnRfdmFyXG5mdW5jdGlvbiBjYW1sX2pzX2V4cG9ydF92YXIgKCl7XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNcbiAgZWxzZVxuICAgIHJldHVybiBqb29fZ2xvYmFsX29iamVjdDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSh1bml0KXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYodHlwZW9mIGcuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG4iLCIvL1Byb3ZpZGVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdGltZVxuLy9SZXF1aXJlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHVuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIHVuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICBkLmdldERhdGUoKSwgZC5nZXRNb250aCgpLCBkLmdldEZ1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0RGF5KCksIGRveSxcbiAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X21rdGltZSh0bSl7XG4gIHZhciBkID0gKG5ldyBEYXRlKHRtWzZdKzE5MDAsdG1bNV0sdG1bNF0sdG1bM10sdG1bMl0sdG1bMV0pKS5nZXRUaW1lKCk7XG4gIHZhciB0ID0gTWF0aC5mbG9vcihkIC8gMTAwMCk7XG4gIHZhciB0bTIgPSB1bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuXG4vL1Byb3ZpZGVzOiB3aW5fc3RhcnR1cCBjb25zdFxuZnVuY3Rpb24gd2luX3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5fY2xlYW51cCBjb25zdFxuZnVuY3Rpb24gd2luX2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5faGFuZGxlX2ZkIGNvbnN0XG5mdW5jdGlvbiB3aW5faGFuZGxlX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaXNhdHR5IFxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHVuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG4gICAgcmV0dXJuIHR0eS5pc2F0dHkoZmlsZURlc2NyaXB0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhvYmopKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHN3aXRjaCAob2JqLnQgJiA2KSB7XG4gICAgICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMob2JqKTtcbiAgICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgICAgZm9yICh2YXIgYiA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgICAgICBmb3IgKHZhciBhID0gb2JqLmMsIGwgPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvYmopLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhvYmopKSB7XG4gICAgICAgIHZhciBqc2J5dGVzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvYmopO1xuICAgICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYiA9IG9iaiwgbCA9IG9iai5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICBzd2l0Y2ggKHYudCAmIDYpIHtcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzICh2KTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgdi5jKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCB2LmMpO1xuICB9XG4gIHJldHVybiBoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaGFzaCAoY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTsgcmQgPSAwOyB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHYgJiYgdi5jYW1sX2N1c3RvbSl7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGhoID0gY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2godik7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludCAoaCwgaGgpO1xuICAgICAgICBudW0gLS07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2WzJdKTtcbiAgICAgICAgbnVtLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgcXVldWVbLS1yZF0gPSB2WzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gKHZ8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2K3YrMSk7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICt2KSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCx2KTtcbiAgICAgIG51bS0tO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSxzdGFja19zaXplLHRyYWNrZXIpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGcub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuXG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpudWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ5dGVzO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBieXRlcyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LGJ5dGVzLDAsbGVuKTtcbiAgfVxuICB2YXIgc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpO1xuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmZmVyKSxvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldCAoYXJyYXksIGluZGV4KSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5W2luZGV4KzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGFycmF5W29mcytpKzFdID0gdjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvLy8vLy8vLy8gQklOX1BST1RcblxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9idWZfZmxvYXRfYXJyYXlfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9zZXQsIGNhbWxfYmFfZ2V0XzFcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfYnVmX2Zsb2F0X2FycmF5X3N0dWIodl9zcmNfcG9zLCB2X2J1Ziwgdl9kc3RfcG9zLCB2X2Fyciwgdl9sZW4pe1xuICB2YXIgYztcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKyl7XG4gICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0Wzctal0gPSBjYW1sX2JhX2dldF8xKHZfYnVmLHZfc3JjX3BvcytqKyhpKjgpKTtcbiAgICBjID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzICh0KSk7XG4gICAgY2FtbF9hcnJheV9zZXQodl9hcnIsdl9kc3RfcG9zK2ksYyk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX2J5dGVzX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfYnVmX2J5dGVzX3N0dWIodl9zcmNfcG9zLCB2X2J1Ziwgdl9kc3RfcG9zLCB2X3N0ciwgdl9sZW4pe1xuICB2YXIgYztcbiAgZm9yKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspe1xuICAgIGMgPSBjYW1sX2JhX2dldF8xKHZfYnVmLHZfc3JjX3BvcytpKTtcbiAgICBjYW1sX3N0cmluZ191bnNhZmVfc2V0KHZfc3RyLHZfZHN0X3BvcytpLGMpO1xuICB9XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2dldCwgY2FtbF9iYV9zZXRfMVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViKHZfc3JjX3Bvcywgdl9hcnIsIHZfZHN0X3Bvcywgdl9idWYsIHZfbGVuKXtcbiAgdmFyIGM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKXtcbiAgICB2YXIgZiA9IGNhbWxfYXJyYXlfZ2V0KHZfYXJyLHZfc3JjX3BvcytpKTtcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGYpKTtcbiAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspXG4gICAgICBjYW1sX2JhX3NldF8xKHZfYnVmLHZfZHN0X3BvcytqKyhpKjgpLCBhWzctal0pO1xuICB9XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWIgKHZfc3JjX3Bvcywgdl9zdHIsIHZfZHN0X3Bvcywgdl9idWYsIHZfbGVuKXtcbiAgdmFyIGM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKXtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2X3N0cix2X3NyY19wb3MraSk7XG4gICAgY2FtbF9iYV9zZXRfMSh2X2J1Zix2X2RzdF9wb3MraSxjKTtcbiAgfVxuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YiAodl9zcmNfcG9zLCB2X3N0ciwgdl9kc3RfcG9zLCB2X2J1Ziwgdl9sZW4pe1xuICB2YXIgYztcbiAgZm9yKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspe1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHZfc3RyLHZfc3JjX3BvcytpKTtcbiAgICBjYW1sX2JhX3NldF8xKHZfYnVmLHZfZHN0X3BvcytpLGMpO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfYmFfc2V0XzEsIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXJcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfYnVmX3N0dWIgKHZfc3JjX3Bvcywgdl9zcmMsIHZfZHN0X3Bvcywgdl9kc3QsIHZfbGVuKXtcbiAgdmFyIHZfc3JjMiA9IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIodl9zcmMuZGF0YS5idWZmZXIpO1xuICB2YXIgdl9kc3QyID0gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcih2X2RzdC5kYXRhLmJ1ZmZlcik7XG4gIHZhciBjO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKyl7XG4gICAgYyA9IGNhbWxfYmFfZ2V0XzEodl9zcmMyLHZfc3JjX3BvcytpKTtcbiAgICBjYW1sX2JhX3NldF8xKHZfZHN0Mix2X2RzdF9wb3MraSxjKTtcbiAgfVxuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9sYXp5X21ha2VfZm9yd2FyZCAodikgeyByZXR1cm4gWzI1MCwgdl07IH1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gbnVsbCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cbiIsIi8vSW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzIzRlOTliMTViNzk1MTMzOGYxNjQ3MjgzNzdjOTA2Y2FhZTVhNzgyMDJcblxuLy9Qcm92aWRlczogYmlnSW50IGNvbnN0XG52YXIgYmlnSW50ID0gKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBCQVNFID0gMWU3LFxuICAgICAgICBMT0dfQkFTRSA9IDcsXG4gICAgICAgIE1BWF9JTlQgPSA5MDA3MTk5MjU0NzQwOTkyLFxuICAgICAgICBNQVhfSU5UX0FSUiA9IHNtYWxsVG9BcnJheShNQVhfSU5UKSxcbiAgICAgICAgREVGQVVMVF9BTFBIQUJFVCA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5cbiAgICB2YXIgQmlnSW50ID0gam9vX2dsb2JhbF9vYmplY3QuQmlnSW50O1xuXG4gICAgdmFyIHN1cHBvcnRzTmF0aXZlQmlnSW50ID0gdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiO1xuXG4gICAgZnVuY3Rpb24gSW50ZWdlcih2LCByYWRpeCwgYWxwaGFiZXQsIGNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgaWYgKHR5cGVvZiByYWRpeCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuICtyYWRpeCA9PT0gMTAgJiYgIWFscGhhYmV0ID8gcGFyc2VWYWx1ZSh2KSA6IHBhcnNlQmFzZSh2LCByYWRpeCwgYWxwaGFiZXQsIGNhc2VTZW5zaXRpdmUpO1xuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaWduID0gc2lnbjtcbiAgICAgICAgdGhpcy5pc1NtYWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FtbF9jdXN0b20gPSAnX3onO1xuICAgIH1cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xuXG4gICAgZnVuY3Rpb24gU21hbGxJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaWduID0gdmFsdWUgPCAwO1xuICAgICAgICB0aGlzLmlzU21hbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbWxfY3VzdG9tID0gJ196JztcbiAgICB9XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xuXG4gICAgZnVuY3Rpb24gTmF0aXZlQmlnSW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYW1sX2N1c3RvbSA9ICdfeic7XG4gICAgfVxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcblxuICAgIGZ1bmN0aW9uIGlzUHJlY2lzZShuKSB7XG4gICAgICAgIHJldHVybiAtTUFYX0lOVCA8IG4gJiYgbiA8IE1BWF9JTlQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc21hbGxUb0FycmF5KG4pIHsgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgZG9lc24ndCByZWZlcmVuY2UgQkFTRSwgbmVlZCB0byBjaGFuZ2UgdGhpcyBmdW5jdGlvbiBpZiBCQVNFIGNoYW5nZXNcbiAgICAgICAgaWYgKG4gPCAxZTcpXG4gICAgICAgICAgICByZXR1cm4gW25dO1xuICAgICAgICBpZiAobiA8IDFlMTQpXG4gICAgICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNyldO1xuICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNykgJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlMTQpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheVRvU21hbGwoYXJyKSB7IC8vIElmIEJBU0UgY2hhbmdlcyB0aGlzIGZ1bmN0aW9uIG1heSBuZWVkIHRvIGNoYW5nZVxuICAgICAgICB0cmltKGFycik7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgNCAmJiBjb21wYXJlQWJzKGFyciwgTUFYX0lOVF9BUlIpIDwgMCkge1xuICAgICAgICAgICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGFyclswXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBhcnJbMF0gKyBhcnJbMV0gKiBCQVNFO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBhcnJbMF0gKyAoYXJyWzFdICsgYXJyWzJdICogQkFTRSkgKiBCQVNFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpbSh2KSB7XG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XG4gICAgICAgIHdoaWxlICh2Wy0taV0gPT09IDApO1xuICAgICAgICB2Lmxlbmd0aCA9IGkgKyAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aCkgeyAvLyBmdW5jdGlvbiBzaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBZYWZmbGUncyBsaWJyYXJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9ZYWZmbGUvQmlnSW50ZWdlclxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB4W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShuKSB7XG4gICAgICAgIGlmIChuID4gMCkgcmV0dXJuIE1hdGguZmxvb3Iobik7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGFuZCBiIGFyZSBhcnJheXMgd2l0aCBhLmxlbmd0aCA+PSBiLmxlbmd0aFxuICAgICAgICB2YXIgbF9hID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBsX2IgPSBiLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobF9hKSxcbiAgICAgICAgICAgIGNhcnJ5ID0gMCxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgc3VtLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbF9iOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBiW2ldICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA+PSBiYXNlID8gMSA6IDA7XG4gICAgICAgICAgICByW2ldID0gc3VtIC0gY2FycnkgKiBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbF9hKSB7XG4gICAgICAgICAgICBzdW0gPSBhW2ldICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA9PT0gYmFzZSA/IDEgOiAwO1xuICAgICAgICAgICAgcltpKytdID0gc3VtIC0gY2FycnkgKiBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSA+IDApIHIucHVzaChjYXJyeSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEFueShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+PSBiLmxlbmd0aCkgcmV0dXJuIGFkZChhLCBiKTtcbiAgICAgICAgcmV0dXJuIGFkZChiLCBhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTbWFsbChhLCBjYXJyeSkgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGNhcnJ5IGlzIG51bWJlciB3aXRoIDAgPD0gY2FycnkgPCBNQVhfSU5UXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBzdW0sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gLSBiYXNlICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3Ioc3VtIC8gYmFzZSk7XG4gICAgICAgICAgICByW2ldID0gc3VtIC0gY2FycnkgKiBiYXNlO1xuICAgICAgICAgICAgY2FycnkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGEsIE1hdGguYWJzKGIpKSwgdGhpcy5zaWduKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkQW55KGEsIGIpLCB0aGlzLnNpZ24pO1xuICAgIH07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUucGx1cyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZDtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChuLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoYSArIGIpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhICsgYik7XG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KE1hdGguYWJzKGIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYiwgTWF0aC5hYnMoYSkpLCBhIDwgMCk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnBsdXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmFkZDtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSArIHBhcnNlVmFsdWUodikudmFsdWUpO1xuICAgIH1cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnBsdXMgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFkZDtcblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHsgLy8gYXNzdW1lcyBhIGFuZCBiIGFyZSBhcnJheXMgd2l0aCBhID49IGJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGFfbCksXG4gICAgICAgICAgICBib3Jyb3cgPSAwLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYl9sOyBpKyspIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93IC0gYltpXTtcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgIGRpZmZlcmVuY2UgKz0gYmFzZTtcbiAgICAgICAgICAgICAgICBib3Jyb3cgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGJvcnJvdyA9IDA7XG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBiX2w7IGkgPCBhX2w7IGkrKykge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gLSBib3Jyb3c7XG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIGRpZmZlcmVuY2UgKz0gYmFzZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IGFfbDsgaSsrKSB7XG4gICAgICAgICAgICByW2ldID0gYVtpXTtcbiAgICAgICAgfVxuICAgICAgICB0cmltKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdEFueShhLCBiLCBzaWduKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGNvbXBhcmVBYnMoYSwgYikgPj0gMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdWJ0cmFjdChhLCBiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYiwgYSk7XG4gICAgICAgICAgICBzaWduID0gIXNpZ247XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBhcnJheVRvU21hbGwodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoc2lnbikgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFNtYWxsKGEsIGIsIHNpZ24pIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIDAgPD0gYiA8IE1BWF9JTlRcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXG4gICAgICAgICAgICBjYXJyeSA9IC1iLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGRpZmZlcmVuY2UgLyBiYXNlKTtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgJT0gYmFzZTtcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlIDwgMCA/IGRpZmZlcmVuY2UgKyBiYXNlIDogZGlmZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgICByID0gYXJyYXlUb1NtYWxsKHIpO1xuICAgICAgICBpZiAodHlwZW9mIHIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChzaWduKSByID0gLXI7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihyKTtcbiAgICAgICAgfSByZXR1cm4gbmV3IEJpZ0ludGVnZXIociwgc2lnbik7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChhLCBNYXRoLmFicyhiKSwgdGhpcy5zaWduKTtcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0QW55KGEsIGIsIHRoaXMuc2lnbik7XG4gICAgfTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW51cyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSAtIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKGIsIE1hdGguYWJzKGEpLCBhID49IDApO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5taW51cyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q7XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAtIHBhcnNlVmFsdWUodikudmFsdWUpO1xuICAgIH1cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1pbnVzID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zdWJ0cmFjdDtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsICF0aGlzLnNpZ24pO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduO1xuICAgICAgICB2YXIgc21hbGwgPSBuZXcgU21hbGxJbnRlZ2VyKC10aGlzLnZhbHVlKTtcbiAgICAgICAgc21hbGwuc2lnbiA9ICFzaWduO1xuICAgICAgICByZXR1cm4gc21hbGw7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoLXRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihNYXRoLmFicyh0aGlzLnZhbHVlKSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSA+PSAwID8gdGhpcy52YWx1ZSA6IC10aGlzLnZhbHVlKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5TG9uZyhhLCBiKSB7XG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxuICAgICAgICAgICAgbCA9IGFfbCArIGJfbCxcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsKSxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgcHJvZHVjdCwgY2FycnksIGksIGFfaSwgYl9qO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYV9sOyArK2kpIHtcbiAgICAgICAgICAgIGFfaSA9IGFbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJfbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgYl9qID0gYltqXTtcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gYV9pICogYl9qICsgcltpICsgal07XG4gICAgICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XG4gICAgICAgICAgICAgICAgcltpICsgaiArIDFdICs9IGNhcnJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyaW0ocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5U21hbGwoYSwgYikgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGIgaXMgbnVtYmVyIHdpdGggfGJ8IDwgQkFTRVxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgY2FycnkgPSAwLFxuICAgICAgICAgICAgcHJvZHVjdCwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcHJvZHVjdCA9IGFbaV0gKiBiICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xuICAgICAgICAgICAgcltpXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgcltpKytdID0gY2FycnkgJSBiYXNlO1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hpZnRMZWZ0KHgsIG4pIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHIucHVzaCgwKTtcbiAgICAgICAgcmV0dXJuIHIuY29uY2F0KHgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5S2FyYXRzdWJhKHgsIHkpIHtcbiAgICAgICAgdmFyIG4gPSBNYXRoLm1heCh4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChuIDw9IDMwKSByZXR1cm4gbXVsdGlwbHlMb25nKHgsIHkpO1xuICAgICAgICBuID0gTWF0aC5jZWlsKG4gLyAyKTtcblxuICAgICAgICB2YXIgYiA9IHguc2xpY2UobiksXG4gICAgICAgICAgICBhID0geC5zbGljZSgwLCBuKSxcbiAgICAgICAgICAgIGQgPSB5LnNsaWNlKG4pLFxuICAgICAgICAgICAgYyA9IHkuc2xpY2UoMCwgbik7XG5cbiAgICAgICAgdmFyIGFjID0gbXVsdGlwbHlLYXJhdHN1YmEoYSwgYyksXG4gICAgICAgICAgICBiZCA9IG11bHRpcGx5S2FyYXRzdWJhKGIsIGQpLFxuICAgICAgICAgICAgYWJjZCA9IG11bHRpcGx5S2FyYXRzdWJhKGFkZEFueShhLCBiKSwgYWRkQW55KGMsIGQpKTtcblxuICAgICAgICB2YXIgcHJvZHVjdCA9IGFkZEFueShhZGRBbnkoYWMsIHNoaWZ0TGVmdChzdWJ0cmFjdChzdWJ0cmFjdChhYmNkLCBhYyksIGJkKSwgbikpLCBzaGlmdExlZnQoYmQsIDIgKiBuKSk7XG4gICAgICAgIHRyaW0ocHJvZHVjdCk7XG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIGEgc3VyZmFjZSBmaXQgb2YgYSBncmFwaCBwbG90dGluZyB0aGUgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZVxuICAgIC8vIGJldHdlZW4gbG9uZyBtdWx0aXBsaWNhdGlvbiBhbmQga2FyYXRzdWJhIG11bHRpcGxpY2F0aW9uIHZlcnN1cyB0aGUgbGVuZ3RocyBvZiB0aGUgdHdvIGFycmF5cy5cbiAgICBmdW5jdGlvbiB1c2VLYXJhdHN1YmEobDEsIGwyKSB7XG4gICAgICAgIHJldHVybiAtMC4wMTIgKiBsMSAtIDAuMDEyICogbDIgKyAwLjAwMDAxNSAqIGwxICogbDIgPiAwO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlLFxuICAgICAgICAgICAgc2lnbiA9IHRoaXMuc2lnbiAhPT0gbi5zaWduLFxuICAgICAgICAgICAgYWJzO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgICAgICBpZiAoYiA9PT0gMSkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMoYik7XG4gICAgICAgICAgICBpZiAoYWJzIDwgQkFTRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGEsIGFicyksIHNpZ24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShhYnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VLYXJhdHN1YmEoYS5sZW5ndGgsIGIubGVuZ3RoKSkgLy8gS2FyYXRzdWJhIGlzIG9ubHkgZmFzdGVyIGZvciBjZXJ0YWluIGFycmF5IHNpemVzXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlLYXJhdHN1YmEoYSwgYiksIHNpZ24pO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGEsIGIpLCBzaWduKTtcbiAgICB9O1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5U21hbGxBbmRBcnJheShhLCBiLCBzaWduKSB7IC8vIGEgPj0gMFxuICAgICAgICBpZiAoYSA8IEJBU0UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGIsIGEpLCBzaWduKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGIsIHNtYWxsVG9BcnJheShhKSksIHNpZ24pO1xuICAgIH1cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoaXNQcmVjaXNlKGEudmFsdWUgKiB0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYS52YWx1ZSAqIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoTWF0aC5hYnMoYS52YWx1ZSksIHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSksIHRoaXMuc2lnbiAhPT0gYS5zaWduKTtcbiAgICB9O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgIGlmIChhLnZhbHVlID09PSAxKSByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSwgdGhpcy52YWx1ZSwgdGhpcy5zaWduICE9PSBhLnNpZ24pO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpLl9tdWx0aXBseUJ5U21hbGwodGhpcyk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRpbWVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICogcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XG4gICAgfVxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudGltZXMgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm11bHRpcGx5O1xuXG4gICAgZnVuY3Rpb24gc3F1YXJlKGEpIHtcbiAgICAgICAgLy9jb25zb2xlLmFzc2VydCgyICogQkFTRSAqIEJBU0UgPCBNQVhfSU5UKTtcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsICsgbCksXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIHByb2R1Y3QsIGNhcnJ5LCBpLCBhX2ksIGFfajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgYV9pID0gYVtpXTtcbiAgICAgICAgICAgIGNhcnJ5ID0gMCAtIGFfaSAqIGFfaTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYV9qID0gYVtqXTtcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gMiAqIChhX2kgKiBhX2opICsgcltpICsgal0gKyBjYXJyeTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xuICAgICAgICAgICAgICAgIHJbaSArIGpdID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJbaSArIGxdID0gY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpbShyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHRoaXMudmFsdWUpLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlICogdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSkpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZShzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpKSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKiB0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXZNb2QxKGEsIGIpIHsgLy8gTGVmdCBvdmVyIGZyb20gcHJldmlvdXMgdmVyc2lvbi4gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMiBvbiBzbWFsbGVyIGlucHV0IHNpemVzLlxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlQXJyYXkoYi5sZW5ndGgpLFxuICAgICAgICAgICAgZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0ID0gYltiX2wgLSAxXSxcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb25cbiAgICAgICAgICAgIGxhbWJkYSA9IE1hdGguY2VpbChiYXNlIC8gKDIgKiBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpKSxcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IG11bHRpcGx5U21hbGwoYSwgbGFtYmRhKSxcbiAgICAgICAgICAgIGRpdmlzb3IgPSBtdWx0aXBseVNtYWxsKGIsIGxhbWJkYSksXG4gICAgICAgICAgICBxdW90aWVudERpZ2l0LCBzaGlmdCwgY2FycnksIGJvcnJvdywgaSwgbCwgcTtcbiAgICAgICAgaWYgKHJlbWFpbmRlci5sZW5ndGggPD0gYV9sKSByZW1haW5kZXIucHVzaCgwKTtcbiAgICAgICAgZGl2aXNvci5wdXNoKDApO1xuICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBkaXZpc29yW2JfbCAtIDFdO1xuICAgICAgICBmb3IgKHNoaWZ0ID0gYV9sIC0gYl9sOyBzaGlmdCA+PSAwOyBzaGlmdC0tKSB7XG4gICAgICAgICAgICBxdW90aWVudERpZ2l0ID0gYmFzZSAtIDE7XG4gICAgICAgICAgICBpZiAocmVtYWluZGVyW3NoaWZ0ICsgYl9sXSAhPT0gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSB7XG4gICAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IE1hdGguZmxvb3IoKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gKiBiYXNlICsgcmVtYWluZGVyW3NoaWZ0ICsgYl9sIC0gMV0pIC8gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHF1b3RpZW50RGlnaXQgPD0gYmFzZSAtIDFcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIGJvcnJvdyA9IDA7XG4gICAgICAgICAgICBsID0gZGl2aXNvci5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gcXVvdGllbnREaWdpdCAqIGRpdmlzb3JbaV07XG4gICAgICAgICAgICAgICAgcSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSAoY2FycnkgLSBxICogYmFzZSk7XG4gICAgICAgICAgICAgICAgY2FycnkgPSBxO1xuICAgICAgICAgICAgICAgIGlmIChib3Jyb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93ICsgYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBib3Jyb3c7XG4gICAgICAgICAgICAgICAgICAgIGJvcnJvdyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGJvcnJvdyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgLT0gMTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjYXJyeSArPSByZW1haW5kZXJbc2hpZnQgKyBpXSAtIGJhc2UgKyBkaXZpc29yW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FycnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGNhcnJ5ICsgYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2Fycnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9ycm93ICs9IGNhcnJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3NoaWZ0XSA9IHF1b3RpZW50RGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVub3JtYWxpemF0aW9uXG4gICAgICAgIHJlbWFpbmRlciA9IGRpdk1vZFNtYWxsKHJlbWFpbmRlciwgbGFtYmRhKVswXTtcbiAgICAgICAgcmV0dXJuIFthcnJheVRvU21hbGwocmVzdWx0KSwgYXJyYXlUb1NtYWxsKHJlbWFpbmRlcildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdk1vZDIoYSwgYikgeyAvLyBJbXBsZW1lbnRhdGlvbiBpZGVhIHNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIFNpbGVudCBNYXR0J3MgbGlicmFyeSBodHRwOi8vc2lsZW50bWF0dC5jb20vYmlnaW50ZWdlci9cbiAgICAgICAgLy8gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMSBvbiBsYXJnZXIgaW5wdXQgc2l6ZXMuXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBwYXJ0ID0gW10sXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIGd1ZXNzLCB4bGVuLCBoaWdoeCwgaGlnaHksIGNoZWNrO1xuICAgICAgICB3aGlsZSAoYV9sKSB7XG4gICAgICAgICAgICBwYXJ0LnVuc2hpZnQoYVstLWFfbF0pO1xuICAgICAgICAgICAgdHJpbShwYXJ0KTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKHBhcnQsIGIpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGxlbiA9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgaGlnaHggPSBwYXJ0W3hsZW4gLSAxXSAqIGJhc2UgKyBwYXJ0W3hsZW4gLSAyXTtcbiAgICAgICAgICAgIGhpZ2h5ID0gYltiX2wgLSAxXSAqIGJhc2UgKyBiW2JfbCAtIDJdO1xuICAgICAgICAgICAgaWYgKHhsZW4gPiBiX2wpIHtcbiAgICAgICAgICAgICAgICBoaWdoeCA9IChoaWdoeCArIDEpICogYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGd1ZXNzID0gTWF0aC5jZWlsKGhpZ2h4IC8gaGlnaHkpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNoZWNrID0gbXVsdGlwbHlTbWFsbChiLCBndWVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVBYnMoY2hlY2ssIHBhcnQpIDw9IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGd1ZXNzLS07XG4gICAgICAgICAgICB9IHdoaWxlIChndWVzcyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChndWVzcyk7XG4gICAgICAgICAgICBwYXJ0ID0gc3VidHJhY3QocGFydCwgY2hlY2spO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChwYXJ0KV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2TW9kU21hbGwodmFsdWUsIGxhbWJkYSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgcXVvdGllbnQgPSBjcmVhdGVBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBpLCBxLCByZW1haW5kZXIsIGRpdmlzb3I7XG4gICAgICAgIHJlbWFpbmRlciA9IDA7XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBkaXZpc29yID0gcmVtYWluZGVyICogYmFzZSArIHZhbHVlW2ldO1xuICAgICAgICAgICAgcSA9IHRydW5jYXRlKGRpdmlzb3IgLyBsYW1iZGEpO1xuICAgICAgICAgICAgcmVtYWluZGVyID0gZGl2aXNvciAtIHEgKiBsYW1iZGE7XG4gICAgICAgICAgICBxdW90aWVudFtpXSA9IHEgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIHJlbWFpbmRlciB8IDBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdk1vZEFueShzZWxmLCB2KSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIGlmIChzdXBwb3J0c05hdGl2ZUJpZ0ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgTmF0aXZlQmlnSW50KHNlbGYudmFsdWUgLyBuLnZhbHVlKSwgbmV3IE5hdGl2ZUJpZ0ludChzZWxmLnZhbHVlICUgbi52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gc2VsZi52YWx1ZSwgYiA9IG4udmFsdWU7XG4gICAgICAgIHZhciBxdW90aWVudDtcbiAgICAgICAgaWYgKGIgPT09IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXZpZGUgYnkgemVyb1wiKTtcbiAgICAgICAgaWYgKHNlbGYuaXNTbWFsbCkge1xuICAgICAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZShhIC8gYikpLCBuZXcgU21hbGxJbnRlZ2VyKGEgJSBiKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gW3NlbGYsIEludGVnZXJbMF1dO1xuICAgICAgICAgICAgaWYgKGIgPT0gLTEpIHJldHVybiBbc2VsZi5uZWdhdGUoKSwgSW50ZWdlclswXV07XG4gICAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMoYik7XG4gICAgICAgICAgICBpZiAoYWJzIDwgQkFTRSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kU21hbGwoYSwgYWJzKTtcbiAgICAgICAgICAgICAgICBxdW90aWVudCA9IGFycmF5VG9TbWFsbCh2YWx1ZVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNpZ24pIHJlbWFpbmRlciA9IC1yZW1haW5kZXI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxdW90aWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaWduICE9PSBuLnNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTbWFsbEludGVnZXIocXVvdGllbnQpLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBzZWxmLnNpZ24gIT09IG4uc2lnbiksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KGFicyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSBjb21wYXJlQWJzKGEsIGIpO1xuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PT0gLTEpIHJldHVybiBbSW50ZWdlclswXSwgc2VsZl07XG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAwKSByZXR1cm4gW0ludGVnZXJbc2VsZi5zaWduID09PSBuLnNpZ24gPyAxIDogLTFdLCBJbnRlZ2VyWzBdXTtcblxuICAgICAgICAvLyBkaXZNb2QxIGlzIGZhc3RlciBvbiBzbWFsbGVyIGlucHV0IHNpemVzXG4gICAgICAgIGlmIChhLmxlbmd0aCArIGIubGVuZ3RoIDw9IDIwMClcbiAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kMShhLCBiKTtcbiAgICAgICAgZWxzZSB2YWx1ZSA9IGRpdk1vZDIoYSwgYik7XG5cbiAgICAgICAgcXVvdGllbnQgPSB2YWx1ZVswXTtcbiAgICAgICAgdmFyIHFTaWduID0gc2VsZi5zaWduICE9PSBuLnNpZ24sXG4gICAgICAgICAgICBtb2QgPSB2YWx1ZVsxXSxcbiAgICAgICAgICAgIG1TaWduID0gc2VsZi5zaWduO1xuICAgICAgICBpZiAodHlwZW9mIHF1b3RpZW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAocVNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xuICAgICAgICAgICAgcXVvdGllbnQgPSBuZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KTtcbiAgICAgICAgfSBlbHNlIHF1b3RpZW50ID0gbmV3IEJpZ0ludGVnZXIocXVvdGllbnQsIHFTaWduKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2QgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChtU2lnbikgbW9kID0gLW1vZDtcbiAgICAgICAgICAgIG1vZCA9IG5ldyBTbWFsbEludGVnZXIobW9kKTtcbiAgICAgICAgfSBlbHNlIG1vZCA9IG5ldyBCaWdJbnRlZ2VyKG1vZCwgbVNpZ24pO1xuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCBtb2RdO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkaXZNb2RBbnkodGhpcywgdik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdW90aWVudDogcmVzdWx0WzBdLFxuICAgICAgICAgICAgcmVtYWluZGVyOiByZXN1bHRbMV1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZGl2bW9kID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2Q7XG5cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMF07XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm92ZXIgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgLyBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gQmlnSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMV07XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1vZCA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucmVtYWluZGVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAlIHBhcnNlVmFsdWUodikudmFsdWUpO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZDtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgYiA9IG4udmFsdWUsXG4gICAgICAgICAgICB2YWx1ZSwgeCwgeTtcbiAgICAgICAgaWYgKGIgPT09IDApIHJldHVybiBJbnRlZ2VyWzFdO1xuICAgICAgICBpZiAoYSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgIGlmIChhID09PSAxKSByZXR1cm4gSW50ZWdlclsxXTtcbiAgICAgICAgaWYgKGEgPT09IC0xKSByZXR1cm4gbi5pc0V2ZW4oKSA/IEludGVnZXJbMV0gOiBJbnRlZ2VyWy0xXTtcbiAgICAgICAgaWYgKG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuLmlzU21hbGwpIHRocm93IG5ldyBFcnJvcihcIlRoZSBleHBvbmVudCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGlzIHRvbyBsYXJnZS5cIik7XG4gICAgICAgIGlmICh0aGlzLmlzU21hbGwpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UodmFsdWUgPSBNYXRoLnBvdyhhLCBiKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gdGhpcztcbiAgICAgICAgeSA9IEludGVnZXJbMV07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoYiAmIDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcbiAgICAgICAgICAgICAgICAtLWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgYnJlYWs7XG4gICAgICAgICAgICBiIC89IDI7XG4gICAgICAgICAgICB4ID0geC5zcXVhcmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUucG93O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XG4gICAgICAgIHZhciBfMCA9IEJpZ0ludCgwKSwgXzEgPSBCaWdJbnQoMSksIF8yID0gQmlnSW50KDIpO1xuICAgICAgICBpZiAoYiA9PT0gXzApIHJldHVybiBJbnRlZ2VyWzFdO1xuICAgICAgICBpZiAoYSA9PT0gXzApIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICBpZiAoYSA9PT0gXzEpIHJldHVybiBJbnRlZ2VyWzFdO1xuICAgICAgICBpZiAoYSA9PT0gQmlnSW50KC0xKSkgcmV0dXJuIG4uaXNFdmVuKCkgPyBJbnRlZ2VyWzFdIDogSW50ZWdlclstMV07XG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSkgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoXzApO1xuICAgICAgICB2YXIgeCA9IHRoaXM7XG4gICAgICAgIHZhciB5ID0gSW50ZWdlclsxXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICgoYiAmIF8xKSA9PT0gXzEpIHtcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcbiAgICAgICAgICAgICAgICAtLWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA9PT0gXzApIGJyZWFrO1xuICAgICAgICAgICAgYiAvPSBfMjtcbiAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGZ1bmN0aW9uIChleHAsIG1vZCkge1xuICAgICAgICBleHAgPSBwYXJzZVZhbHVlKGV4cCk7XG4gICAgICAgIG1vZCA9IHBhcnNlVmFsdWUobW9kKTtcbiAgICAgICAgaWYgKG1vZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwXCIpO1xuICAgICAgICB2YXIgciA9IEludGVnZXJbMV0sXG4gICAgICAgICAgICBiYXNlID0gdGhpcy5tb2QobW9kKTtcbiAgICAgICAgaWYgKGV4cC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGV4cCA9IGV4cC5tdWx0aXBseShJbnRlZ2VyWy0xXSk7XG4gICAgICAgICAgICBiYXNlID0gYmFzZS5tb2RJbnYobW9kKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZXhwLmlzUG9zaXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKGJhc2UuaXNaZXJvKCkpIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICAgICAgaWYgKGV4cC5pc09kZCgpKSByID0gci5tdWx0aXBseShiYXNlKS5tb2QobW9kKTtcbiAgICAgICAgICAgIGV4cCA9IGV4cC5kaXZpZGUoMik7XG4gICAgICAgICAgICBiYXNlID0gYmFzZS5zcXVhcmUoKS5tb2QobW9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kUG93ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3c7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQWJzKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gYVtpXSA+IGJbaV0gPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gY29tcGFyZUFicyhhLCBiKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcbiAgICAgICAgICAgIGEgPSBNYXRoLmFicyh0aGlzLnZhbHVlKSxcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICBiID0gTWF0aC5hYnMoYik7XG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBiID0gcGFyc2VWYWx1ZSh2KS52YWx1ZTtcbiAgICAgICAgYSA9IGEgPj0gMCA/IGEgOiAtYTtcbiAgICAgICAgYiA9IGIgPj0gMCA/IGIgOiAtYjtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGFib3V0IGNvbXBhcmlzb24gd2l0aCBJbmZpbml0eTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGVyb2xzb24vQmlnSW50ZWdlci5qcy9pc3N1ZXMvNjFcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiBuLnNpZ24gPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbiA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZUFicyhhLCBiKSAqICh0aGlzLnNpZ24gPyAtMSA6IDEpO1xuICAgIH07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIGEgPCAwID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhIDwgMCA/IDEgOiAtMTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2YXIgYiA9IHBhcnNlVmFsdWUodikudmFsdWU7XG4gICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xuICAgIH1cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPT09IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmVxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5lcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscztcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgIT09IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5lcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubm90RXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5lcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscztcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID4gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3QgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmdyZWF0ZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmd0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA8IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmx0ID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sZXNzZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmx0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlcjtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPj0gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ2VxID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDw9IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscztcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlWzBdICYgMSkgPT09IDA7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgQmlnSW50KDEpKSA9PT0gQmlnSW50KDApO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVbMF0gJiAxKSA9PT0gMTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAxO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgQmlnSW50KDEpKSA9PT0gQmlnSW50KDEpO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zaWduO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA+IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmU7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA8IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmU7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy52YWx1ZSkgPT09IDE7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzKCkudmFsdWUgPT09IEJpZ0ludCgxKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gMDtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gQmlnSW50KDApO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChuLmlzVW5pdCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG4uY29tcGFyZUFicygyKSA9PT0gMCkgcmV0dXJuIHRoaXMuaXNFdmVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZChuKS5pc1plcm8oKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnk7XG5cbiAgICBmdW5jdGlvbiBpc0Jhc2ljUHJpbWUodikge1xuICAgICAgICB2YXIgbiA9IHYuYWJzKCk7XG4gICAgICAgIGlmIChuLmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChuLmVxdWFscygyKSB8fCBuLmVxdWFscygzKSB8fCBuLmVxdWFscyg1KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChuLmlzRXZlbigpIHx8IG4uaXNEaXZpc2libGVCeSgzKSB8fCBuLmlzRGl2aXNpYmxlQnkoNSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG4ubGVzc2VyKDQ5KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHdlIGRvbid0IGtub3cgaWYgaXQncyBwcmltZTogbGV0IHRoZSBvdGhlciBmdW5jdGlvbnMgZmlndXJlIGl0IG91dFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pbGxlclJhYmluVGVzdChuLCBhKSB7XG4gICAgICAgIHZhciBuUHJldiA9IG4ucHJldigpLFxuICAgICAgICAgICAgYiA9IG5QcmV2LFxuICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICBkLCB0LCBpLCB4O1xuICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkgYiA9IGIuZGl2aWRlKDIpLCByKys7XG4gICAgICAgIG5leHQ6IGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobi5sZXNzZXIoYVtpXSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgeCA9IGJpZ0ludChhW2ldKS5tb2RQb3coYiwgbik7XG4gICAgICAgICAgICBpZiAoeC5pc1VuaXQoKSB8fCB4LmVxdWFscyhuUHJldikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChkID0gciAtIDE7IGQgIT0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgeCA9IHguc3F1YXJlKCkubW9kKG4pO1xuICAgICAgICAgICAgICAgIGlmICh4LmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHguZXF1YWxzKG5QcmV2KSkgY29udGludWUgbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgXCJzdHJpY3RcIiB0byB0cnVlIHRvIGZvcmNlIEdSSC1zdXBwb3J0ZWQgbG93ZXIgYm91bmQgb2YgMipsb2coTileMlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBmdW5jdGlvbiAoc3RyaWN0KSB7XG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xuICAgICAgICBpZiAoaXNQcmltZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaXNQcmltZTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xuICAgICAgICB2YXIgYml0cyA9IG4uYml0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChiaXRzIDw9IDY0KVxuICAgICAgICAgICAgcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLCBbMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOSwgMzEsIDM3XSk7XG4gICAgICAgIHZhciBsb2dOID0gTWF0aC5sb2coMikgKiBiaXRzLnRvSlNOdW1iZXIoKTtcbiAgICAgICAgdmFyIHQgPSBNYXRoLmNlaWwoKHN0cmljdCA9PT0gdHJ1ZSkgPyAoMiAqIE1hdGgucG93KGxvZ04sIDIpKSA6IGxvZ04pO1xuICAgICAgICBmb3IgKHZhciBhID0gW10sIGkgPSAwOyBpIDwgdDsgaSsrKSB7XG4gICAgICAgICAgICBhLnB1c2goYmlnSW50KGkgKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLCBhKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQcmltZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWU7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgaXNQcmltZSA9IGlzQmFzaWNQcmltZSh0aGlzKTtcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIHQgPSBpdGVyYXRpb25zID09PSB1bmRlZmluZWQgPyA1IDogaXRlcmF0aW9ucztcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBpID0gMDsgaSA8IHQ7IGkrKykge1xuICAgICAgICAgICAgYS5wdXNoKGJpZ0ludC5yYW5kQmV0d2VlbigyLCBuLm1pbnVzKDIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLCBhKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgdCA9IGJpZ0ludC56ZXJvLCBuZXdUID0gYmlnSW50Lm9uZSwgciA9IHBhcnNlVmFsdWUobiksIG5ld1IgPSB0aGlzLmFicygpLCBxLCBsYXN0VCwgbGFzdFI7XG4gICAgICAgIHdoaWxlICghbmV3Ui5pc1plcm8oKSkge1xuICAgICAgICAgICAgcSA9IHIuZGl2aWRlKG5ld1IpO1xuICAgICAgICAgICAgbGFzdFQgPSB0O1xuICAgICAgICAgICAgbGFzdFIgPSByO1xuICAgICAgICAgICAgdCA9IG5ld1Q7XG4gICAgICAgICAgICByID0gbmV3UjtcbiAgICAgICAgICAgIG5ld1QgPSBsYXN0VC5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1QpKTtcbiAgICAgICAgICAgIG5ld1IgPSBsYXN0Ui5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXIuaXNVbml0KCkpIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkgKyBcIiBhbmQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBhcmUgbm90IGNvLXByaW1lXCIpO1xuICAgICAgICBpZiAodC5jb21wYXJlKDApID09PSAtMSkge1xuICAgICAgICAgICAgdCA9IHQuYWRkKG4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHQubmVnYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubW9kSW52ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnY7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAodGhpcy5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsIDEpLCB0aGlzLnNpZ24pO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgKyAxIDwgTUFYX0lOVCkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUgKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCBmYWxzZSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKyBCaWdJbnQoMSkpO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLCAxLCB0aGlzLnNpZ24pO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgLSAxID4gLU1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlIC0gMSk7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgLSBCaWdJbnQoMSkpO1xuICAgIH1cblxuICAgIHZhciBwb3dlcnNPZlR3byA9IFsxXTtcbiAgICB3aGlsZSAoMiAqIHBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aCAtIDFdIDw9IEJBU0UpIHBvd2Vyc09mVHdvLnB1c2goMiAqIHBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aCAtIDFdKTtcbiAgICB2YXIgcG93ZXJzMkxlbmd0aCA9IHBvd2Vyc09mVHdvLmxlbmd0aCwgaGlnaGVzdFBvd2VyMiA9IHBvd2Vyc09mVHdvW3Bvd2VyczJMZW5ndGggLSAxXTtcblxuICAgIGZ1bmN0aW9uIHNoaWZ0X2lzU21hbGwobikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobikgPD0gQkFTRTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodikudG9KU051bWJlcigpO1xuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcobikgKyBcIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0UmlnaHQoLW4pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgd2hpbGUgKG4gPj0gcG93ZXJzMkxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpO1xuICAgICAgICAgICAgbiAtPSBwb3dlcnMyTGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lm11bHRpcGx5KHBvd2Vyc09mVHdvW25dKTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHJlbVF1bztcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLnRvSlNOdW1iZXIoKTtcbiAgICAgICAgaWYgKCFzaGlmdF9pc1NtYWxsKG4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdExlZnQoLW4pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKG4gPj0gcG93ZXJzMkxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSB8fCAocmVzdWx0LmlzTmVnYXRpdmUoKSAmJiByZXN1bHQuaXNVbml0KCkpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgcmVtUXVvID0gZGl2TW9kQW55KHJlc3VsdCwgaGlnaGVzdFBvd2VyMik7XG4gICAgICAgICAgICByZXN1bHQgPSByZW1RdW9bMV0uaXNOZWdhdGl2ZSgpID8gcmVtUXVvWzBdLnByZXYoKSA6IHJlbVF1b1swXTtcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmVtUXVvID0gZGl2TW9kQW55KHJlc3VsdCwgcG93ZXJzT2ZUd29bbl0pO1xuICAgICAgICByZXR1cm4gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0O1xuXG4gICAgZnVuY3Rpb24gYml0d2lzZSh4LCB5LCBmbikge1xuICAgICAgICB5ID0gcGFyc2VWYWx1ZSh5KTtcbiAgICAgICAgdmFyIHhTaWduID0geC5pc05lZ2F0aXZlKCksIHlTaWduID0geS5pc05lZ2F0aXZlKCk7XG4gICAgICAgIHZhciB4UmVtID0geFNpZ24gPyB4Lm5vdCgpIDogeCxcbiAgICAgICAgICAgIHlSZW0gPSB5U2lnbiA/IHkubm90KCkgOiB5O1xuICAgICAgICB2YXIgeERpZ2l0ID0gMCwgeURpZ2l0ID0gMDtcbiAgICAgICAgdmFyIHhEaXZNb2QgPSBudWxsLCB5RGl2TW9kID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAoIXhSZW0uaXNaZXJvKCkgfHwgIXlSZW0uaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHhEaXZNb2QgPSBkaXZNb2RBbnkoeFJlbSwgaGlnaGVzdFBvd2VyMik7XG4gICAgICAgICAgICB4RGlnaXQgPSB4RGl2TW9kWzFdLnRvSlNOdW1iZXIoKTtcbiAgICAgICAgICAgIGlmICh4U2lnbikge1xuICAgICAgICAgICAgICAgIHhEaWdpdCA9IGhpZ2hlc3RQb3dlcjIgLSAxIC0geERpZ2l0OyAvLyB0d28ncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHlEaXZNb2QgPSBkaXZNb2RBbnkoeVJlbSwgaGlnaGVzdFBvd2VyMik7XG4gICAgICAgICAgICB5RGlnaXQgPSB5RGl2TW9kWzFdLnRvSlNOdW1iZXIoKTtcbiAgICAgICAgICAgIGlmICh5U2lnbikge1xuICAgICAgICAgICAgICAgIHlEaWdpdCA9IGhpZ2hlc3RQb3dlcjIgLSAxIC0geURpZ2l0OyAvLyB0d28ncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhSZW0gPSB4RGl2TW9kWzBdO1xuICAgICAgICAgICAgeVJlbSA9IHlEaXZNb2RbMF07XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbih4RGlnaXQsIHlEaWdpdCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW0gPSBmbih4U2lnbiA/IDEgOiAwLCB5U2lnbiA/IDEgOiAwKSAhPT0gMCA/IGJpZ0ludCgtMSkgOiBiaWdJbnQoMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bS5tdWx0aXBseShoaWdoZXN0UG93ZXIyKS5hZGQoYmlnSW50KHJlc3VsdFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5wcmV2KCk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5vdCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubm90O1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgJiBiOyB9KTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYW5kID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHwgYjsgfSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm9yID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm9yO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgXiBiOyB9KTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUueG9yID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3I7XG5cbiAgICB2YXIgTE9CTUFTS19JID0gMSA8PCAzMCwgTE9CTUFTS19CSSA9IChCQVNFICYgLUJBU0UpICogKEJBU0UgJiAtQkFTRSkgfCBMT0JNQVNLX0k7XG4gICAgZnVuY3Rpb24gcm91Z2hMT0IobikgeyAvLyBnZXQgbG93ZXN0T25lQml0IChyb3VnaClcbiAgICAgICAgLy8gU21hbGxJbnRlZ2VyOiByZXR1cm4gTWluKGxvd2VzdE9uZUJpdChuKSwgMSA8PCAzMClcbiAgICAgICAgLy8gQmlnSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMTQpIFtCQVNFPTFlN11cbiAgICAgICAgdmFyIHYgPSBuLnZhbHVlLFxuICAgICAgICAgICAgeCA9IHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8gdiB8IExPQk1BU0tfSSA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIHYgPT09IFwiYmlnaW50XCIgPyB2IHwgQmlnSW50KExPQk1BU0tfSSkgOlxuICAgICAgICAgICAgICAgICAgICB2WzBdICsgdlsxXSAqIEJBU0UgfCBMT0JNQVNLX0JJO1xuICAgICAgICByZXR1cm4geCAmIC14O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVnZXJMb2dhcml0aG0odmFsdWUsIGJhc2UpIHtcbiAgICAgICAgaWYgKGJhc2UuY29tcGFyZVRvKHZhbHVlKSA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSwgYmFzZS5zcXVhcmUoYmFzZSkpO1xuICAgICAgICAgICAgdmFyIHAgPSB0bXAucDtcbiAgICAgICAgICAgIHZhciBlID0gdG1wLmU7XG4gICAgICAgICAgICB2YXIgdCA9IHAubXVsdGlwbHkoYmFzZSk7XG4gICAgICAgICAgICByZXR1cm4gdC5jb21wYXJlVG8odmFsdWUpIDw9IDAgPyB7IHA6IHQsIGU6IGUgKiAyICsgMSB9IDogeyBwOiBwLCBlOiBlICogMiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHA6IGJpZ0ludCgxKSwgZTogMCB9O1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICBpZiAobi5jb21wYXJlVG8oYmlnSW50KDApKSA8IDApIHtcbiAgICAgICAgICAgIG4gPSBuLm5lZ2F0ZSgpLnN1YnRyYWN0KGJpZ0ludCgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uY29tcGFyZVRvKGJpZ0ludCgwKSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBiaWdJbnQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpZ0ludChpbnRlZ2VyTG9nYXJpdGhtKG4sIGJpZ0ludCgyKSkuZSkuYWRkKGJpZ0ludCgxKSk7XG4gICAgfVxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuYml0TGVuZ3RoID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBtYXgoYSwgYikge1xuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XG4gICAgICAgIHJldHVybiBhLmdyZWF0ZXIoYikgPyBhIDogYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWluKGEsIGIpIHtcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xuICAgICAgICByZXR1cm4gYS5sZXNzZXIoYikgPyBhIDogYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2NkKGEsIGIpIHtcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSkuYWJzKCk7XG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpLmFicygpO1xuICAgICAgICBpZiAoYS5lcXVhbHMoYikpIHJldHVybiBhO1xuICAgICAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGI7XG4gICAgICAgIGlmIChiLmlzWmVybygpKSByZXR1cm4gYTtcbiAgICAgICAgdmFyIGMgPSBJbnRlZ2VyWzFdLCBkLCB0O1xuICAgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpKSB7XG4gICAgICAgICAgICBkID0gbWluKHJvdWdoTE9CKGEpLCByb3VnaExPQihiKSk7XG4gICAgICAgICAgICBhID0gYS5kaXZpZGUoZCk7XG4gICAgICAgICAgICBiID0gYi5kaXZpZGUoZCk7XG4gICAgICAgICAgICBjID0gYy5tdWx0aXBseShkKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKHJvdWdoTE9CKGEpKTtcbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgIGIgPSBiLmRpdmlkZShyb3VnaExPQihiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYS5ncmVhdGVyKGIpKSB7XG4gICAgICAgICAgICAgICAgdCA9IGI7IGIgPSBhOyBhID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLnN1YnRyYWN0KGEpO1xuICAgICAgICB9IHdoaWxlICghYi5pc1plcm8oKSk7XG4gICAgICAgIHJldHVybiBjLmlzVW5pdCgpID8gYSA6IGEubXVsdGlwbHkoYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxjbShhLCBiKSB7XG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpLmFicygpO1xuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcbiAgICAgICAgcmV0dXJuIGEuZGl2aWRlKGdjZChhLCBiKSkubXVsdGlwbHkoYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsIGIpIHtcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xuICAgICAgICB2YXIgbG93ID0gbWluKGEsIGIpLCBoaWdoID0gbWF4KGEsIGIpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBoaWdoLnN1YnRyYWN0KGxvdykuYWRkKDEpO1xuICAgICAgICBpZiAocmFuZ2UuaXNTbWFsbCkgcmV0dXJuIGxvdy5hZGQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZ2UpKTtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IHRvQmFzZShyYW5nZSwgQkFTRSkudmFsdWU7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgcmVzdHJpY3RlZCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gcmVzdHJpY3RlZCA/IGRpZ2l0c1tpXSA6IEJBU0U7XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSB0cnVuY2F0ZShNYXRoLnJhbmRvbSgpICogdG9wKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRpZ2l0KTtcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IHRvcCkgcmVzdHJpY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb3cuYWRkKEludGVnZXIuZnJvbUFycmF5KHJlc3VsdCwgQkFTRSwgZmFsc2UpKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VCYXNlID0gZnVuY3Rpb24gKHRleHQsIGJhc2UsIGFscGhhYmV0LCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgIGFscGhhYmV0ID0gYWxwaGFiZXQgfHwgREVGQVVMVF9BTFBIQUJFVDtcbiAgICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0KTtcbiAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgYWxwaGFiZXQgPSBhbHBoYWJldC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBhYnNCYXNlID0gTWF0aC5hYnMoYmFzZSk7XG4gICAgICAgIHZhciBhbHBoYWJldFZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFscGhhYmV0VmFsdWVzW2FscGhhYmV0W2ldXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRleHRbaV07XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCItXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGMgaW4gYWxwaGFiZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGFiZXRWYWx1ZXNbY10gPj0gYWJzQmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIxXCIgJiYgYWJzQmFzZSA9PT0gMSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJhc2UgPSBwYXJzZVZhbHVlKGJhc2UpO1xuICAgICAgICB2YXIgZGlnaXRzID0gW107XG4gICAgICAgIHZhciBpc05lZ2F0aXZlID0gdGV4dFswXSA9PT0gXCItXCI7XG4gICAgICAgIGZvciAoaSA9IGlzTmVnYXRpdmUgPyAxIDogMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmIChjIGluIGFscGhhYmV0VmFsdWVzKSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGFscGhhYmV0VmFsdWVzW2NdKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHRleHRbaV0gIT09IFwiPlwiICYmIGkgPCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZGlnaXRzLnB1c2gocGFyc2VWYWx1ZSh0ZXh0LnNsaWNlKHN0YXJ0ICsgMSwgaSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBjaGFyYWN0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XG4gICAgICAgIHZhciB2YWwgPSBJbnRlZ2VyWzBdLCBwb3cgPSBJbnRlZ2VyWzFdLCBpO1xuICAgICAgICBmb3IgKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hZGQoZGlnaXRzW2ldLnRpbWVzKHBvdykpO1xuICAgICAgICAgICAgcG93ID0gcG93LnRpbWVzKGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlID8gdmFsLm5lZ2F0ZSgpIDogdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShkaWdpdCwgYWxwaGFiZXQpIHtcbiAgICAgICAgYWxwaGFiZXQgPSBhbHBoYWJldCB8fCBERUZBVUxUX0FMUEhBQkVUO1xuICAgICAgICBpZiAoZGlnaXQgPCBhbHBoYWJldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtkaWdpdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiPFwiICsgZGlnaXQgKyBcIj5cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0Jhc2UobiwgYmFzZSkge1xuICAgICAgICBiYXNlID0gYmlnSW50KGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBub256ZXJvIG51bWJlcnMgdG8gYmFzZSAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZS5lcXVhbHMoLTEpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHsgdmFsdWU6IFswXSwgaXNOZWdhdGl2ZTogZmFsc2UgfTtcbiAgICAgICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0LmFwcGx5KFtdLCBBcnJheS5hcHBseShudWxsLCBBcnJheSgtbi50b0pTTnVtYmVyKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZiwgWzEsIDBdKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBhcnIgPSBBcnJheS5hcHBseShudWxsLCBBcnJheShuLnRvSlNOdW1iZXIoKSAtIDEpKVxuICAgICAgICAgICAgICAgIC5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsIFswLCAxXSk7XG4gICAgICAgICAgICBhcnIudW5zaGlmdChbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0LmFwcGx5KFtdLCBhcnIpLFxuICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5lZyA9IGZhbHNlO1xuICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkgJiYgYmFzZS5pc1Bvc2l0aXZlKCkpIHtcbiAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgICAgICBuID0gbi5hYnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZS5pc1VuaXQoKSkge1xuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KG4udG9KU051bWJlcigpKSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIDEpLFxuICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IG5lZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBsZWZ0ID0gbiwgZGl2bW9kO1xuICAgICAgICB3aGlsZSAobGVmdC5pc05lZ2F0aXZlKCkgfHwgbGVmdC5jb21wYXJlQWJzKGJhc2UpID49IDApIHtcbiAgICAgICAgICAgIGRpdm1vZCA9IGxlZnQuZGl2bW9kKGJhc2UpO1xuICAgICAgICAgICAgbGVmdCA9IGRpdm1vZC5xdW90aWVudDtcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGRpdm1vZC5yZW1haW5kZXI7XG4gICAgICAgICAgICBpZiAoZGlnaXQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgPSBiYXNlLm1pbnVzKGRpZ2l0KS5hYnMoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQucHVzaChkaWdpdC50b0pTTnVtYmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKGxlZnQudG9KU051bWJlcigpKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG91dC5yZXZlcnNlKCksIGlzTmVnYXRpdmU6IG5lZyB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQmFzZVN0cmluZyhuLCBiYXNlLCBhbHBoYWJldCkge1xuICAgICAgICB2YXIgYXJyID0gdG9CYXNlKG4sIGJhc2UpO1xuICAgICAgICByZXR1cm4gKGFyci5pc05lZ2F0aXZlID8gXCItXCIgOiBcIlwiKSArIGFyci52YWx1ZS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoeCwgYWxwaGFiZXQpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xuICAgIH07XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XG4gICAgfTtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcbiAgICB9O1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgsIGFscGhhYmV0KSB7XG4gICAgICAgIGlmIChyYWRpeCA9PT0gdW5kZWZpbmVkKSByYWRpeCA9IDEwO1xuICAgICAgICBpZiAocmFkaXggIT09IDEwKSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4LCBhbHBoYWJldCk7XG4gICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZSwgbCA9IHYubGVuZ3RoLCBzdHIgPSBTdHJpbmcodlstLWxdKSwgemVyb3MgPSBcIjAwMDAwMDBcIiwgZGlnaXQ7XG4gICAgICAgIHdoaWxlICgtLWwgPj0gMCkge1xuICAgICAgICAgICAgZGlnaXQgPSBTdHJpbmcodltsXSk7XG4gICAgICAgICAgICBzdHIgKz0gemVyb3Muc2xpY2UoZGlnaXQubGVuZ3RoKSArIGRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduID8gXCItXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gc2lnbiArIHN0cjtcbiAgICB9O1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCwgYWxwaGFiZXQpIHtcbiAgICAgICAgaWYgKHJhZGl4ID09PSB1bmRlZmluZWQpIHJhZGl4ID0gMTA7XG4gICAgICAgIGlmIChyYWRpeCAhPSAxMCkgcmV0dXJuIHRvQmFzZVN0cmluZyh0aGlzLCByYWRpeCwgYWxwaGFiZXQpO1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH07XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvU3RyaW5nID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUudG9KU09OID0gQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksIDEwKTtcbiAgICB9O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU051bWJlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZ1ZhbHVlKHYpIHtcbiAgICAgICAgaWYgKGlzUHJlY2lzZSgrdikpIHtcbiAgICAgICAgICAgIHZhciB4ID0gK3Y7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdHJ1bmNhdGUoeCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRzTmF0aXZlQmlnSW50ID8gbmV3IE5hdGl2ZUJpZ0ludChCaWdJbnQoeCkpIDogbmV3IFNtYWxsSW50ZWdlcih4KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyB2KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lnbiA9IHZbMF0gPT09IFwiLVwiO1xuICAgICAgICBpZiAoc2lnbikgdiA9IHYuc2xpY2UoMSk7XG4gICAgICAgIHZhciBzcGxpdCA9IHYuc3BsaXQoL2UvaSk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgc3BsaXQuam9pbihcImVcIikpO1xuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gc3BsaXRbMV07XG4gICAgICAgICAgICBpZiAoZXhwWzBdID09PSBcIitcIikgZXhwID0gZXhwLnNsaWNlKDEpO1xuICAgICAgICAgICAgZXhwID0gK2V4cDtcbiAgICAgICAgICAgIGlmIChleHAgIT09IHRydW5jYXRlKGV4cCkgfHwgIWlzUHJlY2lzZShleHApKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgZXhwICsgXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzcGxpdFswXTtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsUGxhY2UgPSB0ZXh0LmluZGV4T2YoXCIuXCIpO1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhwIC09IHRleHQubGVuZ3RoIC0gZGVjaW1hbFBsYWNlIC0gMTtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBkZWNpbWFsUGxhY2UpICsgdGV4dC5zbGljZShkZWNpbWFsUGxhY2UgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHAgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBuZWdhdGl2ZSBleHBvbmVudCBwYXJ0IGZvciBpbnRlZ2Vyc1wiKTtcbiAgICAgICAgICAgIHRleHQgKz0gKG5ldyBBcnJheShleHAgKyAxKSkuam9pbihcIjBcIik7XG4gICAgICAgICAgICB2ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNWYWxpZCA9IC9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7XG4gICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xuICAgICAgICBpZiAoc3VwcG9ydHNOYXRpdmVCaWdJbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludChzaWduID8gXCItXCIgKyB2IDogdikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gW10sIG1heCA9IHYubGVuZ3RoLCBsID0gTE9HX0JBU0UsIG1pbiA9IG1heCAtIGw7XG4gICAgICAgIHdoaWxlIChtYXggPiAwKSB7XG4gICAgICAgICAgICByLnB1c2goK3Yuc2xpY2UobWluLCBtYXgpKTtcbiAgICAgICAgICAgIG1pbiAtPSBsO1xuICAgICAgICAgICAgaWYgKG1pbiA8IDApIG1pbiA9IDA7XG4gICAgICAgICAgICBtYXggLT0gbDtcbiAgICAgICAgfVxuICAgICAgICB0cmltKHIpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIociwgc2lnbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOdW1iZXJWYWx1ZSh2KSB7XG4gICAgICAgIGlmIChzdXBwb3J0c05hdGl2ZUJpZ0ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQoQmlnSW50KHYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVjaXNlKHYpKSB7XG4gICAgICAgICAgICBpZiAodiAhPT0gdHJ1bmNhdGUodikpIHRocm93IG5ldyBFcnJvcih2ICsgXCIgaXMgbm90IGFuIGludGVnZXIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodi50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXJWYWx1ZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIC8vIFByZS1kZWZpbmUgbnVtYmVycyBpbiByYW5nZSBbLTk5OSw5OTldXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgSW50ZWdlcltpXSA9IHBhcnNlVmFsdWUoaSk7XG4gICAgICAgIGlmIChpID4gMCkgSW50ZWdlclstaV0gPSBwYXJzZVZhbHVlKC1pKTtcbiAgICB9XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBJbnRlZ2VyLm9uZSA9IEludGVnZXJbMV07XG4gICAgSW50ZWdlci56ZXJvID0gSW50ZWdlclswXTtcbiAgICBJbnRlZ2VyLm1pbnVzT25lID0gSW50ZWdlclstMV07XG4gICAgSW50ZWdlci5tYXggPSBtYXg7XG4gICAgSW50ZWdlci5taW4gPSBtaW47XG4gICAgSW50ZWdlci5nY2QgPSBnY2Q7XG4gICAgSW50ZWdlci5sY20gPSBsY207XG4gICAgSW50ZWdlci5pc0luc3RhbmNlID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBCaWdJbnRlZ2VyIHx8IHggaW5zdGFuY2VvZiBTbWFsbEludGVnZXIgfHwgeCBpbnN0YW5jZW9mIE5hdGl2ZUJpZ0ludDsgfTtcbiAgICBJbnRlZ2VyLnJhbmRCZXR3ZWVuID0gcmFuZEJldHdlZW47XG5cbiAgICBJbnRlZ2VyLmZyb21BcnJheSA9IGZ1bmN0aW9uIChkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMubWFwKHBhcnNlVmFsdWUpLCBwYXJzZVZhbHVlKGJhc2UgfHwgMTApLCBpc05lZ2F0aXZlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEludGVnZXI7XG59KSgpO1xuIiwiLyogZ2xvYmFsIGJpZ0ludCAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLy8gV2UgcmVwcmVzZW50IGEgW1oudF0gYXMgYSBqYXZhc2NyaXB0IDMyYml0IGludGVnZXJzIGlmIGl0IGZpdHMgb3IgYXMgYSBiaWdJbnQuXG5cbi8vUHJvdmlkZXM6IG1sX3pfbm9ybWFsaXplXG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfbm9ybWFsaXplKHgpe1xuICB2YXIgeSA9IHgudG9KU051bWJlciAoKSB8IDA7XG4gIGlmKHguZXF1YWxzKGJpZ0ludCh5KSkpIHJldHVybiB5O1xuICByZXR1cm4geDtcbn1cblxuLy9leHRlcm5hbCBpbml0OiB1bml0IC0+IHVuaXRcbi8vUHJvdmlkZXM6IG1sX3pfaW5pdFxuLy9SZXF1aXJlczogY2FtbF96YXJpdGhfbWFyc2hhbCwgY2FtbF96YXJpdGhfdW5tYXJzaGFsLCBjYW1sX2N1c3RvbV9vcHMsIG1sX3pfaGFzaFxuZnVuY3Rpb24gbWxfel9pbml0KHVuaXQpIHtcbiAgY2FtbF9jdXN0b21fb3BzWydfeiddID1cbiAgICB7IHNlcmlhbGl6ZSA6IGNhbWxfemFyaXRoX21hcnNoYWwsXG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfemFyaXRoX3VubWFyc2hhbCxcbiAgICAgIGhhc2ggOiBtbF96X2hhc2h9O1xuICByZXR1cm4gMCB9XG5cbi8vZXh0ZXJuYWwgbWxfel9pbnN0YWxsX2ZyYW1ldGFibGU6IHVuaXQgLT4gdW5pdFxuLy9Qcm92aWRlczogbWxfel9pbnN0YWxsX2ZyYW1ldGFibGUgY29uc3RcbmZ1bmN0aW9uIG1sX3pfaW5zdGFsbF9mcmFtZXRhYmxlKHVuaXQpIHsgcmV0dXJuIDAgfVxuXG4vL2V4dGVybmFsIG5lZzogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X25lZyBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9uZWcoejEpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkubmVnYXRlKCkpO1xufVxuXG4vL2V4dGVybmFsIGFkZDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfYWRkIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2FkZCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuYWRkKGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBzdWI6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3N1YiBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9zdWIoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnN1YnRyYWN0KGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBtdWw6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X211bCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9tdWwoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLm11bHRpcGx5KGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBkaXY6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2RpdlxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9kaXYoejEsIHoyKSB7XG4gIHoyID0gYmlnSW50KHoyKVxuICBpZih6Mi5lcXVhbHMoYmlnSW50KDApKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5kaXZpZGUoYmlnSW50KHoyKSkpXG59XG5cbi8vZXh0ZXJuYWwgY2RpdjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfY2RpdlxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X2RpdiwgbWxfel9zaWduLCBtbF96X2FkZFxuZnVuY3Rpb24gbWxfel9jZGl2KHoxLCB6Mikge1xuICB2YXIgejFfcG9zID0gbWxfel9zaWduKHoxKTtcbiAgdmFyIHoyX3BvcyA9IG1sX3pfc2lnbih6Mik7XG4gIGlmICh6MV9wb3MgKiB6Ml9wb3MgPiAwKSAvKiBNdWx0aXBsaWNhdGlvbiBpcyBsaWtlIGEgc2lnbndpc2UgeG9yICovIHtcbiAgICBpZiAoIWJpZ0ludCh6MSkubW9kKGJpZ0ludCh6MikpLmVxdWFscyhiaWdJbnQoMCkpKSB7XG4gICAgICByZXR1cm4gbWxfel9hZGQobWxfel9kaXYoejEsIHoyKSwgYmlnSW50KDEpKSA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtbF96X2Rpdih6MSwgejIpO1xufVxuXG4vL2V4dGVybmFsIGZkaXY6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2ZkaXZcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9kaXYsIG1sX3pfc2lnbiwgbWxfel9zdWJcbmZ1bmN0aW9uIG1sX3pfZmRpdih6MSwgejIpIHtcbiAgdmFyIHoxX3BvcyA9IG1sX3pfc2lnbih6MSk7XG4gIHZhciB6Ml9wb3MgPSBtbF96X3NpZ24oejIpO1xuICBpZiAoejFfcG9zICogejJfcG9zIDwgMCkgLyogTXVsdGlwbGljYXRpb24gaXMgbGlrZSBhIHNpZ253aXNlIHhvciAqLyB7XG4gICAgaWYgKCFiaWdJbnQoejEpLm1vZChiaWdJbnQoejIpKS5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgICAgcmV0dXJuIG1sX3pfc3ViKG1sX3pfZGl2KHoxLCB6MiksIGJpZ0ludCgxKSkgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWxfel9kaXYoejEsIHoyKTtcbn1cblxuLy9leHRlcm5hbCByZW06IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3JlbVxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9yZW0oejEsIHoyKSB7XG4gIHoyID0gYmlnSW50KHoyKTtcbiAgaWYgKHoyLmVxdWFscyhiaWdJbnQoMCkpKSB7XG4gICAgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLm1vZCh6MikpO1xufVxuXG4vL2V4dGVybmFsIGRpdl9yZW06IHQgLT4gdCAtPiAodCAqIHQpXG4vL1Byb3ZpZGVzOiBtbF96X2Rpdl9yZW1cbi8vUmVxdWlyZXM6IG1sX3pfZGl2LCBtbF96X3JlbVxuZnVuY3Rpb24gbWxfel9kaXZfcmVtKHoxLCB6Mikge1xuICByZXR1cm4gWzAsIG1sX3pfZGl2KHoxLHoyKSwgbWxfel9yZW0oejEsIHoyKV1cbn1cbi8vZXh0ZXJuYWwgc3VjYzogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3N1Y2MgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc3VjYyh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5uZXh0KCkpO1xufVxuXG4vL2V4dGVybmFsIHByZWQ6IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9wcmVkIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3ByZWQoejEpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkucHJldigpKTtcbn1cblxuLy9leHRlcm5hbCBhYnM6IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9hYnMgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfYWJzKHoxKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLmFicygpKTtcbn1cblxuLy9leHRlcm5hbCBsb2dhbmQ6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ2FuZCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9sb2dhbmQoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLmFuZChiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgbG9nb3I6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ29yIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2xvZ29yKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5vcihiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgbG9neG9yOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9sb2d4b3IgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbG9neG9yKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS54b3IoYmlnSW50KHoyKSkpO1xufVxuXG4vL2V4dGVybmFsIGxvZ25vdDogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2xvZ25vdCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2xvZ25vdCh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5ub3QoKSk7XG59XG5cbi8vZXh0ZXJuYWwgc2hpZnRfbGVmdDogdCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9zaGlmdF9sZWZ0IGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3NoaWZ0X2xlZnQoejEsIGFtdCkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5zaGlmdExlZnQoYW10KSk7XG59XG5cbi8vZXh0ZXJuYWwgc2hpZnRfcmlnaHQ6IHQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc2hpZnRfcmlnaHQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc2hpZnRfcmlnaHQoejEsIGFtdCkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5zaGlmdFJpZ2h0KGFtdCkpO1xufVxuXG4vL2V4dGVybmFsIHNoaWZ0X3JpZ2h0X3RydW5jOiB0IC0+IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3NoaWZ0X3JpZ2h0X3RydW5jIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfZGl2XG5mdW5jdGlvbiBtbF96X3NoaWZ0X3JpZ2h0X3RydW5jKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9kaXYoYmlnSW50KHoxKSwgYmlnSW50KDIpLnBvdyh6MikpXG59XG5cbi8vZXh0ZXJuYWwgb2ZfaW50OiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9pbnQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9vZl9pbnQoaSkge1xuICByZXR1cm4gaSB8IDA7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfaW50MzI6IGludDMyIC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IG1sX3pfb2ZfaW50XG5mdW5jdGlvbiBtbF96X29mX2ludDMyKGkzMikge1xuICByZXR1cm4gbWxfel9vZl9pbnQoaTMyKTtcbn1cblxuLy9leHRlcm5hbCBvZl9uYXRpdmVpbnQ6IG5hdGl2ZWludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX25hdGl2ZWludCBjb25zdFxuLy9SZXF1aXJlczogbWxfel9vZl9pbnRcbmZ1bmN0aW9uIG1sX3pfb2ZfbmF0aXZlaW50KHopIHtcbiAgcmV0dXJuIG1sX3pfb2ZfaW50KHopXG59XG5cbi8vZXh0ZXJuYWwgb2ZfaW50NjQ6IGludDY0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfaW50NjQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X25lZywgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfb2ZfaW50NjQoaTY0KSB7XG4gIHZhciBuZWcgPSBmYWxzZTtcbiAgaWYoY2FtbF9pbnQ2NF9jb21wYXJlKGk2NCwgWzI1NSwwLDAsMF0pIDwgMCkge1xuICAgIG5lZyA9IHRydWU7XG4gICAgaTY0ID0gY2FtbF9pbnQ2NF9uZWcoaTY0KVxuICB9XG4gIHZhciB4ID0gYmlnSW50KGk2NFsxXSkuYWRkKGJpZ0ludChpNjRbMl0pLnNoaWZ0TGVmdCgyNCkpLmFkZChiaWdJbnQoaTY0WzNdKS5zaGlmdExlZnQoNDgpKTtcbiAgaWYobmVnKSB7IHggPSB4Lm5lZ2F0ZSgpIH07XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZSh4KVxufVxuXG4vL2V4dGVybmFsIG9mX2Zsb2F0OiBmbG9hdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X29mX2Zsb2F0KGYxKSB7XG4gIGlmKGYxID09IEluZmluaXR5IHx8IGYxID09IC1JbmZpbml0eSB8fCBmMSAhPSBmMSlcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludChmMTwwP01hdGguY2VpbChmMSk6TWF0aC5mbG9vcihmMSkpKTtcbn1cblxuLy9leHRlcm5hbCB0b19pbnQ6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3RvX2ludFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBtbF96X3RvX2ludCh6MSkge1xuICBpZiAoejEgPT0gKHoxIHwgMCkpIHJldHVybiB6MSB8IDA7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xufVxuXG4vL2V4dGVybmFsIHRvX2ludDMyOiB0IC0+IGludDMyXG4vL1Byb3ZpZGVzOiBtbF96X3RvX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X3RvX2ludFxuZnVuY3Rpb24gbWxfel90b19pbnQzMih6MSkgeyByZXR1cm4gbWxfel90b19pbnQoejEpIH1cblxuLy9leHRlcm5hbCB0b19pbnQ2NDogdCAtPiBpbnQ2NFxuLy9Qcm92aWRlczogbWxfel90b19pbnQ2NFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X2ZpdHNfaW50NjQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX3pfdG9faW50NjQoejEpIHtcbiAgejEgPSBiaWdJbnQoejEpXG4gIGlmKCFtbF96X2ZpdHNfaW50NjQoejEpKSB7XG4gICAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX25hbWVkX3ZhbHVlKFwibWxfel9vdmVyZmxvd1wiKSk7XG4gIH1cbiAgdmFyIGEgPSB6MS5hbmQoYmlnSW50KDB4ZmZmZmZmKSkudG9KU051bWJlcigpfDA7XG4gIHZhciBiID0gejEuc2hpZnRSaWdodCgyNCkuYW5kKGJpZ0ludCgweGZmZmZmZikpLnRvSlNOdW1iZXIoKXwwO1xuICB2YXIgYyA9IHoxLnNoaWZ0UmlnaHQoNDgpLmFuZChiaWdJbnQoMHhmZmZmKSkudG9KU051bWJlcigpfDA7XG4gIHZhciB4ID0gWyAyNTUsIGEsIGIsIGNdO1xuICByZXR1cm4geDtcbn1cblxuLy9leHRlcm5hbCB0ZXN0Yml0OiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfdGVzdGJpdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X3Rlc3RiaXQoeixwb3Mpe1xuICB6ID0gYmlnSW50KHopO1xuICByZXR1cm4gKHouc2hpZnRSaWdodChwb3MpLmFuZChiaWdJbnQoMSkpLnRvSlNOdW1iZXIoKSl8MDtcbn1cblxuLy9leHRlcm5hbCB0b19uYXRpdmVpbnQ6IHQgLT4gbmF0aXZlaW50XG4vL1Byb3ZpZGVzOiBtbF96X3RvX25hdGl2ZWludFxuLy9SZXF1aXJlczogbWxfel90b19pbnRcbmZ1bmN0aW9uIG1sX3pfdG9fbmF0aXZlaW50KHoxKSB7IHJldHVybiBtbF96X3RvX2ludCh6MSkgfVxuXG4vL2V4dGVybmFsIGZvcm1hdDogc3RyaW5nIC0+IHQgLT4gc3RyaW5nXG4vL1Byb3ZpZGVzOiBtbF96X2Zvcm1hdCBcbi8vUmVxdWlyZXM6IGJpZ0ludFxuLy9SZXF1aXJlczogY2FtbF90b19qc19zdHJpbmcsIGNhbWxfanNfdG9fc3RyaW5nLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX25ld19zdHJpbmcsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Zvcm1hdChmbXQsIHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKTtcbiAgdmFyIGZtdCA9IGZtdC50b1N0cmluZygpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvWmFyaXRoL2Jsb2IvZDA1NTVkNDUxY2UyOTVjNDQ5N2YyNGE4ZDk5OTNmOGRkMjMwOTdkZi96Lm1saXAjTDI5N1xuICB2YXIgYmFzZSA9IDEwO1xuICB2YXIgY2FzID0gMDtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGFsdCA9IDA7XG4gIHZhciBkaXIgPSAwO1xuICB2YXIgc2lnbiA9ICcnO1xuICB2YXIgcGFkID0gJyAnO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIHByZWZpeD1cIlwiO1xuICB3aGlsZShmbXRbaWR4XSA9PSAnJScpIGlkeCsrO1xuICBmb3IoOzsgaWR4KyspIHtcbiAgICBpZihmbXRbaWR4XSA9PSAnIycpIGFsdCA9IDE7XG4gICAgZWxzZSBpZiAoZm10W2lkeF0gPT0gJzAnKSBwYWQgPSAnMCc7XG4gICAgZWxzZSBpZiAoZm10W2lkeF0gPT0gJy0nKSBkaXIgPSAxO1xuICAgIGVsc2UgaWYgKGZtdFtpZHhdID09ICcgJyB8fCBmbXRbaWR4XSA9PSAnKycpIHNpZ24gPSBmbXRbaWR4XTtcbiAgICBlbHNlIGJyZWFrO1xuICB9XG4gIGlmKHoxLmx0KGJpZ0ludCgwKSkpe3NpZ24gPSAnLSc7ejEgPSB6MS5uZWdhdGUoKX07XG4gIGZvcig7Zm10W2lkeF0+PScwJyAmJiBmbXRbaWR4XSA8PSc5JztpZHgrKylcbiAgICB3aWR0aD0xMCp3aWR0aCArICgrZm10W2lkeF0pO1xuICBzd2l0Y2goZm10W2lkeF0pe1xuICBjYXNlICdpJzogY2FzZSAnZCc6IGNhc2UgJ3UnOiBicmVhaztcbiAgY2FzZSAnYic6IGJhc2UgPSAyOyBpZihhbHQpIHByZWZpeCA9IFwiMGJcIjsgYnJlYWs7XG4gIGNhc2UgJ28nOiBiYXNlID0gODsgaWYoYWx0KSBwcmVmaXggPSBcIjBvXCI7IGJyZWFrO1xuICBjYXNlICd4JzogYmFzZSA9IDE2OyBpZihhbHQpIHByZWZpeCA9IFwiMHhcIjsgYnJlYWs7XG4gIGNhc2UgJ1gnOiBiYXNlID0gMTY7IGlmKGFsdCkgcHJlZml4ID0gXCIwWFwiOyBjYXMgPSAxOyBicmVhaztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiVW5zdXBwb3J0ZWQgZm9ybWF0ICdcIiArIGZtdCArIFwiJ1wiKTtcbiAgfVxuICBpZiAoZGlyKSBwYWQgPSAnICc7XG4gIHZhciByZXMgPSB6MS50b1N0cmluZyhiYXNlKTtcbiAgaWYgKGNhcyA9PT0gMSkge1xuICAgIHJlcyA9IHJlcy50b1VwcGVyQ2FzZSgpO1xuICB9XG4gIHZhciBzaXplID0gcmVzLmxlbmd0aDtcbiAgaWYgKHBhZCA9PSAnICcpIHtcbiAgICBpZihkaXIpIHtcbiAgICAgIHJlcyA9IHNpZ24gKyBwcmVmaXggKyByZXM7XG4gICAgICBmb3IoO3Jlcy5sZW5ndGg8d2lkdGg7KSByZXMgPSByZXMgKyBwYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHNpZ24gKyBwcmVmaXggKyByZXM7XG4gICAgICBmb3IoO3Jlcy5sZW5ndGg8d2lkdGg7KSByZXMgPSBwYWQgKyByZXM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwcmUgPSBzaWduICsgcHJlZml4O1xuICAgIGZvcig7cmVzLmxlbmd0aCtwcmUubGVuZ3RoPHdpZHRoOykgcmVzID0gcGFkICsgcmVzO1xuICAgIHJlcyA9IHByZSArIHJlcztcbiAgfVxuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKHJlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fel9vZl9qc19zdHJpbmdfYmFzZVxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3RvX2pzX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24ganNvb196X29mX2pzX3N0cmluZ19iYXNlKGJhc2UsIHMpIHtcbiAgaWYgKGJhc2UgPT0gMCkgeyAvLyBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvWmFyaXRoL2Jsb2IvYjhkYmFmNDhhNzkyNzA2MWRmNjk5YWQ3Y2U2NDJiYjRmMWZlNTMwOC9jYW1sX3ouYyNMNTk4XG4gICAgYmFzZSA9IDEwO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgc2lnbiA9IDE7XG4gICAgaWYoc1twXSA9PSAnLScpIHsgc2lnbiA9IC0xOyBwKysgfVxuICAgIGVsc2UgaWYgKHNbcF0gPT0gJysnKSB7IHArKyB9XG4gICAgaWYgKHNbcF0gPT0gJzAnKSB7XG4gICAgICBwICsrO1xuICAgICAgaWYgKHMubGVuZ3RoID09IHApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmMgPSBzW3BdO1xuICAgICAgICBpZiAoYmMgPT0gJ28nIHx8IGJjID09ICdPJykge1xuICAgICAgICAgIGJhc2UgPSA4O1xuICAgICAgICB9IGVsc2UgaWYgKGJjID09ICd4JyB8fCBiYyA9PSAnWCcpIHtcbiAgICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgIH0gZWxzZSBpZiAoYmMgPT0gJ2InIHx8IGJjID09ICdCJykge1xuICAgICAgICAgIGJhc2UgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJhc2UgIT0gMTApIHtcbiAgICAgICAgICBzID0gcy5zdWJzdHJpbmcocCsxKTtcbiAgICAgICAgICBpZihzaWduID09IC0xKSBzID0gXCItXCIgKyBzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vcmVtb3ZlIGxlYWRpbmcgJysnXG4gIGlmIChzWzBdID09ICcrJykgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAvL3JlbW92ZSBsZWFkaW5nICcwJ3NcbiAgcyA9IHMucmVwbGFjZSgvXjArLywgJycpO1xuICAvL25vcm1hbGl6ZSBcImVtcHR5XCIgbnVtYmVyc1xuICBpZihzID09ICctJyB8fCBzID09ICcnKSBzID0gJzAnO1xuXG4gIGZ1bmN0aW9uIGRpZ2l0KGNvZGUpe1xuICAgIGlmKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgcmV0dXJuIGNvZGUgLSA0ODtcbiAgICBpZihjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSByZXR1cm4gY29kZSAtIDk3ICsgMTA7XG4gICAgaWYoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSByZXR1cm4gY29kZSAtIDY1ICsgMTA7XG4gIH1cbiAgdmFyIGkgPSAwO1xuICBpZihzW2ldID09ICctJykgaSsrO1xuICBmb3IoIDsgaSA8IHMubGVuZ3RoIDsgaSsrKXtcbiAgICB2YXIgYyA9IGRpZ2l0KHMuY2hhckNvZGVBdChpKSk7XG4gICAgaWYoYyA9PSB1bmRlZmluZWQgfHwgYyA+PSBiYXNlKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5vZl9zdWJzdHJpbmdfYmFzZTogaW52YWxpZCBkaWdpdFwiKTtcbiAgfVxuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHMsIGJhc2UpKTtcbiAgXG59XG5cbi8vZXh0ZXJuYWwgb2Zfc3Vic3RyaW5nX2Jhc2U6IGludCAtPiBzdHJpbmcgLT4gcG9zOmludCAtPiBsZW46aW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2Zfc3Vic3RyaW5nX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZywganNvb196X29mX2pzX3N0cmluZ19iYXNlLCBjYW1sX3RvX2pzX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIG1sX3pfb2Zfc3Vic3RyaW5nX2Jhc2UoYmFzZSwgcywgcG9zLCBsZW4pIHtcbiAgaWYocG9zICE9IDAgfHwgbGVuICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHMgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzKTtcbiAgICBpZiAocy5sZW5ndGggLSBwb3MgPCBsZW4pIHtcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloub2Zfc3Vic3RyaW5nX2Jhc2U6IGludmFsaWQgb2Zmc2V0IG9yIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KHMuc2xpY2UocG9zLHBvcytsZW4pKTtcbiAgfVxuICByZXR1cm4ganNvb196X29mX2pzX3N0cmluZ19iYXNlKGJhc2UsIGNhbWxfdG9fanNfc3RyaW5nKHMpKTtcbn1cblxuLy9leHRlcm5hbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X2NvbXBhcmUgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9jb21wYXJlKHoxLCB6Mikge1xuICByZXR1cm4gYmlnSW50KHoxKS5jb21wYXJlKGJpZ0ludCh6MikpO1xufVxuXG4vL2V4dGVybmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9lcXVhbCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X2VxdWFsKHoxLCB6Mikge1xuICByZXR1cm4gYmlnSW50KHoxKS5lcXVhbHMoYmlnSW50KHoyKSk7XG59XG5cbi8vZXh0ZXJuYWwgc2lnbjogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfc2lnbiBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X3NpZ24oejEpIHtcbiAgcmV0dXJuIGJpZ0ludCh6MSkuY29tcGFyZShiaWdJbnQuemVybyk7XG59XG5cbi8vZXh0ZXJuYWwgZ2NkOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9nY2Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfZ2NkKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50LmdjZChiaWdJbnQoejEpLCBiaWdJbnQoejIpKS5hYnMoKSk7XG59XG5cbi8vZXh0ZXJuYWwgbnVtYml0czogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfbnVtYml0cyBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X251bWJpdHMoejEpIHtcbiAgejEgPSBiaWdJbnQoejEpLmFicygpO1xuICB2YXIgbiA9IDA7XG4gIHZhciB1cHBlckJvdW5kID0gYmlnSW50Lm9uZTtcbiAgd2hpbGUgKHVwcGVyQm91bmQubGVxKHoxKSkge1xuICAgIG4gKz0gMTtcbiAgICB1cHBlckJvdW5kID0gdXBwZXJCb3VuZC5tdWx0aXBseSgyKTtcbiAgfVxuICByZXR1cm4gbjsgLy8gMl57bi0xfSA8PSB8eHwgPCAyXm5cbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X2ZpdHNfaW50IGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfZml0c19pbnQoejEpIHtcbiAgaWYoejEgPT0gKHoxIHwgMCkpIHJldHVybiAxO1xuICBlbHNlIHJldHVybiAwO1xufVxuXG4vL2V4dGVybmFsIGZpdHNfaW50MzI6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9maXRzX2ludDMyXG4vL1JlcXVpcmVzOiBtbF96X2ZpdHNfaW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfaW50MzIoejEpIHtcbiAgcmV0dXJuIG1sX3pfZml0c19pbnQoejEpO1xufVxuXG4vL2V4dGVybmFsIGZpdHNfaW50NjQ6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9maXRzX2ludDY0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfZml0c19pbnQ2NCh6MSkge1xuICB6MSA9IGJpZ0ludCh6MSlcbiAgaWYgKHoxLmNvbXBhcmUoYmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSkgPD0gMCAmJiB6MS5jb21wYXJlKGJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpKSA+PSAwKVxuICAgIHJldHVybiAxXG4gIGVsc2VcbiAgICByZXR1cm4gMFxufVxuXG4vL2V4dGVybmFsIGZpdHNfbmF0aXZlaW50OiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19uYXRpdmVpbnRcbi8vUmVxdWlyZXM6IG1sX3pfZml0c19pbnRcbmZ1bmN0aW9uIG1sX3pfZml0c19uYXRpdmVpbnQoejEpIHtcbiAgcmV0dXJuIG1sX3pfZml0c19pbnQoejEpO1xufVxuXG4vL2V4dGVybmFsIHBvd206IHQgLT4gdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcG93bVxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZSwgbWxfel9pbnZlcnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIG1sX3pfcG93bSh6MSwgejIsIHozKSB7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICB6MSA9IGJpZ0ludCh6MSk7XG4gIHoyID0gYmlnSW50KHoyKTtcbiAgejMgPSBiaWdJbnQoejMpO1xuICBpZih6My5lcXVhbHMoemVybykpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgaWYoejMuYWJzKCkuZXF1YWxzKG9uZSkpIHJldHVybiAwO1xuICBpZih6Mi5lcXVhbHMoemVybykpIHJldHVybiAxO1xuICBpZih6Mi5sdCgwKSkge1xuICAgIHZhciBpbnYgPSBiaWdJbnQobWxfel9pbnZlcnQoejEsIHozKSk7XG4gICAgdmFyIHIgPSBpbnYubW9kUG93KHoyLm5lZ2F0ZSgpLCB6Myk7XG4gICAgaWYoci5sdCh6ZXJvKSkgciA9IHIuYWRkKHozLmFicygpKTtcbiAgICByZXR1cm4gbWxfel9ub3JtYWxpemUocik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHIgPSBiaWdJbnQoejEpLm1vZFBvdyh6MiwgejMpO1xuICAgIGlmKHIubHQoemVybykpIHIgPSByLmFkZCh6My5hYnMoKSk7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xuICB9XG59XG5cbi8vZXh0ZXJuYWwgcG93bjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcG93XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfZmFpbHdpdGgsIG1sX3pfbm9ybWFsaXplLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX3pfcG93KHoxLCBpMSkge1xuICBpMSA9IGJpZ0ludChpMSk7XG4gIGlmIChpMS5sdChiaWdJbnQoMCkpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5wb3c6IGV4cG9uZW50IG11c3QgYmUgbm9ubmVnYXRpdmVcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkucG93KGkxKSk7XG59XG5cbi8vZXh0ZXJuYWwgaGFzaDogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gbWxfel9oYXNoKHoxKSB7XG4gIHZhciBhID0gYmlnSW50KHoxKS50b0FycmF5KE1hdGgucG93KDIsIDMyKSk7XG4gIHZhciBhY2MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBhY2MgPSBjYW1sX2hhc2hfbWl4X2ludChhY2MsIGEudmFsdWVbaV0pO1xuICB9XG4gIGlmKGEudmFsdWUubGVuZ3RoICUgMiAhPSAwKSB7XG4gICAgYWNjID0gY2FtbF9oYXNoX21peF9pbnQoYWNjLCAwKTtcbiAgfVxuICBpZihhLmlzTmVnYXRpdmUpe1xuICAgIGFjYyA9IGFjYyArIDFcbiAgfVxuICByZXR1cm4gYWNjIHwgMFxufVxuXG4vL2V4dGVybmFsIHRvX2JpdHM6IHQgLT4gc3RyaW5nXG4vL1Byb3ZpZGVzOiBtbF96X3RvX2JpdHMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZywgY2FtbF9zdHJfcmVwZWF0LCBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfdG9fYml0cyh6MSkge1xuICB6MSA9IGJpZ0ludCh6MSkuYWJzKCk7XG4gIHZhciByZXMgPSBcIlwiO1xuICB3aGlsZSghejEuZXF1YWxzKGJpZ0ludCgwKSkpe1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHoxLm1vZChiaWdJbnQoMjU2KSkpO1xuICAgIHoxID0gejEuZGl2aWRlKGJpZ0ludCgyNTYpKTtcbiAgfVxuICB3aGlsZShyZXMubGVuZ3RoICUgNCAhPSAwKXtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTtcbiAgfVxuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKHJlcyk7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfYml0czogc3RyaW5nIC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfYml0cyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X29mX2JpdHMoejEpIHtcbiAgdmFyIHIgPSBiaWdJbnQuemVyb1xuICB2YXIgYmFzZTEgPSBiaWdJbnQoMjU2KTtcbiAgdmFyIGJhc2UgPSBiaWdJbnQub25lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHoxKTsgaSsrKXtcbiAgICB2YXIgZCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQoejEsaSk7XG4gICAgciA9IGJpZ0ludChiYXNlKS5tdWx0aXBseShkKS5hZGQocik7XG4gICAgYmFzZSA9IGJpZ0ludChiYXNlKS5tdWx0aXBseShiYXNlMSk7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xufVxuXG4vL2V4dGVybmFsIHBvd21fc2VjOiB0IC0+IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Bvd21fc2VjXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfZmFpbHdpdGgsIG1sX3pfcG93bSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Bvd21fc2VjKHoxLCB6MiwgejMpIHtcbiAgejMgPSBiaWdJbnQoejMpLmFicygpO1xuICAvLyBwb3dtX3NlYyByZXF1aXJlcyB0aGF0IHRoZSBleHBvbmVudCBiZSBwb3NpdGl2ZVxuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZiAoYmlnSW50KHoyKS5sdChvbmUpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5wb3dtX3NlYzogZXhwb25lbnQgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcbiAgfVxuICBpZiAoIWJpZ0ludCh6MykuYW5kKG9uZSkuZXF1YWxzKG9uZSkpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLnBvd21fc2VjOiBtb2R1bHVzIG11c3QgYmUgb2RkXCIpO1xuICB9XG4gIHJldHVybiBtbF96X3Bvd20oejEsIHoyLCB6Mylcbn1cblxuLy9leHRlcm5hbCByb290OiB0IC0+IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Jvb3Rcbi8vUmVxdWlyZXM6IG1sX3pfcG93LCAgYmlnSW50LCBtbF96X25vcm1hbGl6ZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Jvb3QoeiwgaSkge1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgeiA9IGJpZ0ludCh6KTtcblxuICBpZiAoaSAlIDIgPT09IDAgJiYgei5sdCh6ZXJvKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucm9vdDogZXZlbiByb290IG9mIGEgbmVnYXRpdmUgbnVtYmVyXCIpO1xuICB9XG5cbiAgaWYgKHouZXF1YWxzKHplcm8pIHx8IHouZXF1YWxzKG9uZSkpIHtcbiAgICByZXR1cm4gbWxfel9ub3JtYWxpemUoeik7XG4gIH1cblxuICB2YXIgc3RhcnQgPSB6ZXJvO1xuICB2YXIgZW5kID0gejtcbiAgdmFyIGFucyA9IG51bGw7XG5cbiAgdmFyIHR3byA9IGJpZ0ludCgyKTtcblxuICB3aGlsZSAoc3RhcnQubGVxKGVuZCkpXG4gIHtcbiAgICB2YXIgbWlkID0gc3RhcnQuYWRkKGVuZCkuZGl2aWRlKHR3byk7XG4gICAgdmFyIHBvID0gbWlkLnBvdyhpKTtcbiAgICBpZiAocG8uZXF1YWxzKHopKSB7XG4gICAgICByZXR1cm4gbWxfel9ub3JtYWxpemUobWlkKTtcbiAgICB9IGVsc2UgaWYgKHBvLmx0KHopKSB7XG4gICAgICBzdGFydCA9IG1pZC5uZXh0KCk7XG4gICAgICBhbnMgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IG1pZC5wcmV2KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShhbnMpO1xufVxuXG4vL2V4dGVybmFsIGludmVydDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfaW52ZXJ0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfZ2NkZXh0X2ludGVybiwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfaW52ZXJ0KGEsIG4pIHtcbiAgLy8gQmVjYXVzZSBbYS5tb2RJbnYobildIHByb2R1Y2VzIGRpZmZlcmVudCByZXN1bHRzIGZvciBlZGdlIGNhc2VzLFxuICAvLyB3ZSB3cm90ZSBvdXIgb3duIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGdjZGV4dF9pbnRlcm4uXG4gIGEgPSBiaWdJbnQoYSk7XG4gIG4gPSBiaWdJbnQobik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZihuLmFicygpLmVxdWFscyhvbmUpKVxuICAgIHJldHVybiAwO1xuICBpZiAobi5lcXVhbHMoemVybykgJiYgYS5hYnMoKS5lcXVhbHMob25lKSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGlmIChuLmVxdWFscyh6ZXJvKSB8fCBhLmVxdWFscyh6ZXJvKSkge1xuICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgfVxuICB2YXIgeCA9IG1sX3pfZ2NkZXh0X2ludGVybihhLCBuKTtcbiAgdmFyIHIgPSBiaWdJbnQoeFsyXSk7XG4gIHZhciB0bXAgPSBiaWdJbnQoYSkubXVsdGlwbHkocikubW9kKG4pO1xuICBpZih0bXAubHQoemVybykpIHRtcCA9IHRtcC5hZGQobi5hYnMoKSk7XG4gIGlmKHIubHQoemVybykpIHIgPSByLmFkZChuLmFicygpKTtcbiAgaWYodG1wLmVxdWFscyhvbmUpKSB7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xuICB9XG4gIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbn1cblxuLy9leHRlcm5hbCBwZXJmZWN0X3Bvd2VyOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfcGVyZmVjdF9wb3dlclxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ZhaWx3aXRoLCBtbF96X251bWJpdHMsIG1sX3pfcm9vdCwgbWxfel9wb3dcbmZ1bmN0aW9uIG1sX3pfcGVyZmVjdF9wb3dlcih6KSB7XG4gIC8vIFJldHVybiB0cnVlIGlmIG9wIGlzIGEgcGVyZmVjdCBwb3dlciwgaS5lLiwgaWYgdGhlcmUgZXhpc3QgaW50ZWdlcnMgYSBhbmRcbiAgLy8gYiwgd2l0aCBiID4gMSwgc3VjaCB0aGF0IG9wID0gYV5iLlxuICAvLyBPdGhlcndpc2UgZmFsc2UuXG4gIHogPSBiaWdJbnQoeik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuXG4gIGlmICh6LmVxdWFscyh6ZXJvKSB8fCB6LmVxdWFscyhvbmUpIHx8IHouZXF1YWxzKG9uZS5uZWdhdGUoKSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB2YXIgbG9nMnogPSBtbF96X251bWJpdHMoei5hYnMoKSk7XG4gIGZvciAodmFyIGIgPSAyOyBiIDw9IGxvZzJ6OyBiKyspIHtcbiAgICBpZih6Lmx0KHplcm8pICYmIGIgJSAyID09IDApIGNvbnRpbnVlO1xuICAgIHZhciB6cCA9IHouYWJzKCk7XG4gICAgdmFyIHAgPSBiaWdJbnQobWxfel9yb290KHpwLCBiKSk7XG4gICAgaWYoei5sdCh6ZXJvKSkgcCA9IHAubmVnYXRlKCk7XG4gICAgdmFyIHIgPSBiaWdJbnQobWxfel9wb3cocCwgYikpO1xuICAgIGlmICh6LmVxdWFscyhyKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL2V4dGVybmFsIHBlcmZlY3Rfc3F1YXJlOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfcGVyZmVjdF9zcXVhcmVcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9yb290XG5mdW5jdGlvbiBtbF96X3BlcmZlY3Rfc3F1YXJlKHopIHtcbiAgeiA9IGJpZ0ludCh6KTtcbiAgaWYgKHoubHQoYmlnSW50KDApKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciByb290ID0gYmlnSW50KG1sX3pfcm9vdCh6LCAyKSk7XG4gIGlmIChyb290Lm11bHRpcGx5KHJvb3QpLmVxKHopKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIDBcbiAgfTtcbn1cblxuLy9leHRlcm5hbCBwcm9iYWJfcHJpbWU6IHQgLT4gaW50IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9wcm9iYWJfcHJpbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9wcm9iYWJfcHJpbWUoeiwgaSkge1xuICBpZiAoYmlnSW50KHopLmlzUHJvYmFibGVQcmltZShpKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vZXh0ZXJuYWwgbmV4dHByaW1lOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbmV4dHByaW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X25leHRwcmltZSh6MSkge1xuICAvLyBJbnRlcmVzdGluZ2x5LCB0aGUgemFyaXRoIG5leHRfcHJpbWUgb25seSByZXR1cm5zIFxuICAvLyBwcm9iYWJhbGlzdGljIHByaW1lcy4gIFdlIGRvIHRoZSBzYW1lLCB3aXRoIHRoZSBcbiAgLy8gc2FtZSBwcm9iYWJsaXN0aWMgcGFyYW1ldGVyIG9mIDI1LlxuICAvLyBodHRwczovL2Zvc3NpZXMub3JnL2RveC9nbXAtNi4xLjIvbXB6XzJuZXh0cHJpbWVfOGNfc291cmNlLmh0bWxcbiAgXG4gIHoxID0gYmlnSW50KHoxKVxuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICB2YXIgdHdvID0gYmlnSW50KDIpO1xuXG4gIGlmICh6MS5sdChvbmUpIHx8IHoxLmVxdWFscyhvbmUpKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBpZiAoejEuYW5kKG9uZSkuZXF1YWxzKG9uZSkpIHtcbiAgICB6MSA9IHoxLmFkZCh0d28pO1xuICB9IGVsc2Uge1xuICAgIHoxID0gejEuYWRkKG9uZSk7XG4gIH1cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh6MS5pc1Byb2JhYmxlUHJpbWUoMjUpKSB7XG4gICAgICByZXR1cm4gbWxfel9ub3JtYWxpemUoejEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6MSA9IHoxLmFkZCh0d28pXG4gICAgfVxuICB9XG59XG5cbi8vZXh0ZXJuYWwgZXh0cmFjdDogdCAtPiBpbnQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZXh0cmFjdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9leHRyYWN0KHoxLCBwb3MsIGxlbikge1xuICB6MSA9IGJpZ0ludCh6MSk7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZSh6MS5zaGlmdFJpZ2h0KHBvcykuYW5kKGJpZ0ludCgyKS5wb3cobGVuKS5zdWJ0cmFjdCgxKSkpO1xufVxuXG4vL2V4dGVybmFsIGdjZGV4dF9pbnRlcm46IHQgLT4gdCAtPiAodCAqIHQgKiBib29sKVxuLy9Qcm92aWRlczogbWxfel9nY2RleHRfaW50ZXJuXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2djZGV4dF9pbnRlcm4oejEsIHoyKSB7XG4gIHoxID0gYmlnSW50KHoxKTtcbiAgejIgPSBiaWdJbnQoejIpO1xuICB2YXIgZ2NkID0gYmlnSW50LmdjZCh6MSx6Mik7XG4gIHZhciBhID0gejE7XG4gIHZhciBiID0gejI7XG4gIHZhciB4ID0gYmlnSW50KDApO1xuICB2YXIgbGFzdHggPSBiaWdJbnQoMSk7XG4gIHZhciB5ID0gYmlnSW50KDEpO1xuICB2YXIgbGFzdHkgPSBiaWdJbnQoMSk7XG4gIHZhciBxLCB0LCByO1xuICBpZih6MS5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgfVxuICB3aGlsZSghYi5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgIHEgPSBhLmRpdmlkZShiKTtcbiAgICByID0gYS5zdWJ0cmFjdChxLm11bHRpcGx5KGIpKTtcbiAgICB0ID0geDtcbiAgICB4ID0gbGFzdHguc3VidHJhY3QocS5tdWx0aXBseSh4KSk7XG4gICAgbGFzdHggPSB0O1xuICAgIHQgPSB5O1xuICAgIHkgPSBsYXN0eS5zdWJ0cmFjdChxLm11bHRpcGx5KHkpKTtcbiAgICBsYXN0eSA9IHQ7XG4gICAgYSA9IGI7XG4gICAgYiA9IHI7XG4gIH1cbiAgaWYoYS5sdChiaWdJbnQoMCkpKVxuICAgIHJldHVybiBbMCxtbF96X25vcm1hbGl6ZShhLm5lZ2F0ZSgpKSxtbF96X25vcm1hbGl6ZShsYXN0eC5uZWdhdGUoKSksMV1cbiAgZWxzZVxuICAgIHJldHVybiBbMCxtbF96X25vcm1hbGl6ZShhKSxtbF96X25vcm1hbGl6ZShsYXN0eCksMV1cbn1cblxuLy9leHRlcm5hbCBzcXJ0OiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc3FydFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X3Jvb3QsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfel9zcXJ0KHoxKSB7XG4gIHZhciB6ID0gYmlnSW50KHoxKTtcbiAgdmFyIHplcm8gPSBiaWdJbnQoMCk7XG4gIGlmICh6Lmx0KHplcm8pKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5zcXJ0OiBzcXVhcmUgcm9vdCBvZiBhIG5lZ2F0aXZlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gbWxfel9yb290KHosIDIpO1xufVxuXG4vL2V4dGVybmFsIHNxcnRfcmVtOiB0IC0+ICh0ICogdClcbi8vUHJvdmlkZXM6IG1sX3pfc3FydF9yZW1cbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9yb290LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3NxcnRfcmVtKHopIHtcbiAgeiA9IGJpZ0ludCh6KTtcbiAgdmFyIHplcm8gPSBiaWdJbnQoMCk7XG4gIGlmICh6Lmx0KHplcm8pKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5zcXJ0X3JlbTogc3F1YXJlIHJvb3Qgb2YgYSBuZWdhdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgdmFyIHJvb3QgPSBiaWdJbnQobWxfel9yb290KHosIDIpKTtcbiAgdmFyIG11bCA9IHJvb3QubXVsdGlwbHkocm9vdCk7XG4gIHZhciBkaWZmID0gei5zdWJ0cmFjdChtdWwpO1xuICByZXR1cm4gWzAsIG1sX3pfbm9ybWFsaXplKHJvb3QpLCBtbF96X25vcm1hbGl6ZShkaWZmKV1cbn1cblxuLy9leHRlcm5hbCB0cmFpbGluZ196ZXJvczogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfdHJhaWxpbmdfemVyb3MgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel90cmFpbGluZ196ZXJvcyh6KSB7XG4gIHogPSBiaWdJbnQoeikuYWJzKCk7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZiAoei5lcXVhbHMoemVybykpIHtcbiAgICAvLyBtYXhfaW50IGluIDMyYml0XG4gICAgcmV0dXJuIDB4N2ZmZmZmZmY7XG4gIH1cbiAgdmFyIGkgPSAwXG4gIHogPSB6Lnhvcih6LnByZXYoKSkuc2hpZnRSaWdodCgxKTtcbiAgZm9yIChpID0gMDsgIXouZXF1YWxzKGJpZ0ludC56ZXJvKTsgaSsrKSB7XG4gICAgeiA9IHouc2hpZnRSaWdodCgxKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuLy9leHRlcm5hbCBwb3Bjb3VudDogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfcG9wY291bnRcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel9wb3Bjb3VudCh6KSB7XG4gIHogPSBiaWdJbnQoeik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICB2YXIgb25lID0gYmlnSW50KDEpO1xuICBpZiAoei5sdCh6ZXJvKSkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyAhei5lcXVhbHMoemVybyk7IGkrKykge1xuICAgIHogPSB6LmFuZCh6LnByZXYoKSk7XG4gIH1cbiAgaWYoaSAhPSAoaXwwKSkgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX25hbWVkX3ZhbHVlKFwibWxfel9vdmVyZmxvd1wiKSk7XG4gIHJldHVybiBpfDA7XG59XG5cbi8vZXh0ZXJuYWwgaGFtZGlzdDogdCAtPiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9oYW1kaXN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfcG9wY291bnQsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel9oYW1kaXN0KHoxLCB6Mikge1xuICBpZihiaWdJbnQoejEpLmlzTmVnYXRpdmUoKSAhPSBiaWdJbnQoejIpLmlzTmVnYXRpdmUgKCkpe1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIGlmKCh6MSAhPSAoejEgfCAwKSB8fCB6MiAhPSAoejIgfCAwKSkgJiYgKGJpZ0ludCh6MSkuaXNOZWdhdGl2ZSgpIHx8IGJpZ0ludCh6MikuaXNOZWdhdGl2ZSAoKSkpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouaGFtZGlzdDogbmVnYXRpdmUgYXJndW1lbnRzXCIpO1xuICB9XG4gIHJldHVybiBtbF96X3BvcGNvdW50KGJpZ0ludCh6MSkueG9yKGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBzaXplOiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9zaXplIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfc2l6ZSh6MSkge1xuICAvLyBDbGFpbSB0byBiZSBhIDMyLWJpdCBhcmNoaXRlY3R1cmUuXG4gIHJldHVybiBiaWdJbnQoejEpLnRvQXJyYXkoTWF0aC5wb3coMiwgMzIpKS52YWx1ZS5sZW5ndGg7XG59XG5cbi8vZXh0ZXJuYWwgZGl2ZXhhY3Q6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2RpdmV4YWN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfZGl2XG5mdW5jdGlvbiBtbF96X2RpdmV4YWN0KHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9kaXYoejEsIHoyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF96YXJpdGhfbWFyc2hhbFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBjYW1sX3phcml0aF9tYXJzaGFsKHdyaXRlciwgdiwgc3opIHtcbiAgdiA9IGJpZ0ludCh2KTtcbiAgdmFyIGJpdHMgPSB2LnRvQXJyYXkoTWF0aC5wb3coMiwgMzIpKTtcbiAgd3JpdGVyLndyaXRlKDgsIGJpdHMuaXNOZWdhdGl2ZSA/MSA6IDApO1xuICB2YXIgYmxvY2sgPSBiaXRzLnZhbHVlLmxlbmd0aDtcbiAgdmFyIGxlbiA9IGJsb2NrICogNDtcbiAgd3JpdGVyLndyaXRlKDMyLCBsZW4pO1xuICBmb3IodmFyIGkgPSBibG9jayAtIDE7IGkgPj0gMDsgaSAtLSl7XG4gICAgd3JpdGVyLndyaXRlKDgsIChiaXRzLnZhbHVlW2ldID4+PiAwICkgJiAweGZmKTtcbiAgICB3cml0ZXIud3JpdGUoOCwgKGJpdHMudmFsdWVbaV0gPj4+IDggKSAmIDB4ZmYpO1xuICAgIHdyaXRlci53cml0ZSg4LCAoYml0cy52YWx1ZVtpXSA+Pj4gMTYpICYgMHhmZik7XG4gICAgd3JpdGVyLndyaXRlKDgsIChiaXRzLnZhbHVlW2ldID4+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBzelswXSA9IDQgKiAoMSArICgoKGxlbiArIDMpIC8gNCkgfCAwKSk7XG4gIHN6WzFdID0gOCAqICgxICsgKCgobGVuICsgNykgLyA4KSB8IDApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF96YXJpdGhfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfZmFpbHdpdGgsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBjYW1sX3phcml0aF91bm1hcnNoYWwocmVhZGVyLCBzeikge1xuICB2YXIgbmVnYXRlO1xuICBzd2l0Y2gocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6IG5lZ2F0ZSA9IHRydWU7IGJyZWFrO1xuICBjYXNlIDA6IG5lZ2F0ZSA9IGZhbHNlOyBicmVhaztcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB6IChtYWxmb3JtZWQgaW5wdXQpXCIpO1xuICB9XG4gIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICB2YXIgeCA9IGJpZ0ludCgwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbiAvIDQ7IGkrKyl7XG4gICAgdmFyIHkgPSBiaWdJbnQocmVhZGVyLnJlYWQ4dSgpKTtcbiAgICB5ID0geS5hZGQoKHJlYWRlci5yZWFkOHUoKSkgPDwgOCk7XG4gICAgeSA9IHkuYWRkKChyZWFkZXIucmVhZDh1KCkpIDw8IDE2KTtcbiAgICB5ID0geS5hZGQoKChyZWFkZXIucmVhZDh1KCkpIDw8IDI0KSA+Pj4gMCk7XG4gICAgeCA9IHkuc2hpZnRMZWZ0KGkgKiAzMikuYWRkKHgpO1xuICB9XG4gIGlmKG5lZ2F0ZSkgeCA9IHgubmVnYXRlKCk7XG4gIHN6WzBdID0gbGVuICsgNDtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHgpXG59XG4iLCIvLy8vLy8vLy8gQ09SRV9LRVJORUxcblxuLy9Qcm92aWRlczogY29yZV9hcnJheV91bnNhZmVfaW50X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxudmFyIGNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0ID0gY2FtbF9hcnJheV9ibGl0XG4vL1Byb3ZpZGVzOiBjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbnZhciBjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0ID0gY2FtbF9hcnJheV9ibGl0XG5cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX3RpbWVfbnNfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX3RvX2pzX3N0cmluZywgY2FtbF9qc190b19zdHJpbmdcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX3RpbWVfbnNfZm9ybWF0KHRpbWUsZm9ybWF0KXtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gIHZhciBmb3JtYXRqcyA9IGNhbWxfdG9fanNfc3RyaW5nKGZvcm1hdCk7XG4gIHZhciBqc3RyaW5nID0gam9vX2dsb2JhbF9vYmplY3Quc3RyZnRpbWUoZm9ybWF0anMsIGQpO1xuICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcoanN0cmluZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX2NvbXBhY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19jb21wYWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX2hlYXBfY2h1bmtzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19oZWFwX2NodW5rcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX2hlYXBfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX2hlYXBfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19tYWpvcl9jb2xsZWN0aW9uc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfbWFqb3JfY29sbGVjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWFqb3Jfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21ham9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWlub3JfY29sbGVjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21pbm9yX2NvbGxlY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21pbm9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfcHJvbW90ZWRfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX3Byb21vdGVkX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfdG9wX2hlYXBfd29yZHNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX3RvcF9oZWFwX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuXG4vL1Byb3ZpZGVzOiBDb3JlX2tlcm5lbF9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2tcbmZ1bmN0aW9uIENvcmVfa2VybmVsX2hlYXBfYmxvY2tfaXNfaGVhcF9ibG9jayh4KXtcbiAgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTtcbn1cblxuLy9Qcm92aWRlczogY29yZV9tZDVfZmRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luLCBjYW1sX21kNV9jaGFuLCBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbmZ1bmN0aW9uIGNvcmVfbWQ1X2ZkKGZkKXtcbiAgICB2YXIgaWMgPSBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbWxfbWQ1X2NoYW4oaWMsIC0xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBjYW1sX21sX2Nsb3NlX2NoYW5uZWwoaWMpO1xuICAgIH1cbn1cblxuLy8gUHJvdmlkZXM6IGNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmdcbi8vIFJlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfYmxpdF9zdHJpbmcsIGNhbWxfY3JlYXRlX2J5dGVzLCBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuZnVuY3Rpb24gY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZyhidWYsIG9mcywgbGVuLCByZXMpe1xuICAgIHZhciBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIoYnVmLCBvZnMsIGJ5dGVzLCAwLCBsZW4pO1xuICAgIHZhciByZXMyID0gY2FtbF9tZDVfc3RyaW5nKGJ5dGVzLCAwLCBsZW4pO1xuICAgIGNhbWxfYmxpdF9zdHJpbmcocmVzMiwgMCwgcmVzLCAwLCAxNik7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vQmlnc3RyaW5nXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfZnJvbVxuZnVuY3Rpb24gYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1Yih2X2JzdHIpIHtcbiAgaWYgKHZfYnN0ci5kYXRhMiAhPSBudWxsKSB7XG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdzdHJpbmdfZGVzdHJveTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgfVxuXG4gIGlmICh2X2JzdHIuaGFzT3duUHJvcGVydHkoJ19faXNfZGVhbGxvY2F0ZWQnKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19kZXN0cm95OiBiaWdzdHJpbmcgaXMgYWxyZWFkeSBkZWFsbG9jYXRlZFwiKTtcbiAgfVxuXG4gIHZhciBkZXN0cm95ZWRfZGF0YSA9IG5ldyB2X2JzdHIuZGF0YS5fX3Byb3RvX18uY29uc3RydWN0b3IoMCk7XG4gIHZhciBkZXN0cm95ZWRfYmlnc3RyaW5nID1cbiAgICAgIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGVzdHJveWVkX2RhdGEsIG51bGwsIHZfYnN0ci5kYXRhX3R5cGUsIHZfYnN0ci5raW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2X2JzdHIubGF5b3V0LCBbMF0pO1xuICBkZXN0cm95ZWRfYmlnc3RyaW5nLl9faXNfZGVhbGxvY2F0ZWQgPSB0cnVlO1xuXG4gIC8vIE11dGF0ZSB0aGUgb3JpZ2luYWwgYmlnc3RyaW5nIGluLXBsYWNlLCB0byBzaW11bGF0ZSB3aGF0IHRoZSBDIHZlcnNpb24gZG9lc1xuICBPYmplY3QuYXNzaWduKHZfYnN0ciwgZGVzdHJveWVkX2JpZ3N0cmluZyk7XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19yZWFsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX2Zyb20sIGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ19yZWFsbG9jKGJpZ3N0cmluZywgc2l6ZSkge1xuICAgIGlmIChiaWdzdHJpbmcuZGF0YTIgIT0gbnVsbCkge1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdzdHJpbmcudW5zYWZlX2Rlc3Ryb3lfYW5kX3Jlc2l6ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoYmlnc3RyaW5nLmhhc093blByb3BlcnR5KCdfX2lzX2RlYWxsb2NhdGVkJykpIHtcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX3JlYWxsb2M6IGJpZ3N0cmluZyBpcyBhbHJlYWR5IGRlYWxsb2NhdGVkXCIpO1xuICAgIH1cblxuICAgIHZhciBuZXdfZGF0YSA9IG5ldyBiaWdzdHJpbmcuZGF0YS5fX3Byb3RvX18uY29uc3RydWN0b3Ioc2l6ZSk7XG4gICAgbmV3X2RhdGEuc2V0KGJpZ3N0cmluZy5kYXRhLnNsaWNlKDAsIHNpemUpKTtcbiAgICB2YXIgbmV3X2JpZ3N0cmluZyA9XG4gICAgICAgIGNhbWxfYmFfY3JlYXRlX2Zyb20obmV3X2RhdGEsIG51bGwsIGJpZ3N0cmluZy5kYXRhX3R5cGUsIGJpZ3N0cmluZy5raW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ3N0cmluZy5sYXlvdXQsIFtzaXplXSk7XG5cbiAgICBiaWdzdHJpbmdfZGVzdHJveV9zdHViKGJpZ3N0cmluZyk7XG5cbiAgICByZXR1cm4gbmV3X2JpZ3N0cmluZztcbn1cbiIsIi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCh2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9jbGVhcl9jYW1sX2JhY2t0cmFjZV9wb3MgY29uc3RcbmZ1bmN0aW9uIEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zKHgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KSB7XG4gIHZhciBuID0gMzI7XG4gIHZhciB5O1xuICB5ID0geCA+PjE2OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0xNjsgeCA9IHk7IH1cbiAgeSA9IHggPj4gODsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDg7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDQ7IGlmICh5ICE9IDApIHsgbiA9IG4gLSA0OyB4ID0geTsgfVxuICB5ID0geCA+PiAyOyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gMjsgeCA9IHk7IH1cbiAgeSA9IHggPj4gMTsgaWYgKHkgIT0gMCkgcmV0dXJuIG4gLSAyO1xuICByZXR1cm4gbiAtIHg7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X2NseiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X2Nseih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF90b19pbnQzMlxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHooeCkge1xuICB2YXIgbiA9IDY0O1xuICB2YXIgeTtcbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMzIpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtMzI7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDE2KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLTE2OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA4KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSA4OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA0KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSA0OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAyKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSAyOyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHJldHVybiBuIC0gMjtcbiAgcmV0dXJuIG4gLSBjYW1sX2ludDY0X3RvX2ludDMyKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIoYmFzZSwgZXhwb25lbnQpIHtcbiAgdmFyIG9uZSA9IDE7XG4gIHZhciBtdWwgPSBbb25lLCBiYXNlLCBvbmUsIG9uZV07XG4gIHZhciByZXMgPSBvbmU7XG4gIHdoaWxlICghZXhwb25lbnQ9PTApIHtcbiAgICBtdWxbMV0gPSAobXVsWzFdICogbXVsWzNdKSB8IDA7XG4gICAgbXVsWzJdID0gKG11bFsxXSAqIG11bFsxXSkgfCAwO1xuICAgIG11bFszXSA9IChtdWxbMl0gKiBtdWxbMV0pIHwgMDtcbiAgICByZXMgPSAocmVzICogbXVsW2V4cG9uZW50ICYgM10pIHwgMDtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50ID4+IDI7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YihiYXNlLCBleHBvbmVudCkge1xuICB2YXIgb25lID0gWzI1NSwxLDAsMF07XG4gIHZhciBtdWwgPSBbb25lLCBiYXNlLCBvbmUsIG9uZV07XG4gIHZhciByZXMgPSBvbmU7XG4gIHdoaWxlICghY2FtbF9pbnQ2NF9pc196ZXJvKGV4cG9uZW50KSkge1xuICAgIG11bFsxXSA9IGNhbWxfaW50NjRfbXVsKG11bFsxXSwgbXVsWzNdKTtcbiAgICBtdWxbMl0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFsxXSk7XG4gICAgbXVsWzNdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzJdLCBtdWxbMV0pO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfbXVsKHJlcywgbXVsW2V4cG9uZW50WzFdICYgM10pO1xuICAgIGV4cG9uZW50ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZChleHBvbmVudCwgMik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9oYXNoX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsMSwwLHMpXG59XG4vL1Byb3ZpZGVzOiBCYXNlX2hhc2hfZG91YmxlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9kb3VibGUoZCkge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsMSwwLGQpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2FtX3Rlc3RpbmcgY29uc3Rcbi8vV2Vha2RlZlxuZnVuY3Rpb24gQmFzZV9hbV90ZXN0aW5nKHgpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5LGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKSwwLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLG9mcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUEksIGJ1dCB3aXRob3V0IHRoZSB3ZWFrIHNlbWFudGljc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA8IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gM1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NyZWF0ZSAobikge1xuICBpZiAobiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgdmFyIHggPSBbMjUxLFwiY2FtbF9lcGhlX2xpc3RfaGVhZFwiXTtcbiAgeC5sZW5ndGggPSBjYW1sX2VwaGVfa2V5X29mZnNldCArIG47XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfc2V0KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHJldHVybiAoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXT09PXVuZGVmaW5lZCk/MDp4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXQsY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF93ZWFrX2dldCh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jaGVjayBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NoZWNrKHgsIGkpIHtcbiAgaWYoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIT09dW5kZWZpbmVkICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSAhPT0wKVxuICAgIHJldHVybiAxO1xuICBlbHNlXG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIC8vIG1pbnVzIG9uZSBiZWNhdXNlIGNhbWxfYXJyYXlfYmxpdCB3b3JrcyBvbiBvY2FtbCBhcnJheVxuICBjYW1sX2FycmF5X2JsaXQoYTEsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTEgLSAxLFxuICAgICAgICAgICAgICAgICAgYTIsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTIgLSAxLFxuICAgICAgICAgICAgICAgICAgbGVuKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jcmVhdGVcbnZhciBjYW1sX2VwaGVfY3JlYXRlID0gY2FtbF93ZWFrX2NyZWF0ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19ibGl0XG52YXIgY2FtbF9lcGhlX2JsaXRfa2V5ID0gY2FtbF93ZWFrX2JsaXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRcbnZhciBjYW1sX2VwaGVfZ2V0X2tleSA9IGNhbWxfd2Vha19nZXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldF9jb3B5XG52YXIgY2FtbF9lcGhlX2dldF9rZXlfY29weSA9IGNhbWxfd2Vha19nZXRfY29weVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY2hlY2tcbnZhciBjYW1sX2VwaGVfY2hlY2tfa2V5ID0gY2FtbF93ZWFrX2NoZWNrXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2tleSh4LCBpLCB2KSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIFswLCB2XSlcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2tleSh4LCBpKSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIDApXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NCA9IGNhbWxfaGFzaF9taXhfaW50NjQ7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCA9IGNhbWxfaGFzaF9taXhfaW50O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXQgPSBjYW1sX2hhc2hfbWl4X2Zsb2F0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmcgPSBjYW1sX2hhc2hfbWl4X3N0cmluZztcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG5mdW5jdGlvbiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZShzZWVkKSB7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChzZWVkKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy8gUHJvdmlkZXM6IGRlZmVycmVkX3J1blxuZnVuY3Rpb24gZGVmZXJyZWRfcnVuKGZ1bmMpIHtcbiAgdmFyIGRlZmVycmVkID0ge1xuICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbihmdW5jKSAvLyB0aGUgb2NhbWwgdHlwZXMgZG9uJ3Qga25vdyB0aGlzLCBidXQgZnVuYyBjYW4gYWN0dWFsbHkgYmUgYXN5bmMgb3Igc3luY1xuICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGRlZmVycmVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgZGVmZXJyZWQuaXNFcnJvciA9IHRydWU7XG4gICAgICAgIGRlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLFxuICAgIGlzRXJyb3I6IGZhbHNlLFxuICAgIGlzRGV0ZXJtaW5lZDogZmFsc2UsXG4gIH07XG4gIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX21hcFxuZnVuY3Rpb24gZGVmZXJyZWRfbWFwKGRlZmVycmVkLCBmdW5jKSB7XG4gIHZhciBuZXdEZWZlcnJlZCA9IHtcbiAgICBwcm9taXNlOiBkZWZlcnJlZC5wcm9taXNlXG4gICAgICAudGhlbihmdW5jKSAvLyB0aGUgb2NhbWwgdHlwZXMgZG9uJ3Qga25vdyB0aGlzLCBidXQgZnVuYyBjYW4gYWN0dWFsbHkgYmUgYXN5bmMgb3Igc3luY1xuICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIG5ld0RlZmVycmVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIG5ld0RlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBuZXdEZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgbmV3RGVmZXJyZWQuaXNFcnJvciA9IHRydWU7XG4gICAgICAgIG5ld0RlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLFxuICAgIGlzRXJyb3I6IGZhbHNlLFxuICAgIGlzRGV0ZXJtaW5lZDogZmFsc2UsXG4gIH07XG4gIHJldHVybiBuZXdEZWZlcnJlZDtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX2JpbmRcbmZ1bmN0aW9uIGRlZmVycmVkX2JpbmQoZGVmZXJyZWQsIGZ1bmMpIHtcbiAgdmFyIG5ld0RlZmVycmVkID0ge1xuICAgIHByb21pc2U6IGRlZmVycmVkLnByb21pc2VcbiAgICAgIC50aGVuKGZ1bmMpXG4gICAgICAudGhlbihmdW5jdGlvbiAoYW5vdGhlckRlZmVycmVkKSB7XG4gICAgICAgIHJldHVybiBhbm90aGVyRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbmV3RGVmZXJyZWQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbmV3RGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIG5ld0RlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICBuZXdEZWZlcnJlZC5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgbmV3RGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSksXG4gICAgaXNFcnJvcjogZmFsc2UsXG4gICAgaXNEZXRlcm1pbmVkOiBmYWxzZSxcbiAgfTtcbiAgcmV0dXJuIG5ld0RlZmVycmVkO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfdXBvblxuZnVuY3Rpb24gZGVmZXJyZWRfdXBvbihkZWZlcnJlZCwgZnVuYykge1xuICBkZWZlcnJlZC5wcm9taXNlXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgZnVuYyhkZWZlcnJlZC52YWx1ZSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfdXBvbl9leG5cbmZ1bmN0aW9uIGRlZmVycmVkX3Vwb25fZXhuKGRlZmVycmVkLCBmdW5jKSB7XG4gIGRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgZnVuYyhkZWZlcnJlZC52YWx1ZSk7XG4gIH0pO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfaXNfZGV0ZXJtaW5lZFxuZnVuY3Rpb24gZGVmZXJyZWRfaXNfZGV0ZXJtaW5lZChkZWZlcnJlZCkge1xuICByZXR1cm4gZGVmZXJyZWQuaXNEZXRlcm1pbmVkO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfcGVla1xuZnVuY3Rpb24gZGVmZXJyZWRfcGVlayhkZWZlcnJlZCkge1xuICBpZiAoIWRlZmVycmVkLmlzRGV0ZXJtaW5lZCB8fCBkZWZlcnJlZC5pc0Vycm9yKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIFswLCBkZWZlcnJlZC52YWx1ZV07XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF92YWx1ZV9leG5cbmZ1bmN0aW9uIGRlZmVycmVkX3ZhbHVlX2V4bihkZWZlcnJlZCkge1xuICBpZiAoIWRlZmVycmVkLmlzRGV0ZXJtaW5lZCkge1xuICAgIHRocm93IEVycm9yKFwiRGVmZXJyZWQgaGFzIG5vdCByZXR1cm5lZCB5ZXQuXCIpO1xuICB9XG4gIGlmIChkZWZlcnJlZC5pc0Vycm9yKSB7XG4gICAgdGhyb3cgZGVmZXJyZWQuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIGRlZmVycmVkLnZhbHVlO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfcmV0dXJuXG5mdW5jdGlvbiBkZWZlcnJlZF9yZXR1cm4odmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlOiBQcm9taXNlLnJlc29sdmUodmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc0RldGVybWluZWQ6IHRydWUsXG4gIH07XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9jcmVhdGVcbmZ1bmN0aW9uIGRlZmVycmVkX2NyZWF0ZShwcm9taXNlX2NyZWF0b3IpIHtcbiAgdmFyIGRlZmVycmVkID0ge1xuICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBwcm9taXNlX2NyZWF0b3IocmVzb2x2ZSk7XG4gICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBkZWZlcnJlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICBkZWZlcnJlZC5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgZGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSksXG4gICAgaXNFcnJvcjogZmFsc2UsXG4gICAgaXNEZXRlcm1pbmVkOiBmYWxzZSxcbiAgfTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfdG9fcHJvbWlzZVxuZnVuY3Rpb24gZGVmZXJyZWRfdG9fcHJvbWlzZShkZWZlcnJlZCkge1xuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX29mX3Byb21pc2VcbmZ1bmN0aW9uIGRlZmVycmVkX29mX3Byb21pc2UocHJvbWlzZSkge1xuICB2YXIgZGVmZXJyZWQgPSB7XG4gICAgcHJvbWlzZTogcHJvbWlzZVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGRlZmVycmVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgZGVmZXJyZWQuaXNFcnJvciA9IHRydWU7XG4gICAgICAgIGRlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLFxuICAgIGlzRXJyb3I6IGZhbHNlLFxuICAgIGlzRGV0ZXJtaW5lZDogZmFsc2UsXG4gIH07XG4gIHJldHVybiBkZWZlcnJlZDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkJPTDpcbiAgICAgICAgaWYocG9zID4gMCAmJiBzW3BvcyAtIDFdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FT0w6XG4gICAgICAgIGlmKHBvcyA8IHMubGVuZ3RoICYmIHNbcG9zXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuV09SREJPVU5EQVJZOlxuICAgICAgICBpZihwb3MgPT0gMCkge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzWzBdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkgIT0gaXNfd29yZF9sZXR0ZXIoc1twb3NdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkJFR0dST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5zdGFydH19KTtcbiAgICAgICAgZ3JvdXAuc3RhcnQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVOREdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLmVuZH19KTtcbiAgICAgICAgZ3JvdXAuZW5kID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5SRUZHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIGlmKGdyb3VwLnN0YXJ0IDwgMCB8fCBncm91cC5lbmQgPCAwKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgZm9yICh2YXIgaSA9IGdyb3VwLnN0YXJ0OyBpIDwgZ3JvdXAuZW5kOyBpKyspe1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZihzW2ldICE9IHNbcG9zXSkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFT1BUOlxuICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkgcG9zKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVNUQVI6XG4gICAgICAgIHdoaWxlIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKVxuICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFUExVUzpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICB9IHdoaWxlIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5BQ0NFUFQ6XG4gICAgICAgIHJldHVybiBhY2NlcHQoKTtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5HT1RPOlxuICAgICAgICBwYyA9IHBjICsgc2FyZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUFVTSEJBQ0s6XG4gICAgICAgIHB1c2goe3Bvczoge3BjOiBwYyArIHNhcmcsIHR4dDogcG9zfX0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TRVRNQVJLOlxuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOnJlX3JlZ2lzdGVyLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDogdWFyZyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZV9yZWdpc3Rlclt1YXJnXX19KTtcbiAgICAgICAgcmVfcmVnaXN0ZXJbdWFyZ10gPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIRUNLUFJPR1JFU1M6XG4gICAgICAgIGlmIChyZV9yZWdpc3Rlclt1YXJnXSA9PT0gcG9zKSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGVjb2RlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiByZV9tYXRjaF9pbXBsO1xufSgpO1xuXG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9mb3J3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9mb3J3YXJkKHJlLCBzLCBwb3MpIHtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnNlYXJjaF9mb3J3YXJkXCIpXG4gIHdoaWxlIChwb3MgPD0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfYmFja3dhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2JhY2t3YXJkKHJlLCBzLCBwb3MpIHtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnNlYXJjaF9iYWNrd2FyZFwiKVxuICB3aGlsZSAocG9zID49IDApIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MtLTtcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cblxuLy9Qcm92aWRlczogcmVfc3RyaW5nX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3N0cmluZ19tYXRjaChyZSxzLHBvcyl7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zdHJpbmdfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3BhcnRpYWxfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfcGFydGlhbF9tYXRjaChyZSxzLHBvcyl7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5wYXJ0aWFsX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAxKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9yZXBsYWNlbWVudF90ZXh0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2dldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy8gZXh0ZXJuYWwgcmVfcmVwbGFjZW1lbnRfdGV4dDogc3RyaW5nIC0+IGludCBhcnJheSAtPiBzdHJpbmcgLT4gc3RyaW5nXG5mdW5jdGlvbiByZV9yZXBsYWNlbWVudF90ZXh0KHJlcGwsZ3JvdXBzLG9yaWcpIHtcbiAgdmFyIHJlcGwgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlcGwpO1xuICB2YXIgbGVuID0gcmVwbC5sZW5ndGg7XG4gIHZhciBvcmlnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvcmlnKTtcbiAgdmFyIHJlcyA9IFwiXCI7IC8vcmVzdWx0XG4gIHZhciBuID0gMDsgLy8gY3VycmVudCBwb3NpdGlvblxuICB2YXIgY3VyOyAvL2N1cnJlbnQgY2hhclxuICB2YXIgc3RhcnQsIGVuZCwgYztcbiAgd2hpbGUobiA8IGxlbil7XG4gICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICBpZihjdXIgIT0gJ1xcXFwnKXtcbiAgICAgIHJlcyArPSBjdXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYobiA9PSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogaWxsZWdhbCBiYWNrc2xhc2ggc2VxdWVuY2VcIik7XG4gICAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgICAgc3dpdGNoKGN1cil7XG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgcmVzICs9IGN1cjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcwJzogY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6XG4gICAgICBjYXNlICc1JzogY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICAgIGMgPSArY3VyO1xuICAgICAgICBpZiAoYyoyID49IGdyb3Vwcy5sZW5ndGggLSAxIClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IHJlZmVyZW5jZSB0byB1bm1hdGNoZWQgZ3JvdXBcIiApO1xuICAgICAgICBzdGFydCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcyxjKjIpO1xuICAgICAgICBlbmQgPSBjYW1sX2FycmF5X2dldChncm91cHMsIGMqMiArMSk7XG4gICAgICAgIGlmIChzdGFydCA9PSAtMSlcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IHJlZmVyZW5jZSB0byB1bm1hdGNoZWQgZ3JvdXBcIik7XG4gICAgICAgIHJlcys9b3JpZy5zbGljZShzdGFydCxlbmQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlcyArPSAoJ1xcXFwnICArIGN1cik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHJlcyk7IH1cbiIsIi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXRcbnZhciBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0IFxuLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyclxudmFyIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnJcblxuLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2JlZm9yZV90ZXN0XG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyLCBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0XG5mdW5jdGlvbiBleHBlY3RfdGVzdF9jb2xsZWN0b3JfYmVmb3JlX3Rlc3QgKHZvdXRwdXQsIHZzdGRvdXQsIHZzdGRlcnIpe1xuICBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyID0gY2FtbF9tbF9jaGFubmVsc1t2c3RkZXJyXTtcbiAgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dCA9IGNhbWxfbWxfY2hhbm5lbHNbdnN0ZG91dF07XG4gIHZhciBvdXRwdXQgPSBjYW1sX21sX2NoYW5uZWxzW3ZvdXRwdXRdO1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRvdXRdID0gb3V0cHV0O1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRlcnJdID0gb3V0cHV0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2FmdGVyX3Rlc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnIsIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXRcbmZ1bmN0aW9uIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9hZnRlcl90ZXN0ICh2c3Rkb3V0LCB2c3RkZXJyKXtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3Rkb3V0XSA9IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQ7XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZGVycl0gPSBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczpjYW1sX291dF9jaGFubmVsX3Bvc19mZFxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9vdXRfY2hhbm5lbF9wb3NfZmQoY2hhbil7XG4gIHZhciBpbmZvID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuXTtcbiAgcmV0dXJuIGluZm8ub2Zmc2V0XG59XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QobG9jLHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHVuZGVmX21vZHVsZSAoX3gpIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJnKGNhbWxfZ2xvYmFsX2RhdGEuVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUsIGxvYyk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCAoc2hhcGUsc3RydWN0LGlkeCl7XG4gICAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgICAgc3dpdGNoKHNoYXBlKXtcbiAgICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICAgIHN0cnVjdFtpZHhdPXtmdW46dW5kZWZfbW9kdWxlfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6Ly9sYXp5XG4gICAgICAgIHN0cnVjdFtpZHhdPVsyNDYsIHVuZGVmX21vZHVsZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICAgIHN0cnVjdFtpZHhdPVtdO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBbMF07XG4gICAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgICBsb29wKHNoYXBlWzFdW2ldLHN0cnVjdFtpZHhdLGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDE6Ly9WYWx1ZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IHNoYXBlWzFdO1xuICAgICAgfVxuICB9XG4gIHZhciByZXMgPSBbXTtcbiAgbG9vcChzaGFwZSxyZXMsMCk7XG4gIHJldHVybiByZXNbMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlLHJlYWwseCkge1xuICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgc3dpdGNoKHNoYXBlKXtcbiAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgIGNhc2UgMTovL2xhenlcbiAgICBjYXNlIDI6Ly9jbGFzc1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX3VwZGF0ZV9kdW1teShyZWFsLHgpO1xuICAgIH1cbiAgZWxzZVxuICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGVbMV1baV0scmVhbFtpXSx4W2ldKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjYW1sX3N0cmluZ191bnNhZmVfc2V0KGRzdCwgZHN0X29mZiArIGksIGNhbWxfYmFfZ2V0XzEoc3JjLCBzcmNfb2ZmICsgaSkpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX2JsaXRfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xLCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjYW1sX2JhX3NldF8xKGRzdCwgZHN0X29mZiArIGksIGNhbWxfYmFfZ2V0XzEoc3JjLCBzcmNfb2ZmICsgaSkpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX2JsaXRfZnJvbV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMSwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNhbWxfYmFfc2V0XzEoZHN0LCBkc3Rfb2ZmICsgaSwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzcmMsIHNyY19vZmYgKyBpKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfbWVtY21wX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMSwgY2FtbF9pbnRfY29tcGFyZVxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfbWVtY21wX2JpZ3N0cmluZyhiYTEsIGJhMV9vZmYsIGJhMiwgYmEyX29mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGNhbWxfaW50X2NvbXBhcmUoY2FtbF9iYV9nZXRfMShiYTEsIGJhMV9vZmYgKyBpKSwgY2FtbF9iYV9nZXRfMShiYTIsIGJhMl9vZmYgKyBpKSk7XG4gICAgaWYgKGMgIT0gMCkgcmV0dXJuIGNcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfbWVtY21wX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMSwgY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfbWVtY21wX3N0cmluZyhiYSwgYmFfb2ZmLCBzdHIsIHN0cl9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBjYW1sX2ludF9jb21wYXJlKGNhbWxfYmFfZ2V0XzEoYmEsIGJhX29mZiArIGkpLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHN0ciwgc3RyX29mZiArIGkpKTtcbiAgICBpZiAoYyAhPSAwKSByZXR1cm4gY1xuICB9XG4gIHJldHVybiAwO1xufVxuIiwiLy8vLy8vLy8vIFRJTUVfTk9XXG5cbi8vUHJvdmlkZXM6IHRpbWVfbm93X25hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2hfb3JfemVyb1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbnZhciBtc190b19uYW5vID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxMDAwKjEwMDApO1xuZnVuY3Rpb24gdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvKCl7XG4gICAgdmFyIG1zID0gRGF0ZS5ub3coKTtcbiAgICAvLyBtdWx0aXBsZSBieSB0d28gLSBpbnQ2MyBpbnRlZ2VycyBhcmUgc2hpZnRlZCB0byB0aGUgbGVmdFxuICAgIHZhciBtc19pNjMgPSBjYW1sX2ludDY0X29mX2Zsb2F0KG1zKjIpO1xuICAgIHJldHVybiBjYW1sX2ludDY0X211bChtc19pNjMsbXNfdG9fbmFubyk7XG59XG4iXX0=
