// Generated by js_of_ocaml 3.7.1
(function(joo_global_object)
   {(function()
       {var
         DefaultLocale=
          {days:
           ["Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"],
           shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
           months:
           ["January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"],
           shortMonths:
           ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"],
           AM:"AM",
           PM:"PM",
           am:"am",
           pm:"pm",
           formats:
           {D:"%m/%d/%y",
            F:"%Y-%m-%d",
            R:"%H:%M",
            T:"%H:%M:%S",
            X:"%T",
            c:"%a %b %d %X %Y",
            r:"%I:%M:%S %p",
            v:"%e-%b-%Y",
            x:"%D"}},
         defaultStrftime=new Strftime(DefaultLocale,0,false),
         isCommonJS=typeof module !== "undefined",
         namespace;
        if(isCommonJS)
         {namespace = module.exports = adaptedStrftime;
          namespace.strftime = deprecatedStrftime;
          if(joo_global_object)joo_global_object.strftime = adaptedStrftime}
        else
         {namespace
          =
          joo_global_object
          ||
          function(){return this || (1,eval)("this")}();
          namespace.strftime = adaptedStrftime}
        var
         _require=isCommonJS?"require('strftime')":"strftime",
         _deprecationWarnings={};
        function deprecationWarning(name,instead)
         {if(! _deprecationWarnings[name])
           {if
             (typeof console
              !==
              "undefined"
              &&
              typeof console.warn
              ==
              "function")
             console.warn
              ("[WARNING] "
               +
               name
               +
               " is deprecated and will be removed in version 1.0. Instead, use `"
               +
               instead
               +
               "`.");
            _deprecationWarnings[name] = true}}
        namespace.strftimeTZ = deprecatedStrftimeTZ;
        namespace.strftimeUTC = deprecatedStrftimeUTC;
        namespace.localizedStrftime = deprecatedStrftimeLocalized;
        function adaptForwards(fn)
         {fn.localize = defaultStrftime.localize.bind(defaultStrftime);
          fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
          fn.utc = defaultStrftime.utc.bind(defaultStrftime)}
        adaptForwards(adaptedStrftime);
        function adaptedStrftime(fmt,d,locale)
         {if(d && d.days){locale = d;d = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + "(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        adaptForwards(deprecatedStrftime);
        function deprecatedStrftime(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftime(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftime(format, [date])`",
             _require + "(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeTZ(fmt,d,locale,timezone)
         {if
           ((typeof locale == "number" || typeof locale == "string")
            &&
            timezone
            ==
            null)
           {timezone = locale;locale = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
             +
             _require
             +
             ".localize(locale); s.timezone(tz)(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, tz)`",
             "var s = "
             +
             _require
             +
             ".timezone(tz); s(format, [date])` or `"
             +
             _require
             +
             ".timezone(tz)(format, [date])");
          var
           strftime=
            (locale?defaultStrftime.localize(locale):defaultStrftime).timezone
             (timezone);
          return strftime(fmt,d)}
        var utcStrftime=defaultStrftime.utc();
        function deprecatedStrftimeUTC(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, date, locale)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).utc(); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, [date])`",
             "var s = " + _require + ".utc(); s(format, [date])");
          var strftime=locale?utcStrftime.localize(locale):utcStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeLocalized(locale)
         {deprecationWarning
           ("`" + _require + ".localizedStrftime(locale)`",
            _require + ".localize(locale)");
          return defaultStrftime.localize(locale)}
        if(typeof Date.now !== "function")
         Date.now = function(){return + new Date()};
        function Strftime(locale,customTimezoneOffset,useUtcTimezone)
         {var
           _locale=locale || DefaultLocale,
           _customTimezoneOffset=customTimezoneOffset || 0,
           _useUtcBasedDate=useUtcTimezone || false,
           _cachedDateTimestamp=0,
           _cachedDate;
          function _strftime(format,date)
           {var timestamp;
            if(! date)
             {var currentTimestamp=Date.now();
              if(currentTimestamp > _cachedDateTimestamp)
               {_cachedDateTimestamp = currentTimestamp;
                _cachedDate = new Date(_cachedDateTimestamp);
                timestamp = _cachedDateTimestamp;
                if(_useUtcBasedDate)
                 _cachedDate
                 =
                 new
                  Date
                  (_cachedDateTimestamp
                   +
                   getTimestampToUtcOffsetFor(_cachedDate)
                   +
                   _customTimezoneOffset)}
              date = _cachedDate}
            else
             {timestamp = date.getTime();
              if(_useUtcBasedDate)
               date
               =
               new
                Date
                (date.getTime()
                 +
                 getTimestampToUtcOffsetFor(date)
                 +
                 _customTimezoneOffset)}
            return _processFormat(format,date,_locale,timestamp)}
          function _processFormat(format,date,locale,timestamp)
           {var
             resultString="",
             padding=null,
             isInScope=false,
             length=format.length,
             extendedTZ=false;
            for(var i=0;i < length;i++)
             {var currentCharCode=format.charCodeAt(i);
              if(isInScope === true)
               {if(currentCharCode === 45)
                 {padding = "";continue}
                else
                 if(currentCharCode === 95)
                  {padding = " ";continue}
                 else
                  if(currentCharCode === 48)
                   {padding = "0";continue}
                  else
                   if(currentCharCode === 58)
                    {if(extendedTZ)
                      if
                       (typeof console
                        !==
                        "undefined"
                        &&
                        typeof console.warn
                        ==
                        "function")
                       console.warn
                        ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                     extendedTZ = true;
                     continue}
                switch(currentCharCode)
                 {case 65:resultString += locale.days[date.getDay()];break;
                  case 66:
                   resultString += locale.months[date.getMonth()];break;
                  case 67:
                   resultString
                   +=
                   padTill2(Math.floor(date.getFullYear() / 100),padding);
                   break;
                  case 68:
                   resultString
                   +=
                   _processFormat(locale.formats.D,date,locale,timestamp);
                   break;
                  case 70:
                   resultString
                   +=
                   _processFormat(locale.formats.F,date,locale,timestamp);
                   break;
                  case 72:
                   resultString += padTill2(date.getHours(),padding);break;
                  case 73:
                   resultString += padTill2(hours12(date.getHours()),padding);
                   break;
                  case 76:
                   resultString += padTill3(Math.floor(timestamp % 1000));
                   break;
                  case 77:
                   resultString += padTill2(date.getMinutes(),padding);break;
                  case 80:
                   resultString += date.getHours() < 12?locale.am:locale.pm;
                   break;
                  case 82:
                   resultString
                   +=
                   _processFormat(locale.formats.R,date,locale,timestamp);
                   break;
                  case 83:
                   resultString += padTill2(date.getSeconds(),padding);break;
                  case 84:
                   resultString
                   +=
                   _processFormat(locale.formats.T,date,locale,timestamp);
                   break;
                  case 85:
                   resultString += padTill2(weekNumber(date,"sunday"),padding);
                   break;
                  case 87:
                   resultString += padTill2(weekNumber(date,"monday"),padding);
                   break;
                  case 88:
                   resultString
                   +=
                   _processFormat(locale.formats.X,date,locale,timestamp);
                   break;
                  case 89:resultString += date.getFullYear();break;
                  case 90:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += "GMT";
                   else
                    {var tzString=date.toString().match(/\(([\w\s]+)\)/);
                     resultString += tzString && tzString[1] || ""}
                   break;
                  case 97:
                   resultString += locale.shortDays[date.getDay()];break;
                  case 98:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 99:
                   resultString
                   +=
                   _processFormat(locale.formats.c,date,locale,timestamp);
                   break;
                  case 100:
                   resultString += padTill2(date.getDate(),padding);break;
                  case 101:
                   resultString
                   +=
                   padTill2(date.getDate(),padding == null?" ":padding);
                   break;
                  case 104:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 106:
                   var
                    y=new Date(date.getFullYear(),0,1),
                    day=
                     Math.ceil
                      ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                   resultString += padTill3(day);
                   break;
                  case 107:
                   resultString
                   +=
                   padTill2(date.getHours(),padding == null?" ":padding);
                   break;
                  case 108:
                   resultString
                   +=
                   padTill2
                    (hours12(date.getHours()),padding == null?" ":padding);
                   break;
                  case 109:
                   resultString += padTill2(date.getMonth() + 1,padding);break;
                  case 110:resultString += "\n";break;
                  case 111:
                   resultString
                   +=
                   String(date.getDate())
                   +
                   ordinal(date.getDate());
                   break;
                  case 112:
                   resultString += date.getHours() < 12?locale.AM:locale.PM;
                   break;
                  case 114:
                   resultString
                   +=
                   _processFormat(locale.formats.r,date,locale,timestamp);
                   break;
                  case 115:resultString += Math.floor(timestamp / 1000);break;
                  case 116:resultString += "\t";break;
                  case 117:
                   var day=date.getDay();resultString += day === 0?7:day;break;
                  case 118:
                   resultString
                   +=
                   _processFormat(locale.formats.v,date,locale,timestamp);
                   break;
                  case 119:resultString += date.getDay();break;
                  case 120:
                   resultString
                   +=
                   _processFormat(locale.formats.x,date,locale,timestamp);
                   break;
                  case 121:
                   resultString += ("" + date.getFullYear()).slice(2);break;
                  case 122:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += extendedTZ?"+00:00":"+0000";
                   else
                    {var off;
                     if(_customTimezoneOffset !== 0)
                      off = _customTimezoneOffset / (60 * 1000);
                     else
                      off = - date.getTimezoneOffset();
                     var
                      sign=off < 0?"-":"+",
                      sep=extendedTZ?":":"",
                      hours=Math.floor(Math.abs(off / 60)),
                      mins=Math.abs(off % 60);
                     resultString
                     +=
                     sign
                     +
                     padTill2(hours)
                     +
                     sep
                     +
                     padTill2(mins)}
                   break;
                  default:resultString += format[i];break}
                padding = null;
                isInScope = false;
                continue}
              if(currentCharCode === 37){isInScope = true;continue}
              resultString += format[i]}
            return resultString}
          var strftime=_strftime;
          strftime.localize
          =
          function(locale)
           {return new
                    Strftime
                    (locale || _locale,_customTimezoneOffset,_useUtcBasedDate)};
          strftime.timezone
          =
          function(timezone)
           {var
             customTimezoneOffset=_customTimezoneOffset,
             useUtcBasedDate=_useUtcBasedDate,
             timezoneType=typeof timezone;
            if(timezoneType === "number" || timezoneType === "string")
             {useUtcBasedDate = true;
              if(timezoneType === "string")
               {var
                 sign=timezone[0] === "-"?- 1:1,
                 hours=parseInt(timezone.slice(1,3),10),
                 minutes=parseInt(timezone.slice(3,5),10);
                customTimezoneOffset
                =
                sign
                *
                (60 * hours + minutes)
                *
                60
                *
                1000}
              else
               if(timezoneType === "number")
                customTimezoneOffset = timezone * 60 * 1000}
            return new Strftime(_locale,customTimezoneOffset,useUtcBasedDate)};
          strftime.utc
          =
          function(){return new Strftime(_locale,_customTimezoneOffset,true)};
          return strftime}
        function padTill2(numberToPad,paddingChar)
         {if(paddingChar === "" || numberToPad > 9)return numberToPad;
          if(paddingChar == null)paddingChar = "0";
          return paddingChar + numberToPad}
        function padTill3(numberToPad)
         {if(numberToPad > 99)return numberToPad;
          if(numberToPad > 9)return "0" + numberToPad;
          return "00" + numberToPad}
        function hours12(hour)
         {if(hour === 0)return 12;else if(hour > 12)return hour - 12;
          return hour}
        function weekNumber(date,firstWeekday)
         {firstWeekday = firstWeekday || "sunday";
          var weekday=date.getDay();
          if(firstWeekday === "monday")
           if(weekday === 0)weekday = 6;else weekday--;
          var
           firstDayOfYearUtc=Date.UTC(date.getFullYear(),0,1),
           dateUtc=Date.UTC(date.getFullYear(),date.getMonth(),date.getDate()),
           yday=Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
           weekNum=(yday + 7 - weekday) / 7;
          return Math.floor(weekNum)}
        function ordinal(number)
         {var i=number % 10,ii=number % 100;
          if(ii >= 11 && ii <= 13 || i === 0 || i >= 4)return "th";
          switch(i){case 1:return "st";case 2:return "nd";case 3:return "rd"}}
        function getTimestampToUtcOffsetFor(date)
         {return (date.getTimezoneOffset() || 0) * 60000}}
      ())}
  (function(){return this}()));
(function(joo_global_object)
   {"use strict";
    var worker_threads=require("worker_threads"),_workers;
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    var
     startWorkers=
      function()
        {var snarky_ready_resolve;
         caml_js_export_var().snarky_ready
         =
         new
          (joo_global_object.Promise)
          (function(resolve){snarky_ready_resolve = resolve});
         return function(worker_source,memory,builder)
          {joo_global_object.wasm_workers = [];
           joo_global_object.wasm_rayon_poolbuilder = builder;
           return joo_global_object.Promise.all
                    (Array.from
                      ({length:builder.numThreads()},
                       function()
                        {var
                          worker=
                           new
                            (worker_threads.Worker)
                            (worker_source,
                             {workerData:{memory:memory,receiver:builder.receiver()}});
                         joo_global_object.wasm_workers.push(worker);
                         var target=worker,type="wasm_bindgen_worker_ready";
                         return new
                                 (joo_global_object.Promise)
                                 (function(resolve)
                                   {var done=false;
                                    target.on
                                     ("message",
                                      function(data)
                                       {if(data == null || data.type !== type || done)return;
                                        done = true;
                                        resolve(worker)})})})).then
                   (function(data)
                     {snarky_ready_resolve();
                      _workers = data;
                      try {builder.build()}catch(_e){}})}}
       ();
    function wasm_ready(wasm)
     {worker_threads.parentPort.postMessage
       ({type:"wasm_bindgen_worker_ready"});
      wasm.wbg_rayon_start_worker(worker_threads.workerData.receiver)}
    var
     plonk_wasm=
      function()
        {joo_global_object.startWorkers = startWorkers;
         var env=require("env");
         if(worker_threads.isMainThread)
          {env.memory
           =
           new
            (joo_global_object.WebAssembly.Memory)
            ({initial:20,maximum:65536,shared:true});
           joo_global_object.startWorkers = startWorkers}
         else
          env.memory = worker_threads.workerData.memory;
         var plonk_wasm=require("./plonk_wasm.js");
         if(worker_threads.isMainThread)
          plonk_wasm.initThreadPool(3,__filename);
         else
          wasm_ready(plonk_wasm);
         return plonk_wasm}
       ();
    function rust_affine_to_caml_affine(pt)
     {var infinity=pt.infinity;
      if(infinity)
       {pt.free();return 0}
      else
       {var x=pt.x,y=pt.y;pt.free();return [0,[0,x,y]]}}
    function js_class_vector_of_rust_vector(v,klass)
     {var len=v.length,res=new Array(len);
      for(var i=0,pos=0;i < len;i++)res[i] = klass.__wrap(v[i]);
      return res}
    function caml_array_of_rust_vector(v,klass,convert,should_free)
     {v = js_class_vector_of_rust_vector(v,klass);
      var len=v.length,res=new Array(len + 1);
      res[0] = 0;
      for(var i=0;i < len;i++)
       {var rust_val=v[i];
        res[i + 1] = convert(rust_val);
        if(should_free)rust_val.free()}
      return res}
    function caml_poly_comm_of_rust_poly_comm(poly_comm,klass,should_free)
     {var
       rust_shifted=poly_comm.shifted,
       rust_unshifted=poly_comm.unshifted,
       caml_shifted;
      if(rust_shifted === undefined)
       caml_shifted = 0;
      else
       caml_shifted = [0,rust_affine_to_caml_affine(rust_shifted)];
      var
       caml_unshifted=
        caml_array_of_rust_vector
         (rust_unshifted,klass,rust_affine_to_caml_affine,should_free);
      return [0,caml_unshifted,caml_shifted]}
    function caml_vesta_poly_comm_of_rust(x)
     {return caml_poly_comm_of_rust_poly_comm(x,plonk_wasm.WasmGVesta,false)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_pallas_poly_comm_of_rust(x)
     {return caml_poly_comm_of_rust_poly_comm(x,plonk_wasm.WasmGPallas,false)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    var caml_global_data=[0];
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    var
     free_finalization_registry=
      new
       (joo_global_object.FinalizationRegistry)
       (function(instance_representative){instance_representative.free()});
    function free_on_finalize(x)
     {var instance_representative=x.constructor.__wrap(x.ptr);
      free_finalization_registry.register(x,instance_representative,x);
      return x}
    function caml_plonk_domain_to_rust(x,klass){return new klass(x[1],x[2])}
    function rust_affine_of_caml_affine(pt,klass)
     {var res=new klass();
      if(pt === 0)res.infinity = true;else{res.x = pt[1][1];res.y = pt[1][2]}
      return res}
    function js_class_vector_to_rust_vector(v)
     {var len=v.length,res=new (joo_global_object.Uint32Array)(len);
      for(var i=0;i < len;i++)res[i] = v[i].ptr;
      return res}
    function caml_array_to_rust_vector(v,convert,mk_new)
     {v = v.slice(1);
      for(var i=0,l=v.length;i < l;i++)
       {var class_val=convert(v[i],mk_new);
        v[i] = class_val;
        free_finalization_registry.unregister(class_val)}
      return js_class_vector_to_rust_vector(v)}
    function caml_poly_comm_to_rust_poly_comm
     (poly_comm,poly_comm_class,mk_affine)
     {var
       caml_unshifted=poly_comm[1],
       caml_shifted=poly_comm[2],
       rust_shifted=undefined;
      if(caml_shifted !== 0)
       rust_shifted = rust_affine_of_caml_affine(caml_shifted[1],mk_affine);
      var
       rust_unshifted=
        caml_array_to_rust_vector
         (caml_unshifted,rust_affine_of_caml_affine,mk_affine);
      return new poly_comm_class(rust_unshifted,rust_shifted)}
    function caml_plonk_verification_evals_to_rust
     (x,klass,poly_comm_class,mk_affine)
     {function convert(poly_comm)
       {return caml_poly_comm_to_rust_poly_comm
                (poly_comm,poly_comm_class,mk_affine)}
      function convertArray(comms)
       {var n=comms.length,res=new Array(n - 1);
        for(var i=1;i < n;i++)res[i - 1] = convert(comms[i]);
        return js_class_vector_to_rust_vector(res)}
      var
       sigma_comm=convertArray(x[1]),
       coefficients_comm=convertArray(x[2]),
       generic_comm=convert(x[3]),
       psm_comm=convert(x[4]),
       complete_add_comm=convert(x[5]),
       mul_comm=convert(x[6]),
       emul_comm=convert(x[7]),
       endomul_scalar_comm=convert(x[8]);
      return new
              klass
              (sigma_comm,
               coefficients_comm,
               generic_comm,
               psm_comm,
               complete_add_comm,
               mul_comm,
               emul_comm,
               endomul_scalar_comm)}
    function caml_plonk_verification_shifts_to_rust(x,klass)
     {return new klass(x[1],x[2],x[3],x[4],x[5],x[6],x[7])}
    function caml_plonk_verifier_index_to_rust
     (x,
      klass,
      domain_class,
      verification_evals_class,
      poly_comm_class,
      mk_affine,
      verification_shifts_class)
     {var
       domain=caml_plonk_domain_to_rust(x[1],domain_class),
       max_poly_size=x[2],
       max_quot_size=x[3],
       srs=x[4],
       evals=
        caml_plonk_verification_evals_to_rust
         (x[5],verification_evals_class,poly_comm_class,mk_affine),
       shifts=
        caml_plonk_verification_shifts_to_rust(x[6],verification_shifts_class);
      return new klass(domain,max_poly_size,max_quot_size,srs,evals,shifts)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_neg(x){return x.neg()}
    function integers_uint_of_string(s,max_val)
     {var i=0,len=caml_ml_string_length(s),negative=false;
      if(i >= len)caml_failwith("int_of_string");
      var c=caml_string_unsafe_get(s,i);
      if(c === 45){i++;negative = true}else if(c === 43)i++;
      var no_digits=true;
      max_val.hi = max_val.hi >>> 0;
      var
       ten=caml_int64_of_int32(10),
       max_base_10=max_val.udivmod(ten).quotient,
       res=caml_int64_of_int32(0);
      for(;i < len;i++)
       {var c=caml_string_unsafe_get(s,i),d=caml_parse_digit(c);
        if(d < 0 || d >= 10)break;
        no_digits = false;
        if(caml_int64_ult(max_base_10,res))return max_val;
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(ten,res),d);
        if(caml_int64_ult(res,d))return max_val}
      if(no_digits)caml_failwith("int_of_string");
      if(negative)res = caml_int64_neg(res);
      res.hi = res.hi >>> 0;
      return res}
    function caml_int64_to_int32(x){return x.toInt()}
    var
     UInt32=
      function()
        {function UInt32(x){this.value = x >>> 0}
         UInt32.prototype.caml_custom = "integers:uint32";
         return UInt32}
       ();
    function integers_uint32_of_int64(i)
     {return new UInt32(caml_int64_to_int32(i))}
    function integers_uint32_of_string(s)
     {var max_val=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      return integers_uint32_of_int64(integers_uint_of_string(s,max_val))}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    function caml_pasta_fq_copy(x,y)
     {for(var i=0,l=x.length;i < l;i++)x[i] = y[i]}
    var caml_pasta_fq_sub=plonk_wasm.caml_pasta_fq_sub;
    function caml_pasta_fq_mut_sub(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_sub(x,y))}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function column_of_rust(col)
     {var tag=col.tag,gate_type=col.gate_type,i=col.i;
      col.free();
      return {0:[tag,i],2:[tag,i],5:[tag,i],6:[tag,gate_type],7:[tag,i]}[tag]
             ||
             tag}
    function variable_of_rust(variable)
     {var col=variable.col,row=variable.row;
      variable.free();
      return [0,column_of_rust(col),row]}
    function polish_token_of_rust(token)
     {var
       tag=token.tag,
       i0=token.i0,
       i1=token.i1,
       f=token.f,
       v=variable_of_rust(token.v);
      token.free();
      return {5:[5,i0,i1],6:[6,f],7:[7,v],9:[9,i0],14:[14,i0],16:[16,i0]}[tag]
             ||
             tag}
    function wrap(ptr,klass)
     {var obj=Object.create(klass.prototype);obj.ptr = ptr;return obj}
    function index_term_of_rust(term,token_class)
     {var
       column=column_of_rust(term.column),
       coefficient=
        js_class_vector_of_rust_vector(term.coefficient,token_class);
      coefficient = coefficient.map(polish_token_of_rust);
      coefficient = [0].concat(coefficient);
      term.free();
      return [0,column,coefficient]}
    function linearization_of_rust(linearization,affine_class)
     {var
       F=affine_class === plonk_wasm.WasmGVesta?"Fq":"Fp",
       WasmPolishToken=plonk_wasm["Wasm" + F + "PolishToken"],
       WasmIndexTerm=plonk_wasm["Wasm" + F + "IndexTerm"],
       constant_term=
        js_class_vector_of_rust_vector
         (linearization.constant_term,WasmPolishToken);
      constant_term = constant_term.map(polish_token_of_rust);
      constant_term = [0].concat(constant_term);
      var
       index_terms=
        Array.from(linearization.index_terms).map
         (function(ptr)
           {var wasmIndexTerm=wrap(ptr,WasmIndexTerm);
            return index_term_of_rust(wasmIndexTerm,WasmPolishToken)});
      index_terms = [0].concat(index_terms);
      linearization.free();
      return [0,constant_term,index_terms]}
    function caml_plonk_domain_of_rust(x)
     {var log_size_of_group=x.log_size_of_group,group_gen=x.group_gen;
      x.free();
      return [0,log_size_of_group,group_gen]}
    function caml_plonk_verification_evals_of_rust(x,affine_klass)
     {function convert(poly_comm)
       {return caml_poly_comm_of_rust_poly_comm(poly_comm,affine_klass,false)}
      function convertArray(comms)
       {comms
        =
        js_class_vector_of_rust_vector(comms,plonk_wasm.WasmFqPolyComm);
        return [0].concat(comms.map(convert))}
      var
       sigma_comm=convertArray(x.sigma_comm),
       coefficients_comm=convertArray(x.coefficients_comm),
       generic_comm=convert(x.generic_comm),
       psm_comm=convert(x.psm_comm),
       complete_add_comm=convert(x.complete_add_comm),
       mul_comm=convert(x.mul_comm),
       emul_comm=convert(x.emul_comm),
       endomul_scalar_comm=convert(x.endomul_scalar_comm);
      x.free();
      return [0,
              sigma_comm,
              coefficients_comm,
              generic_comm,
              psm_comm,
              complete_add_comm,
              mul_comm,
              emul_comm,
              endomul_scalar_comm,
              0]}
    function caml_plonk_verification_shifts_of_rust(x)
     {var res=[0,x.s0,x.s1,x.s2,x.s3,x.s4,x.s5,x.s6];x.free();return res}
    var None=0;
    function caml_plonk_verifier_index_of_rust(x,affine_class)
     {var
       domain=caml_plonk_domain_of_rust(x.domain),
       max_poly_size=x.max_poly_size,
       max_quot_size=x.max_quot_size,
       srs=free_on_finalize(x.srs),
       evals=caml_plonk_verification_evals_of_rust(x.evals,affine_class),
       shifts=caml_plonk_verification_shifts_of_rust(x.shifts),
       lookup_index=None;
      x.free();
      return [0,domain,max_poly_size,max_quot_size,srs,evals,shifts,None]}
    function caml_pasta_fq_plonk_verifier_index_of_rust(x)
     {return caml_plonk_verifier_index_of_rust(x,plonk_wasm.WasmGPallas)}
    function caml_pasta_fq_plonk_verifier_index_to_rust(x)
     {return caml_plonk_verifier_index_to_rust
              (x,
               plonk_wasm.WasmFqPlonkVerifierIndex,
               plonk_wasm.WasmFqDomain,
               plonk_wasm.WasmFqPlonkVerificationEvals,
               plonk_wasm.WasmFqPolyComm,
               plonk_wasm.caml_pallas_affine_one,
               plonk_wasm.WasmFqShifts)}
    function caml_pasta_fq_plonk_verifier_index_deep_copy(x)
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_deep_copy
                (caml_pasta_fq_plonk_verifier_index_to_rust(x)))}
    var caml_pasta_fq_print=plonk_wasm.caml_pasta_fq_print;
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function integers_ulonglong_size(unit){return 8}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function bigstring_blit_bigstring_bytes_stub
     (v_bstr,v_src_pos,v_str,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var c=caml_ba_get_1(v_bstr,v_src_pos + i);
        caml_bytes_set(v_str,v_dst_pos + i,c)}
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_pasta_fp_plonk_index_create(gates,public_inputs,urs)
     {var
       t=
        plonk_wasm.caml_pasta_fp_plonk_index_create(gates,public_inputs,urs);
      return free_on_finalize(t)}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    var caml_vesta_endo_base=plonk_wasm.caml_vesta_endo_base;
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function caml_pasta_fp_plonk_gate_vector_create()
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fp_plonk_gate_vector_create())}
    function caml_pasta_fq_plonk_verifier_index_create(x)
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_create(x))}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_pasta_fq_domain_generator=
      plonk_wasm.caml_pasta_fq_domain_generator;
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_fq_srs_h(t)
     {return rust_affine_to_caml_affine(plonk_wasm.caml_fq_srs_h(t))}
    function caml_pallas_negate(x)
     {var res=plonk_wasm.caml_pallas_negate(x);
      free_on_finalize(res);
      return res}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    var caml_ml_channels=new Array();
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_plonk_wire_of_rust(wire)
     {var res=[0,wire.row,wire.col];wire.free();return res}
    function caml_plonk_wires_of_rust(wires)
     {var
       res=
        [0,
         caml_plonk_wire_of_rust(wires[0]),
         caml_plonk_wire_of_rust(wires[1]),
         caml_plonk_wire_of_rust(wires[2]),
         caml_plonk_wire_of_rust(wires[3]),
         caml_plonk_wire_of_rust(wires[4]),
         caml_plonk_wire_of_rust(wires[5]),
         caml_plonk_wire_of_rust(wires[6])];
      wires.free();
      return res}
    function caml_u8array_vector_of_rust_flat_vector(v,inner_len)
     {var
       len=v.length,
       output_len=len / inner_len,
       res=new Array(output_len + 1);
      res[0] = 0;
      for(var i=1,pos=0;i <= output_len;i++)
       {var inner_res=new (joo_global_object.Uint8Array)(inner_len);
        for(var j=0;j < inner_len;j++,pos++)inner_res[j] = v[pos];
        res[i] = inner_res}
      return res}
    function caml_plonk_gate_of_rust(gate)
     {var
       res=
        [0,
         gate.typ,
         caml_plonk_wires_of_rust(gate.wires),
         caml_u8array_vector_of_rust_flat_vector(gate.c,32)];
      gate.free();
      return res}
    function caml_pasta_fq_plonk_gate_vector_get(v,i)
     {return caml_plonk_gate_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_gate_vector_get(v,i))}
    function caml_u8array_vector_to_rust_flat_vector(v)
     {var i=1,len=v.length - i;
      if(len === 0)return new (joo_global_object.Uint8Array)(0);
      var
       inner_len=v[i].length,
       res=new (joo_global_object.Uint8Array)(len * inner_len);
      for(var pos=0;i <= len;i++)
       for(var j=0;j < inner_len;j++,pos++)res[pos] = v[i][j];
      return res}
    function caml_option_to_maybe_undefined(x){return x === 0?undefined:x[1]}
    function caml_random_oracles_to_rust(x,roKlass)
     {var
       joint_combiner_ocaml=caml_option_to_maybe_undefined(x[1]),
       joint_combiner_chal=undefined,
       joint_combiner=undefined;
      if(joint_combiner_ocaml !== undefined)
       {joint_combiner_chal = joint_combiner_ocaml[1][1];
        joint_combiner = joint_combiner_ocaml[2]}
      return new
              roKlass
              (joint_combiner_chal,
               joint_combiner,
               x[2],
               x[3],
               x[4][1],
               x[5],
               x[6],
               x[7],
               x[8],
               x[9][1],
               x[10][1],
               x[11][1])}
    var
     UInt64=
      function()
        {function UInt64(x){this.value = x}
         UInt64.prototype.caml_custom = "integers:uint64";
         return UInt64}
       ();
    function integers_uint64_of_string(s)
     {var max_val=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      return new UInt64(integers_uint_of_string(s,max_val))}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_fp_srs_h(t)
     {return rust_affine_to_caml_affine(plonk_wasm.caml_fp_srs_h(t))}
    function caml_pasta_fp_plonk_verifier_index_of_rust(x)
     {return caml_plonk_verifier_index_of_rust(x,plonk_wasm.WasmGVesta)}
    function caml_pasta_fp_plonk_verifier_index_create(x)
     {var
       vk=plonk_wasm.caml_pasta_fp_plonk_verifier_index_create(x),
       vk_caml=caml_pasta_fp_plonk_verifier_index_of_rust(vk);
      return vk_caml}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    var caml_pasta_fq_deep_copy=plonk_wasm.caml_pasta_fq_deep_copy;
    function bigstring_is_mmapped_stub(x){return 0}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function bin_prot_blit_buf_float_array_stub
     (v_src_pos,v_buf,v_dst_pos,v_arr,v_len)
     {var c,t=new Array(8);
      for(var i=0;i < v_len;i++)
       {for(var j=0;j < 8;j++)
         t[7 - j] = caml_ba_get_1(v_buf,v_src_pos + j + i * 8);
        c = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        caml_array_set(v_arr,v_dst_pos + i,c)}
      return 0}
    function caml_pasta_fq_plonk_verifier_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fq_plonk_verifier_index_write
              (append,
               caml_pasta_fq_plonk_verifier_index_to_rust(t),
               caml_jsstring_of_string(path))}
    function caml_pallas_random()
     {var res=plonk_wasm.caml_pallas_random();
      free_on_finalize(res);
      return res}
    var caml_pasta_fp_to_bigint=plonk_wasm.caml_pasta_fp_to_bigint;
    function caml_vesta_poly_comm_to_rust(x)
     {return caml_poly_comm_to_rust_poly_comm
              (x,plonk_wasm.WasmFpPolyComm,plonk_wasm.caml_vesta_affine_one)}
    function caml_pasta_fp_commitments_to_rust(x)
     {function convertArray(v)
       {var n=v.length - 1,res=new Array(n);
        for(var i=0;i < n;++i)res[i] = caml_vesta_poly_comm_to_rust(v[i + 1]);
        return js_class_vector_to_rust_vector(res)}
      var
       w_comm=convertArray(x[1]),
       z_comm=caml_vesta_poly_comm_to_rust(x[2]),
       t_comm=caml_vesta_poly_comm_to_rust(x[3]);
      return new (plonk_wasm.WasmFpProverCommitments)(w_comm,z_comm,t_comm)}
    function caml_pasta_fp_opening_proof_to_rust(x)
     {function convert_affines(affines)
       {return caml_array_to_rust_vector
                (affines,
                 rust_affine_of_caml_affine,
                 plonk_wasm.caml_vesta_affine_one)}
      var
       lr=x[1],
       delta=rust_affine_of_caml_affine(x[2],plonk_wasm.caml_vesta_affine_one),
       z1=x[3],
       z2=x[4],
       sg=rust_affine_of_caml_affine(x[5],plonk_wasm.caml_vesta_affine_one),
       len=lr.length,
       l_ocaml=new Array(len),
       r_ocaml=new Array(len);
      for(var i=1;i < len;i++){l_ocaml[i] = lr[i][1];r_ocaml[i] = lr[i][2]}
      var l=convert_affines(l_ocaml),r=convert_affines(r_ocaml);
      return new (plonk_wasm.WasmFpOpeningProof)(l,r,delta,z1,z2,sg)}
    function caml_fp_vector_to_rust(v)
     {return caml_u8array_vector_to_rust_flat_vector(v)}
    var PERMUTS_MINUS_1=6,COLUMNS=15;
    function caml_pasta_fp_proof_evaluations_to_rust(x)
     {var w=new (plonk_wasm.WasmVecVecFp)(COLUMNS);
      for(var i=0;i < COLUMNS;++i)w.push(caml_fp_vector_to_rust(x[1][i + 1]));
      var
       z=caml_fp_vector_to_rust(x[2]),
       s=new (plonk_wasm.WasmVecVecFp)(PERMUTS_MINUS_1);
      for(i = 0;i < PERMUTS_MINUS_1;++i)
       s.push(caml_fp_vector_to_rust(x[3][i + 1]));
      var
       generic_selector=caml_fp_vector_to_rust(x[4]),
       poseidon_selector=caml_fp_vector_to_rust(x[5]);
      return new
              (plonk_wasm.WasmFpProofEvaluations)
              (w,z,s,generic_selector,poseidon_selector)}
    function caml_pasta_fp_proof_to_rust(x)
     {var
       commitments=caml_pasta_fp_commitments_to_rust(x[1]),
       proof=caml_pasta_fp_opening_proof_to_rust(x[2]),
       evals0=caml_pasta_fp_proof_evaluations_to_rust(x[3][1]),
       evals1=caml_pasta_fp_proof_evaluations_to_rust(x[3][2]),
       ft_eval1=x[4],
       public_=caml_fp_vector_to_rust(x[5]),
       prev_challenges=x[6],
       chals_len=prev_challenges.length,
       prev_challenges_scalars=new (plonk_wasm.WasmVecVecFp)(chals_len - 1),
       prev_challenges_comms=new Array(chals_len - 1);
      for(var i=1;i < chals_len;i++)
       {prev_challenges_scalars.push
         (caml_fp_vector_to_rust(prev_challenges[i][1]));
        prev_challenges_comms[i - 1]
        =
        caml_vesta_poly_comm_to_rust(prev_challenges[i][2])}
      prev_challenges_comms
      =
      js_class_vector_to_rust_vector(prev_challenges_comms);
      return new
              (plonk_wasm.WasmFpProverProof)
              (commitments,
               proof,
               evals0,
               evals1,
               ft_eval1,
               public_,
               prev_challenges_scalars,
               prev_challenges_comms)}
    function caml_pasta_fp_commitments_of_rust(x)
     {function convertArray(v)
       {var
         a=js_class_vector_of_rust_vector(v,plonk_wasm.WasmFpPolyComm),
         res=[0];
        for(var i=0;i < a.length;++i)
         res.push(caml_vesta_poly_comm_of_rust(a[i]));
        return res}
      var
       w_comm=convertArray(x.w_comm),
       z_comm=caml_vesta_poly_comm_of_rust(x.z_comm),
       t_comm=caml_vesta_poly_comm_of_rust(x.t_comm);
      x.free();
      return [0,w_comm,z_comm,t_comm]}
    function caml_pasta_fp_opening_proof_of_rust(x)
     {function convert_affines(affines)
       {return caml_array_of_rust_vector
                (affines,
                 plonk_wasm.WasmGVesta,
                 rust_affine_to_caml_affine,
                 false)}
      var
       l=convert_affines(x.lr_0),
       r=convert_affines(x.lr_1),
       delta=rust_affine_to_caml_affine(x.delta),
       z1=x.z1,
       z2=x.z2,
       sg=rust_affine_to_caml_affine(x.sg);
      x.free();
      var len=l.length;
      if(len !== r.length)throw new Error("l and r lengths don't match");
      var lr=new Array(len);
      lr[0] = 0;
      for(var i=1;i < len;i++)
       {var tuple=new Array(3);
        tuple[0] = 0;
        tuple[1] = l[i];
        tuple[2] = r[i];
        lr[i] = tuple}
      return [0,lr,delta,z1,z2,sg]}
    function caml_fp_vector_of_rust(v)
     {return caml_u8array_vector_of_rust_flat_vector(v,32)}
    function caml_pasta_fp_proof_evaluations_of_rust(x)
     {function convertArray(v,n)
       {var res=[0];
        for(var i=0;i < n;++i)res.push(caml_fp_vector_of_rust(v.get(i)));
        return res}
      var
       w=convertArray(x.w,COLUMNS),
       z=caml_fp_vector_of_rust(x.z),
       s=convertArray(x.s,PERMUTS_MINUS_1),
       generic_selector=caml_fp_vector_of_rust(x.generic_selector),
       poseidon_selector=caml_fp_vector_of_rust(x.poseidon_selector);
      x.free();
      return [0,w,z,s,generic_selector,poseidon_selector]}
    function caml_pasta_fp_proof_of_rust(x)
     {var
       messages=caml_pasta_fp_commitments_of_rust(x.commitments),
       proof=caml_pasta_fp_opening_proof_of_rust(x.proof),
       evals0=caml_pasta_fp_proof_evaluations_of_rust(x.evals0),
       evals1=caml_pasta_fp_proof_evaluations_of_rust(x.evals1),
       ft_eval1=x.ft_eval1,
       public_=caml_fp_vector_of_rust(x.public_),
       prev_challenges_scalars=x.prev_challenges_scalars,
       prev_challenges_comms=
        js_class_vector_of_rust_vector
         (x.prev_challenges_comms,plonk_wasm.WasmFpPolyComm),
       chals_len=prev_challenges_comms.length,
       prev_challenges=new Array(chals_len);
      prev_challenges[0] = 0;
      for(var i=1;i < chals_len;i++)
       {var res=new Array(3);
        res[0] = 0;
        res[1] = caml_fp_vector_of_rust(prev_challenges_scalars.get(i - 1));
        res[2] = caml_vesta_poly_comm_of_rust(prev_challenges_comms[i]);
        prev_challenges[i] = res}
      return [0,
              messages,
              proof,
              [0,evals0,evals1],
              ft_eval1,
              public_,
              prev_challenges]}
    function caml_pasta_fp_plonk_proof_deep_copy(proof)
     {return caml_pasta_fp_proof_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_proof_deep_copy
                (caml_pasta_fp_proof_to_rust(proof)))}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_pasta_fq_plonk_verifier_index_dummy()
     {return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_dummy())}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    var
     bigInt=
      function(undefined)
        {"use strict";
         var
          BASE=1e7,
          LOG_BASE=7,
          MAX_INT=9007199254740992,
          MAX_INT_ARR=smallToArray(MAX_INT),
          DEFAULT_ALPHABET="0123456789abcdefghijklmnopqrstuvwxyz",
          BigInt=joo_global_object.BigInt,
          supportsNativeBigInt=typeof BigInt === "function";
         function Integer(v,radix,alphabet,caseSensitive)
          {if(typeof v === "undefined")return Integer[0];
           if(typeof radix !== "undefined")
            return + radix === 10 && ! alphabet
                    ?parseValue(v)
                    :parseBase(v,radix,alphabet,caseSensitive);
           return parseValue(v)}
         function BigInteger(value,sign)
          {this.value = value;
           this.sign = sign;
           this.isSmall = false;
           this.caml_custom = "_z"}
         BigInteger.prototype = Object.create(Integer.prototype);
         function SmallInteger(value)
          {this.value = value;
           this.sign = value < 0;
           this.isSmall = true;
           this.caml_custom = "_z"}
         SmallInteger.prototype = Object.create(Integer.prototype);
         function NativeBigInt(value)
          {this.value = value;this.caml_custom = "_z"}
         NativeBigInt.prototype = Object.create(Integer.prototype);
         function isPrecise(n){return - MAX_INT < n && n < MAX_INT}
         function smallToArray(n)
          {if(n < 1e7)return [n];
           if(n < 1e14)return [n % 1e7,Math.floor(n / 1e7)];
           return [n % 1e7,Math.floor(n / 1e7) % 1e7,Math.floor(n / 1e14)]}
         function arrayToSmall(arr)
          {trim(arr);
           var length=arr.length;
           if(length < 4 && compareAbs(arr,MAX_INT_ARR) < 0)
            switch(length)
             {case 0:return 0;
              case 1:return arr[0];
              case 2:return arr[0] + arr[1] * BASE;
              default:return arr[0] + (arr[1] + arr[2] * BASE) * BASE}
           return arr}
         function trim(v){var i=v.length;while(v[--i] === 0);v.length = i + 1}
         function createArray(length)
          {var x=new Array(length),i=- 1;while(++i < length)x[i] = 0;return x}
         function truncate(n)
          {if(n > 0)return Math.floor(n);return Math.ceil(n)}
         function add(a,b)
          {var
            l_a=a.length,
            l_b=b.length,
            r=new Array(l_a),
            carry=0,
            base=BASE,
            sum,
            i;
           for(i = 0;i < l_b;i++)
            {sum = a[i] + b[i] + carry;
             carry = sum >= base?1:0;
             r[i] = sum - carry * base}
           while(i < l_a)
            {sum = a[i] + carry;
             carry = sum === base?1:0;
             r[i++] = sum - carry * base}
           if(carry > 0)r.push(carry);
           return r}
         function addAny(a,b)
          {if(a.length >= b.length)return add(a,b);return add(b,a)}
         function addSmall(a,carry)
          {var l=a.length,r=new Array(l),base=BASE,sum,i;
           for(i = 0;i < l;i++)
            {sum = a[i] - base + carry;
             carry = Math.floor(sum / base);
             r[i] = sum - carry * base;
             carry += 1}
           while(carry > 0)
            {r[i++] = carry % base;carry = Math.floor(carry / base)}
           return r}
         BigInteger.prototype.add
         =
         function(v)
          {var n=parseValue(v);
           if(this.sign !== n.sign)return this.subtract(n.negate());
           var a=this.value,b=n.value;
           if(n.isSmall)
            return new BigInteger(addSmall(a,Math.abs(b)),this.sign);
           return new BigInteger(addAny(a,b),this.sign)};
         BigInteger.prototype.plus = BigInteger.prototype.add;
         SmallInteger.prototype.add
         =
         function(v)
          {var n=parseValue(v),a=this.value;
           if(a < 0 !== n.sign)return this.subtract(n.negate());
           var b=n.value;
           if(n.isSmall)
            {if(isPrecise(a + b))return new SmallInteger(a + b);
             b = smallToArray(Math.abs(b))}
           return new BigInteger(addSmall(b,Math.abs(a)),a < 0)};
         SmallInteger.prototype.plus = SmallInteger.prototype.add;
         NativeBigInt.prototype.add
         =
         function(v)
          {return new NativeBigInt(this.value + parseValue(v).value)};
         NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
         function subtract(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            r=new Array(a_l),
            borrow=0,
            base=BASE,
            i,
            difference;
           for(i = 0;i < b_l;i++)
            {difference = a[i] - borrow - b[i];
             if(difference < 0){difference += base;borrow = 1}else borrow = 0;
             r[i] = difference}
           for(i = b_l;i < a_l;i++)
            {difference = a[i] - borrow;
             if(difference < 0)
              difference += base;
             else
              {r[i++] = difference;break}
             r[i] = difference}
           for(;i < a_l;i++)r[i] = a[i];
           trim(r);
           return r}
         function subtractAny(a,b,sign)
          {var value;
           if(compareAbs(a,b) >= 0)
            value = subtract(a,b);
           else
            {value = subtract(b,a);sign = ! sign}
           value = arrayToSmall(value);
           if(typeof value === "number")
            {if(sign)value = - value;return new SmallInteger(value)}
           return new BigInteger(value,sign)}
         function subtractSmall(a,b,sign)
          {var l=a.length,r=new Array(l),carry=- b,base=BASE,i,difference;
           for(i = 0;i < l;i++)
            {difference = a[i] + carry;
             carry = Math.floor(difference / base);
             difference %= base;
             r[i] = difference < 0?difference + base:difference}
           r = arrayToSmall(r);
           if(typeof r === "number")
            {if(sign)r = - r;return new SmallInteger(r)}
           return new BigInteger(r,sign)}
         BigInteger.prototype.subtract
         =
         function(v)
          {var n=parseValue(v);
           if(this.sign !== n.sign)return this.add(n.negate());
           var a=this.value,b=n.value;
           if(n.isSmall)return subtractSmall(a,Math.abs(b),this.sign);
           return subtractAny(a,b,this.sign)};
         BigInteger.prototype.minus = BigInteger.prototype.subtract;
         SmallInteger.prototype.subtract
         =
         function(v)
          {var n=parseValue(v),a=this.value;
           if(a < 0 !== n.sign)return this.add(n.negate());
           var b=n.value;
           if(n.isSmall)return new SmallInteger(a - b);
           return subtractSmall(b,Math.abs(a),a >= 0)};
         SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
         NativeBigInt.prototype.subtract
         =
         function(v)
          {return new NativeBigInt(this.value - parseValue(v).value)};
         NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
         BigInteger.prototype.negate
         =
         function(){return new BigInteger(this.value,! this.sign)};
         SmallInteger.prototype.negate
         =
         function()
          {var sign=this.sign,small=new SmallInteger(- this.value);
           small.sign = ! sign;
           return small};
         NativeBigInt.prototype.negate
         =
         function(){return new NativeBigInt(- this.value)};
         BigInteger.prototype.abs
         =
         function(){return new BigInteger(this.value,false)};
         SmallInteger.prototype.abs
         =
         function(){return new SmallInteger(Math.abs(this.value))};
         NativeBigInt.prototype.abs
         =
         function()
          {return new NativeBigInt(this.value >= 0?this.value:- this.value)};
         function multiplyLong(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            l=a_l + b_l,
            r=createArray(l),
            base=BASE,
            product,
            carry,
            i,
            a_i,
            b_j;
           for(i = 0;i < a_l;++i)
            {a_i = a[i];
             for(var j=0;j < b_l;++j)
              {b_j = b[j];
               product = a_i * b_j + r[i + j];
               carry = Math.floor(product / base);
               r[i + j] = product - carry * base;
               r[i + j + 1] += carry}}
           trim(r);
           return r}
         function multiplySmall(a,b)
          {var l=a.length,r=new Array(l),base=BASE,carry=0,product,i;
           for(i = 0;i < l;i++)
            {product = a[i] * b + carry;
             carry = Math.floor(product / base);
             r[i] = product - carry * base}
           while(carry > 0)
            {r[i++] = carry % base;carry = Math.floor(carry / base)}
           return r}
         function shiftLeft(x,n)
          {var r=[];while(n-- > 0)r.push(0);return r.concat(x)}
         function multiplyKaratsuba(x,y)
          {var n=Math.max(x.length,y.length);
           if(n <= 30)return multiplyLong(x,y);
           n = Math.ceil(n / 2);
           var
            b=x.slice(n),
            a=x.slice(0,n),
            d=y.slice(n),
            c=y.slice(0,n),
            ac=multiplyKaratsuba(a,c),
            bd=multiplyKaratsuba(b,d),
            abcd=multiplyKaratsuba(addAny(a,b),addAny(c,d)),
            product=
             addAny
              (addAny(ac,shiftLeft(subtract(subtract(abcd,ac),bd),n)),
               shiftLeft(bd,2 * n));
           trim(product);
           return product}
         function useKaratsuba(l1,l2)
          {return - (0.012 * l1) - 0.012 * l2 + 0.000015 * l1 * l2 > 0}
         BigInteger.prototype.multiply
         =
         function(v)
          {var
            n=parseValue(v),
            a=this.value,
            b=n.value,
            sign=this.sign !== n.sign,
            abs;
           if(n.isSmall)
            {if(b === 0)return Integer[0];
             if(b === 1)return this;
             if(b === - 1)return this.negate();
             abs = Math.abs(b);
             if(abs < BASE)return new BigInteger(multiplySmall(a,abs),sign);
             b = smallToArray(abs)}
           if(useKaratsuba(a.length,b.length))
            return new BigInteger(multiplyKaratsuba(a,b),sign);
           return new BigInteger(multiplyLong(a,b),sign)};
         BigInteger.prototype.times = BigInteger.prototype.multiply;
         function multiplySmallAndArray(a,b,sign)
          {if(a < BASE)return new BigInteger(multiplySmall(b,a),sign);
           return new BigInteger(multiplyLong(b,smallToArray(a)),sign)}
         SmallInteger.prototype._multiplyBySmall
         =
         function(a)
          {if(isPrecise(a.value * this.value))
            return new SmallInteger(a.value * this.value);
           return multiplySmallAndArray
                   (Math.abs(a.value),
                    smallToArray(Math.abs(this.value)),
                    this.sign !== a.sign)};
         BigInteger.prototype._multiplyBySmall
         =
         function(a)
          {if(a.value === 0)return Integer[0];
           if(a.value === 1)return this;
           if(a.value === - 1)return this.negate();
           return multiplySmallAndArray
                   (Math.abs(a.value),this.value,this.sign !== a.sign)};
         SmallInteger.prototype.multiply
         =
         function(v){return parseValue(v)._multiplyBySmall(this)};
         SmallInteger.prototype.times = SmallInteger.prototype.multiply;
         NativeBigInt.prototype.multiply
         =
         function(v)
          {return new NativeBigInt(this.value * parseValue(v).value)};
         NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
         function square(a)
          {var
            l=a.length,
            r=createArray(l + l),
            base=BASE,
            product,
            carry,
            i,
            a_i,
            a_j;
           for(i = 0;i < l;i++)
            {a_i = a[i];
             carry = 0 - a_i * a_i;
             for(var j=i;j < l;j++)
              {a_j = a[j];
               product = 2 * (a_i * a_j) + r[i + j] + carry;
               carry = Math.floor(product / base);
               r[i + j] = product - carry * base}
             r[i + l] = carry}
           trim(r);
           return r}
         BigInteger.prototype.square
         =
         function(){return new BigInteger(square(this.value),false)};
         SmallInteger.prototype.square
         =
         function()
          {var value=this.value * this.value;
           if(isPrecise(value))return new SmallInteger(value);
           return new
                   BigInteger
                   (square(smallToArray(Math.abs(this.value))),false)};
         NativeBigInt.prototype.square
         =
         function(v){return new NativeBigInt(this.value * this.value)};
         function divMod1(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            base=BASE,
            result=createArray(b.length),
            divisorMostSignificantDigit=b[b_l - 1],
            lambda=Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder=multiplySmall(a,lambda),
            divisor=multiplySmall(b,lambda),
            quotientDigit,
            shift,
            carry,
            borrow,
            i,
            l,
            q;
           if(remainder.length <= a_l)remainder.push(0);
           divisor.push(0);
           divisorMostSignificantDigit = divisor[b_l - 1];
           for(shift = a_l - b_l;shift >= 0;shift--)
            {quotientDigit = base - 1;
             if(remainder[shift + b_l] !== divisorMostSignificantDigit)
              quotientDigit
              =
              Math.floor
               ((remainder[shift + b_l] * base + remainder[shift + b_l - 1])
                /
                divisorMostSignificantDigit);
             carry = 0;
             borrow = 0;
             l = divisor.length;
             for(i = 0;i < l;i++)
              {carry += quotientDigit * divisor[i];
               q = Math.floor(carry / base);
               borrow += remainder[shift + i] - (carry - q * base);
               carry = q;
               if(borrow < 0)
                {remainder[shift + i] = borrow + base;borrow = - 1}
               else
                {remainder[shift + i] = borrow;borrow = 0}}
             while(borrow !== 0)
              {quotientDigit -= 1;
               carry = 0;
               for(i = 0;i < l;i++)
                {carry += remainder[shift + i] - base + divisor[i];
                 if(carry < 0)
                  {remainder[shift + i] = carry + base;carry = 0}
                 else
                  {remainder[shift + i] = carry;carry = 1}}
               borrow += carry}
             result[shift] = quotientDigit}
           remainder = divModSmall(remainder,lambda)[0];
           return [arrayToSmall(result),arrayToSmall(remainder)]}
         function divMod2(a,b)
          {var
            a_l=a.length,
            b_l=b.length,
            result=[],
            part=[],
            base=BASE,
            guess,
            xlen,
            highx,
            highy,
            check;
           while(a_l)
            {part.unshift(a[--a_l]);
             trim(part);
             if(compareAbs(part,b) < 0){result.push(0);continue}
             xlen = part.length;
             highx = part[xlen - 1] * base + part[xlen - 2];
             highy = b[b_l - 1] * base + b[b_l - 2];
             if(xlen > b_l)highx = (highx + 1) * base;
             guess = Math.ceil(highx / highy);
             do
              {check = multiplySmall(b,guess);
               if(compareAbs(check,part) <= 0)break;
               guess--}
             while
              (guess);
             result.push(guess);
             part = subtract(part,check)}
           result.reverse();
           return [arrayToSmall(result),arrayToSmall(part)]}
         function divModSmall(value,lambda)
          {var
            length=value.length,
            quotient=createArray(length),
            base=BASE,
            i,
            q,
            remainder,
            divisor;
           remainder = 0;
           for(i = length - 1;i >= 0;--i)
            {divisor = remainder * base + value[i];
             q = truncate(divisor / lambda);
             remainder = divisor - q * lambda;
             quotient[i] = q | 0}
           return [quotient,remainder | 0]}
         function divModAny(self,v)
          {var value,n=parseValue(v);
           if(supportsNativeBigInt)
            return [new NativeBigInt(self.value / n.value),
                    new NativeBigInt(self.value % n.value)];
           var a=self.value,b=n.value,quotient;
           if(b === 0)throw new Error("Cannot divide by zero");
           if(self.isSmall)
            {if(n.isSmall)
              return [new SmallInteger(truncate(a / b)),
                      new SmallInteger(a % b)];
             return [Integer[0],self]}
           if(n.isSmall)
            {if(b === 1)return [self,Integer[0]];
             if(b == - 1)return [self.negate(),Integer[0]];
             var abs=Math.abs(b);
             if(abs < BASE)
              {value = divModSmall(a,abs);
               quotient = arrayToSmall(value[0]);
               var remainder=value[1];
               if(self.sign)remainder = - remainder;
               if(typeof quotient === "number")
                {if(self.sign !== n.sign)quotient = - quotient;
                 return [new SmallInteger(quotient),
                         new SmallInteger(remainder)]}
               return [new BigInteger(quotient,self.sign !== n.sign),
                       new SmallInteger(remainder)]}
             b = smallToArray(abs)}
           var comparison=compareAbs(a,b);
           if(comparison === - 1)return [Integer[0],self];
           if(comparison === 0)
            return [Integer[self.sign === n.sign?1:- 1],Integer[0]];
           if(a.length + b.length <= 200)
            value = divMod1(a,b);
           else
            value = divMod2(a,b);
           quotient = value[0];
           var qSign=self.sign !== n.sign,mod=value[1],mSign=self.sign;
           if(typeof quotient === "number")
            {if(qSign)quotient = - quotient;
             quotient = new SmallInteger(quotient)}
           else
            quotient = new BigInteger(quotient,qSign);
           if(typeof mod === "number")
            {if(mSign)mod = - mod;mod = new SmallInteger(mod)}
           else
            mod = new BigInteger(mod,mSign);
           return [quotient,mod]}
         BigInteger.prototype.divmod
         =
         function(v)
          {var result=divModAny(this,v);
           return {quotient:result[0],remainder:result[1]}};
         NativeBigInt.prototype.divmod
         =
         SmallInteger.prototype.divmod
         =
         BigInteger.prototype.divmod;
         BigInteger.prototype.divide
         =
         function(v){return divModAny(this,v)[0]};
         NativeBigInt.prototype.over
         =
         NativeBigInt.prototype.divide
         =
         function(v)
          {return new NativeBigInt(this.value / parseValue(v).value)};
         SmallInteger.prototype.over
         =
         SmallInteger.prototype.divide
         =
         BigInteger.prototype.over
         =
         BigInteger.prototype.divide;
         BigInteger.prototype.mod = function(v){return divModAny(this,v)[1]};
         NativeBigInt.prototype.mod
         =
         NativeBigInt.prototype.remainder
         =
         function(v)
          {return new NativeBigInt(this.value % parseValue(v).value)};
         SmallInteger.prototype.remainder
         =
         SmallInteger.prototype.mod
         =
         BigInteger.prototype.remainder
         =
         BigInteger.prototype.mod;
         BigInteger.prototype.pow
         =
         function(v)
          {var n=parseValue(v),a=this.value,b=n.value,value,x,y;
           if(b === 0)return Integer[1];
           if(a === 0)return Integer[0];
           if(a === 1)return Integer[1];
           if(a === - 1)return n.isEven()?Integer[1]:Integer[- 1];
           if(n.sign)return Integer[0];
           if(! n.isSmall)
            throw new Error("The exponent " + n.toString() + " is too large.");
           if(this.isSmall)
            if(isPrecise(value = Math.pow(a,b)))
             return new SmallInteger(truncate(value));
           x = this;
           y = Integer[1];
           while(true)
            {if(b & 1 === 1){y = y.times(x);--b}
             if(b === 0)break;
             b /= 2;
             x = x.square()}
           return y};
         SmallInteger.prototype.pow = BigInteger.prototype.pow;
         NativeBigInt.prototype.pow
         =
         function(v)
          {var
            n=parseValue(v),
            a=this.value,
            b=n.value,
            _0=BigInt(0),
            _1=BigInt(1),
            _2=BigInt(2);
           if(b === _0)return Integer[1];
           if(a === _0)return Integer[0];
           if(a === _1)return Integer[1];
           if(a === BigInt(- 1))return n.isEven()?Integer[1]:Integer[- 1];
           if(n.isNegative())return new NativeBigInt(_0);
           var x=this,y=Integer[1];
           while(true)
            {if((b & _1) === _1){y = y.times(x);--b}
             if(b === _0)break;
             b /= _2;
             x = x.square()}
           return y};
         BigInteger.prototype.modPow
         =
         function(exp,mod)
          {exp = parseValue(exp);
           mod = parseValue(mod);
           if(mod.isZero())
            throw new Error("Cannot take modPow with modulus 0");
           var r=Integer[1],base=this.mod(mod);
           if(exp.isNegative())
            {exp = exp.multiply(Integer[- 1]);base = base.modInv(mod)}
           while(exp.isPositive())
            {if(base.isZero())return Integer[0];
             if(exp.isOdd())r = r.multiply(base).mod(mod);
             exp = exp.divide(2);
             base = base.square().mod(mod)}
           return r};
         NativeBigInt.prototype.modPow
         =
         SmallInteger.prototype.modPow
         =
         BigInteger.prototype.modPow;
         function compareAbs(a,b)
          {if(a.length !== b.length)return a.length > b.length?1:- 1;
           for(var i=a.length - 1;i >= 0;i--)
            if(a[i] !== b[i])return a[i] > b[i]?1:- 1;
           return 0}
         BigInteger.prototype.compareAbs
         =
         function(v)
          {var n=parseValue(v),a=this.value,b=n.value;
           if(n.isSmall)return 1;
           return compareAbs(a,b)};
         SmallInteger.prototype.compareAbs
         =
         function(v)
          {var n=parseValue(v),a=Math.abs(this.value),b=n.value;
           if(n.isSmall){b = Math.abs(b);return a === b?0:a > b?1:- 1}
           return - 1};
         NativeBigInt.prototype.compareAbs
         =
         function(v)
          {var a=this.value,b=parseValue(v).value;
           a = a >= 0?a:- a;
           b = b >= 0?b:- b;
           return a === b?0:a > b?1:- 1};
         BigInteger.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var n=parseValue(v),a=this.value,b=n.value;
           if(this.sign !== n.sign)return n.sign?1:- 1;
           if(n.isSmall)return this.sign?- 1:1;
           return compareAbs(a,b) * (this.sign?- 1:1)};
         BigInteger.prototype.compareTo = BigInteger.prototype.compare;
         SmallInteger.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var n=parseValue(v),a=this.value,b=n.value;
           if(n.isSmall)return a == b?0:a > b?1:- 1;
           if(a < 0 !== n.sign)return a < 0?- 1:1;
           return a < 0?1:- 1};
         SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
         NativeBigInt.prototype.compare
         =
         function(v)
          {if(v === Infinity)return - 1;
           if(v === - Infinity)return 1;
           var a=this.value,b=parseValue(v).value;
           return a === b?0:a > b?1:- 1};
         NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
         BigInteger.prototype.equals
         =
         function(v){return this.compare(v) === 0};
         NativeBigInt.prototype.eq
         =
         NativeBigInt.prototype.equals
         =
         SmallInteger.prototype.eq
         =
         SmallInteger.prototype.equals
         =
         BigInteger.prototype.eq
         =
         BigInteger.prototype.equals;
         BigInteger.prototype.notEquals
         =
         function(v){return this.compare(v) !== 0};
         NativeBigInt.prototype.neq
         =
         NativeBigInt.prototype.notEquals
         =
         SmallInteger.prototype.neq
         =
         SmallInteger.prototype.notEquals
         =
         BigInteger.prototype.neq
         =
         BigInteger.prototype.notEquals;
         BigInteger.prototype.greater
         =
         function(v){return this.compare(v) > 0};
         NativeBigInt.prototype.gt
         =
         NativeBigInt.prototype.greater
         =
         SmallInteger.prototype.gt
         =
         SmallInteger.prototype.greater
         =
         BigInteger.prototype.gt
         =
         BigInteger.prototype.greater;
         BigInteger.prototype.lesser
         =
         function(v){return this.compare(v) < 0};
         NativeBigInt.prototype.lt
         =
         NativeBigInt.prototype.lesser
         =
         SmallInteger.prototype.lt
         =
         SmallInteger.prototype.lesser
         =
         BigInteger.prototype.lt
         =
         BigInteger.prototype.lesser;
         BigInteger.prototype.greaterOrEquals
         =
         function(v){return this.compare(v) >= 0};
         NativeBigInt.prototype.geq
         =
         NativeBigInt.prototype.greaterOrEquals
         =
         SmallInteger.prototype.geq
         =
         SmallInteger.prototype.greaterOrEquals
         =
         BigInteger.prototype.geq
         =
         BigInteger.prototype.greaterOrEquals;
         BigInteger.prototype.lesserOrEquals
         =
         function(v){return this.compare(v) <= 0};
         NativeBigInt.prototype.leq
         =
         NativeBigInt.prototype.lesserOrEquals
         =
         SmallInteger.prototype.leq
         =
         SmallInteger.prototype.lesserOrEquals
         =
         BigInteger.prototype.leq
         =
         BigInteger.prototype.lesserOrEquals;
         BigInteger.prototype.isEven
         =
         function(){return (this.value[0] & 1) === 0};
         SmallInteger.prototype.isEven
         =
         function(){return (this.value & 1) === 0};
         NativeBigInt.prototype.isEven
         =
         function(){return (this.value & BigInt(1)) === BigInt(0)};
         BigInteger.prototype.isOdd
         =
         function(){return (this.value[0] & 1) === 1};
         SmallInteger.prototype.isOdd
         =
         function(){return (this.value & 1) === 1};
         NativeBigInt.prototype.isOdd
         =
         function(){return (this.value & BigInt(1)) === BigInt(1)};
         BigInteger.prototype.isPositive = function(){return ! this.sign};
         SmallInteger.prototype.isPositive
         =
         function(){return this.value > 0};
         NativeBigInt.prototype.isPositive
         =
         SmallInteger.prototype.isPositive;
         BigInteger.prototype.isNegative = function(){return this.sign};
         SmallInteger.prototype.isNegative
         =
         function(){return this.value < 0};
         NativeBigInt.prototype.isNegative
         =
         SmallInteger.prototype.isNegative;
         BigInteger.prototype.isUnit = function(){return false};
         SmallInteger.prototype.isUnit
         =
         function(){return Math.abs(this.value) === 1};
         NativeBigInt.prototype.isUnit
         =
         function(){return this.abs().value === BigInt(1)};
         BigInteger.prototype.isZero = function(){return false};
         SmallInteger.prototype.isZero = function(){return this.value === 0};
         NativeBigInt.prototype.isZero
         =
         function(){return this.value === BigInt(0)};
         BigInteger.prototype.isDivisibleBy
         =
         function(v)
          {var n=parseValue(v);
           if(n.isZero())return false;
           if(n.isUnit())return true;
           if(n.compareAbs(2) === 0)return this.isEven();
           return this.mod(n).isZero()};
         NativeBigInt.prototype.isDivisibleBy
         =
         SmallInteger.prototype.isDivisibleBy
         =
         BigInteger.prototype.isDivisibleBy;
         function isBasicPrime(v)
          {var n=v.abs();
           if(n.isUnit())return false;
           if(n.equals(2) || n.equals(3) || n.equals(5))return true;
           if(n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
            return false;
           if(n.lesser(49))return true}
         function millerRabinTest(n,a)
          {var nPrev=n.prev(),b=nPrev,r=0,d,t,i,x;
           while(b.isEven())b = b.divide(2),r++;
           next:
           for(i = 0;i < a.length;i++)
            {if(n.lesser(a[i]))continue;
             x = bigInt(a[i]).modPow(b,n);
             if(x.isUnit() || x.equals(nPrev))continue;
             for(d = r - 1;d != 0;d--)
              {x = x.square().mod(n);
               if(x.isUnit())return false;
               if(x.equals(nPrev))continue next}
             return false}
           return true}
         BigInteger.prototype.isPrime
         =
         function(strict)
          {var isPrime=isBasicPrime(this);
           if(isPrime !== undefined)return isPrime;
           var n=this.abs(),bits=n.bitLength();
           if(bits <= 64)
            return millerRabinTest(n,[2,3,5,7,11,13,17,19,23,29,31,37]);
           var
            logN=Math.log(2) * bits.toJSNumber(),
            t=Math.ceil(strict === true?2 * Math.pow(logN,2):logN);
           for(var a=[],i=0;i < t;i++)a.push(bigInt(i + 2));
           return millerRabinTest(n,a)};
         NativeBigInt.prototype.isPrime
         =
         SmallInteger.prototype.isPrime
         =
         BigInteger.prototype.isPrime;
         BigInteger.prototype.isProbablePrime
         =
         function(iterations)
          {var isPrime=isBasicPrime(this);
           if(isPrime !== undefined)return isPrime;
           var n=this.abs(),t=iterations === undefined?5:iterations;
           for(var a=[],i=0;i < t;i++)
            a.push(bigInt.randBetween(2,n.minus(2)));
           return millerRabinTest(n,a)};
         NativeBigInt.prototype.isProbablePrime
         =
         SmallInteger.prototype.isProbablePrime
         =
         BigInteger.prototype.isProbablePrime;
         BigInteger.prototype.modInv
         =
         function(n)
          {var
            t=bigInt.zero,
            newT=bigInt.one,
            r=parseValue(n),
            newR=this.abs(),
            q,
            lastT,
            lastR;
           while(! newR.isZero())
            {q = r.divide(newR);
             lastT = t;
             lastR = r;
             t = newT;
             r = newR;
             newT = lastT.subtract(q.multiply(newT));
             newR = lastR.subtract(q.multiply(newR))}
           if(! r.isUnit())
            throw new
                   Error
                   (this.toString()
                    +
                    " and "
                    +
                    n.toString()
                    +
                    " are not co-prime");
           if(t.compare(0) === - 1)t = t.add(n);
           if(this.isNegative())return t.negate();
           return t};
         NativeBigInt.prototype.modInv
         =
         SmallInteger.prototype.modInv
         =
         BigInteger.prototype.modInv;
         BigInteger.prototype.next
         =
         function()
          {var value=this.value;
           if(this.sign)return subtractSmall(value,1,this.sign);
           return new BigInteger(addSmall(value,1),this.sign)};
         SmallInteger.prototype.next
         =
         function()
          {var value=this.value;
           if(value + 1 < MAX_INT)return new SmallInteger(value + 1);
           return new BigInteger(MAX_INT_ARR,false)};
         NativeBigInt.prototype.next
         =
         function(){return new NativeBigInt(this.value + BigInt(1))};
         BigInteger.prototype.prev
         =
         function()
          {var value=this.value;
           if(this.sign)return new BigInteger(addSmall(value,1),true);
           return subtractSmall(value,1,this.sign)};
         SmallInteger.prototype.prev
         =
         function()
          {var value=this.value;
           if(value - 1 > - MAX_INT)return new SmallInteger(value - 1);
           return new BigInteger(MAX_INT_ARR,true)};
         NativeBigInt.prototype.prev
         =
         function(){return new NativeBigInt(this.value - BigInt(1))};
         var powersOfTwo=[1];
         while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
         var
          powers2Length=powersOfTwo.length,
          highestPower2=powersOfTwo[powers2Length - 1];
         function shift_isSmall(n){return Math.abs(n) <= BASE}
         BigInteger.prototype.shiftLeft
         =
         function(v)
          {var n=parseValue(v).toJSNumber();
           if(! shift_isSmall(n))
            throw new Error(String(n) + " is too large for shifting.");
           if(n < 0)return this.shiftRight(- n);
           var result=this;
           if(result.isZero())return result;
           while(n >= powers2Length)
            {result = result.multiply(highestPower2);n -= powers2Length - 1}
           return result.multiply(powersOfTwo[n])};
         NativeBigInt.prototype.shiftLeft
         =
         SmallInteger.prototype.shiftLeft
         =
         BigInteger.prototype.shiftLeft;
         BigInteger.prototype.shiftRight
         =
         function(v)
          {var remQuo,n=parseValue(v).toJSNumber();
           if(! shift_isSmall(n))
            throw new Error(String(n) + " is too large for shifting.");
           if(n < 0)return this.shiftLeft(- n);
           var result=this;
           while(n >= powers2Length)
            {if(result.isZero() || result.isNegative() && result.isUnit())
              return result;
             remQuo = divModAny(result,highestPower2);
             result = remQuo[1].isNegative()?remQuo[0].prev():remQuo[0];
             n -= powers2Length - 1}
           remQuo = divModAny(result,powersOfTwo[n]);
           return remQuo[1].isNegative()?remQuo[0].prev():remQuo[0]};
         NativeBigInt.prototype.shiftRight
         =
         SmallInteger.prototype.shiftRight
         =
         BigInteger.prototype.shiftRight;
         function bitwise(x,y,fn)
          {y = parseValue(y);
           var
            xSign=x.isNegative(),
            ySign=y.isNegative(),
            xRem=xSign?x.not():x,
            yRem=ySign?y.not():y,
            xDigit=0,
            yDigit=0,
            xDivMod=null,
            yDivMod=null,
            result=[];
           while(! xRem.isZero() || ! yRem.isZero())
            {xDivMod = divModAny(xRem,highestPower2);
             xDigit = xDivMod[1].toJSNumber();
             if(xSign)xDigit = highestPower2 - 1 - xDigit;
             yDivMod = divModAny(yRem,highestPower2);
             yDigit = yDivMod[1].toJSNumber();
             if(ySign)yDigit = highestPower2 - 1 - yDigit;
             xRem = xDivMod[0];
             yRem = yDivMod[0];
             result.push(fn(xDigit,yDigit))}
           var sum=fn(xSign?1:0,ySign?1:0) !== 0?bigInt(- 1):bigInt(0);
           for(var i=result.length - 1;i >= 0;i -= 1)
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
           return sum}
         BigInteger.prototype.not = function(){return this.negate().prev()};
         NativeBigInt.prototype.not
         =
         SmallInteger.prototype.not
         =
         BigInteger.prototype.not;
         BigInteger.prototype.and
         =
         function(n){return bitwise(this,n,function(a,b){return a & b})};
         NativeBigInt.prototype.and
         =
         SmallInteger.prototype.and
         =
         BigInteger.prototype.and;
         BigInteger.prototype.or
         =
         function(n){return bitwise(this,n,function(a,b){return a | b})};
         NativeBigInt.prototype.or
         =
         SmallInteger.prototype.or
         =
         BigInteger.prototype.or;
         BigInteger.prototype.xor
         =
         function(n){return bitwise(this,n,function(a,b){return a ^ b})};
         NativeBigInt.prototype.xor
         =
         SmallInteger.prototype.xor
         =
         BigInteger.prototype.xor;
         var
          LOBMASK_I=1 << 30,
          LOBMASK_BI=(BASE & - BASE) * (BASE & - BASE) | LOBMASK_I;
         function roughLOB(n)
          {var
            v=n.value,
            x=
             typeof v === "number"
              ?v | LOBMASK_I
              :typeof v === "bigint"
                ?v | BigInt(LOBMASK_I)
                :v[0] + v[1] * BASE | LOBMASK_BI;
           return x & - x}
         function integerLogarithm(value,base)
          {if(base.compareTo(value) <= 0)
            {var
              tmp=integerLogarithm(value,base.square(base)),
              p=tmp.p,
              e=tmp.e,
              t=p.multiply(base);
             return t.compareTo(value) <= 0?{p:t,e:e * 2 + 1}:{p:p,e:e * 2}}
           return {p:bigInt(1),e:0}}
         BigInteger.prototype.bitLength
         =
         function()
          {var n=this;
           if(n.compareTo(bigInt(0)) < 0)n = n.negate().subtract(bigInt(1));
           if(n.compareTo(bigInt(0)) === 0)return bigInt(0);
           return bigInt(integerLogarithm(n,bigInt(2)).e).add(bigInt(1))};
         NativeBigInt.prototype.bitLength
         =
         SmallInteger.prototype.bitLength
         =
         BigInteger.prototype.bitLength;
         function max(a,b)
          {a = parseValue(a);b = parseValue(b);return a.greater(b)?a:b}
         function min(a,b)
          {a = parseValue(a);b = parseValue(b);return a.lesser(b)?a:b}
         function gcd(a,b)
          {a = parseValue(a).abs();
           b = parseValue(b).abs();
           if(a.equals(b))return a;
           if(a.isZero())return b;
           if(b.isZero())return a;
           var c=Integer[1],d,t;
           while(a.isEven() && b.isEven())
            {d = min(roughLOB(a),roughLOB(b));
             a = a.divide(d);
             b = b.divide(d);
             c = c.multiply(d)}
           while(a.isEven())a = a.divide(roughLOB(a));
           do
            {while(b.isEven())b = b.divide(roughLOB(b));
             if(a.greater(b)){t = b;b = a;a = t}
             b = b.subtract(a)}
           while
            (! b.isZero());
           return c.isUnit()?a:a.multiply(c)}
         function lcm(a,b)
          {a = parseValue(a).abs();
           b = parseValue(b).abs();
           return a.divide(gcd(a,b)).multiply(b)}
         function randBetween(a,b)
          {a = parseValue(a);
           b = parseValue(b);
           var low=min(a,b),high=max(a,b),range=high.subtract(low).add(1);
           if(range.isSmall)return low.add(Math.floor(Math.random() * range));
           var digits=toBase(range,BASE).value,result=[],restricted=true;
           for(var i=0;i < digits.length;i++)
            {var
              top=restricted?digits[i]:BASE,
              digit=truncate(Math.random() * top);
             result.push(digit);
             if(digit < top)restricted = false}
           return low.add(Integer.fromArray(result,BASE,false))}
         function parseBase(text,base,alphabet,caseSensitive)
          {alphabet = alphabet || DEFAULT_ALPHABET;
           text = String(text);
           if(! caseSensitive)
            {text = text.toLowerCase();alphabet = alphabet.toLowerCase()}
           var length=text.length,i,absBase=Math.abs(base),alphabetValues={};
           for(i = 0;i < alphabet.length;i++)alphabetValues[alphabet[i]] = i;
           for(i = 0;i < length;i++)
            {var c=text[i];
             if(c === "-")continue;
             if(c in alphabetValues)
              if(alphabetValues[c] >= absBase)
               {if(c === "1" && absBase === 1)continue;
                throw new
                       Error
                       (c + " is not a valid digit in base " + base + ".")}}
           base = parseValue(base);
           var digits=[],isNegative=text[0] === "-";
           for(i = isNegative?1:0;i < text.length;i++)
            {var c=text[i];
             if(c in alphabetValues)
              digits.push(parseValue(alphabetValues[c]));
             else
              if(c === "<")
               {var start=i;
                do i++;while(text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1,i)))}
              else
               throw new Error(c + " is not a valid character")}
           return parseBaseFromArray(digits,base,isNegative)}
         function parseBaseFromArray(digits,base,isNegative)
          {var val=Integer[0],pow=Integer[1],i;
           for(i = digits.length - 1;i >= 0;i--)
            {val = val.add(digits[i].times(pow));pow = pow.times(base)}
           return isNegative?val.negate():val}
         function stringify(digit,alphabet)
          {alphabet = alphabet || DEFAULT_ALPHABET;
           if(digit < alphabet.length)return alphabet[digit];
           return "<" + digit + ">"}
         function toBase(n,base)
          {base = bigInt(base);
           if(base.isZero())
            {if(n.isZero())return {value:[0],isNegative:false};
             throw new Error("Cannot convert nonzero numbers to base 0.")}
           if(base.equals(- 1))
            {if(n.isZero())return {value:[0],isNegative:false};
             if(n.isNegative())
              return {value:
                      [].concat.apply
                       ([],
                        Array.apply(null,Array(- n.toJSNumber())).map
                         (Array.prototype.valueOf,[1,0])),
                      isNegative:false};
             var
              arr=
               Array.apply(null,Array(n.toJSNumber() - 1)).map
                (Array.prototype.valueOf,[0,1]);
             arr.unshift([1]);
             return {value:[].concat.apply([],arr),isNegative:false}}
           var neg=false;
           if(n.isNegative() && base.isPositive()){neg = true;n = n.abs()}
           if(base.isUnit())
            {if(n.isZero())return {value:[0],isNegative:false};
             return {value:
                     Array.apply(null,Array(n.toJSNumber())).map
                      (Number.prototype.valueOf,1),
                     isNegative:neg}}
           var out=[],left=n,divmod;
           while(left.isNegative() || left.compareAbs(base) >= 0)
            {divmod = left.divmod(base);
             left = divmod.quotient;
             var digit=divmod.remainder;
             if(digit.isNegative())
              {digit = base.minus(digit).abs();left = left.next()}
             out.push(digit.toJSNumber())}
           out.push(left.toJSNumber());
           return {value:out.reverse(),isNegative:neg}}
         function toBaseString(n,base,alphabet)
          {var arr=toBase(n,base);
           return (arr.isNegative?"-":"")
                  +
                  arr.value.map(function(x){return stringify(x,alphabet)}).join
                   ("")}
         BigInteger.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         SmallInteger.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         NativeBigInt.prototype.toArray
         =
         function(radix){return toBase(this,radix)};
         BigInteger.prototype.toString
         =
         function(radix,alphabet)
          {if(radix === undefined)radix = 10;
           if(radix !== 10)return toBaseString(this,radix,alphabet);
           var
            v=this.value,
            l=v.length,
            str=String(v[--l]),
            zeros="0000000",
            digit;
           while(--l >= 0)
            {digit = String(v[l]);str += zeros.slice(digit.length) + digit}
           var sign=this.sign?"-":"";
           return sign + str};
         SmallInteger.prototype.toString
         =
         function(radix,alphabet)
          {if(radix === undefined)radix = 10;
           if(radix != 10)return toBaseString(this,radix,alphabet);
           return String(this.value)};
         NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
         NativeBigInt.prototype.toJSON
         =
         BigInteger.prototype.toJSON
         =
         SmallInteger.prototype.toJSON
         =
         function(){return this.toString()};
         BigInteger.prototype.valueOf
         =
         function(){return parseInt(this.toString(),10)};
         BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
         SmallInteger.prototype.valueOf = function(){return this.value};
         SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
         NativeBigInt.prototype.valueOf
         =
         NativeBigInt.prototype.toJSNumber
         =
         function(){return parseInt(this.toString(),10)};
         function parseStringValue(v)
          {if(isPrecise(+ v))
            {var x=+ v;
             if(x === truncate(x))
              return supportsNativeBigInt
                      ?new NativeBigInt(BigInt(x))
                      :new SmallInteger(x);
             throw new Error("Invalid integer: " + v)}
           var sign=v[0] === "-";
           if(sign)v = v.slice(1);
           var split=v.split(/e/i);
           if(split.length > 2)
            throw new Error("Invalid integer: " + split.join("e"));
           if(split.length === 2)
            {var exp=split[1];
             if(exp[0] === "+")exp = exp.slice(1);
             exp = + exp;
             if(exp !== truncate(exp) || ! isPrecise(exp))
              throw new
                     Error
                     ("Invalid integer: " + exp + " is not a valid exponent.");
             var text=split[0],decimalPlace=text.indexOf(".");
             if(decimalPlace >= 0)
              {exp -= text.length - decimalPlace - 1;
               text
               =
               text.slice(0,decimalPlace)
               +
               text.slice(decimalPlace + 1)}
             if(exp < 0)
              throw new
                     Error
                     ("Cannot include negative exponent part for integers");
             text += new Array(exp + 1).join("0");
             v = text}
           var isValid=/^([0-9][0-9]*)$/.test(v);
           if(! isValid)throw new Error("Invalid integer: " + v);
           if(supportsNativeBigInt)
            return new NativeBigInt(BigInt(sign?"-" + v:v));
           var r=[],max=v.length,l=LOG_BASE,min=max - l;
           while(max > 0)
            {r.push(+ v.slice(min,max));min -= l;if(min < 0)min = 0;max -= l}
           trim(r);
           return new BigInteger(r,sign)}
         function parseNumberValue(v)
          {if(supportsNativeBigInt)return new NativeBigInt(BigInt(v));
           if(isPrecise(v))
            {if(v !== truncate(v))throw new Error(v + " is not an integer.");
             return new SmallInteger(v)}
           return parseStringValue(v.toString())}
         function parseValue(v)
          {if(typeof v === "number")return parseNumberValue(v);
           if(typeof v === "string")return parseStringValue(v);
           if(typeof v === "bigint")return new NativeBigInt(v);
           return v}
         for(var i=0;i < 1000;i++)
          {Integer[i] = parseValue(i);if(i > 0)Integer[- i] = parseValue(- i)}
         Integer.one = Integer[1];
         Integer.zero = Integer[0];
         Integer.minusOne = Integer[- 1];
         Integer.max = max;
         Integer.min = min;
         Integer.gcd = gcd;
         Integer.lcm = lcm;
         Integer.isInstance
         =
         function(x)
          {return x instanceof BigInteger
                  ||
                  x instanceof SmallInteger
                  ||
                  x instanceof NativeBigInt};
         Integer.randBetween = randBetween;
         Integer.fromArray
         =
         function(digits,base,isNegative)
          {return parseBaseFromArray
                   (digits.map(parseValue),parseValue(base || 10),isNegative)};
         return Integer}
       ();
    function ml_z_normalize(x)
     {var y=x.toJSNumber() | 0;if(x.equals(bigInt(y)))return y;return x}
    function ml_z_shift_right(z1,amt)
     {return ml_z_normalize(bigInt(z1).shiftRight(amt))}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function integers_uint32_compare(x,y)
     {if(x.value > y.value)return 1;if(x.value < y.value)return - 1;return 0}
    function caml_pasta_fp_copy(x,y)
     {for(var i=0,l=x.length;i < l;i++)x[i] = y[i]}
    var caml_pasta_fp_square=plonk_wasm.caml_pasta_fp_square;
    function caml_pasta_fp_mut_square(x)
     {caml_pasta_fp_copy(x,caml_pasta_fp_square(x))}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_pasta_fq_plonk_verifier_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return caml_pasta_fq_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_read
                (offset,urs,caml_jsstring_of_string(path)))}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_pasta_fp_plonk_verifier_index_to_rust(x)
     {return caml_plonk_verifier_index_to_rust
              (x,
               plonk_wasm.WasmFpPlonkVerifierIndex,
               plonk_wasm.WasmFpDomain,
               plonk_wasm.WasmFpPlonkVerificationEvals,
               plonk_wasm.WasmFpPolyComm,
               plonk_wasm.caml_vesta_affine_one,
               plonk_wasm.WasmFpShifts)}
    function caml_pasta_fp_plonk_proof_verify(index,proof)
     {index = caml_pasta_fp_plonk_verifier_index_to_rust(index);
      proof = caml_pasta_fp_proof_to_rust(proof);
      return plonk_wasm.caml_pasta_fp_plonk_proof_verify(index,proof)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function ml_z_shift_left(z1,amt)
     {return ml_z_normalize(bigInt(z1).shiftLeft(amt))}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function caml_js_to_bool(x){return + x}
    function caml_pasta_fq_is_square(x)
     {return caml_js_to_bool(plonk_wasm.caml_pasta_fq_is_square(x))}
    function caml_option_of_maybe_undefined(x){return x === undefined?0:[0,x]}
    function caml_random_oracles_of_rust(x)
     {var
       joint_combiner_chal=x.joint_combiner_chal,
       joint_combiner=x.joint_combiner,
       joint_combiner_ocaml=undefined;
      if(joint_combiner_chal !== undefined && joint_combiner !== undefined)
       joint_combiner_ocaml = [0,[0,joint_combiner_chal],joint_combiner];
      return [0,
              caml_option_of_maybe_undefined(joint_combiner_ocaml),
              x.beta,
              x.gamma,
              [0,x.alpha_chal],
              x.alpha,
              x.zeta,
              x.v,
              x.u,
              [0,x.zeta_chal],
              [0,x.v_chal],
              [0,x.u_chal]]}
    function caml_oracles_of_rust(x)
     {return [0,
              caml_random_oracles_of_rust(x.o),
              [0,x.p_eval0,x.p_eval1],
              caml_u8array_vector_of_rust_flat_vector
               (x.opening_prechallenges,32),
              x.digest_before_evaluations]}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_plonk_wire_to_rust(wire)
     {return plonk_wasm.Wire.create(wire[1],wire[2])}
    function caml_plonk_wires_to_rust(wires)
     {return new
              (plonk_wasm.WasmGateWires)
              (caml_plonk_wire_to_rust(wires[1]),
               caml_plonk_wire_to_rust(wires[2]),
               caml_plonk_wire_to_rust(wires[3]),
               caml_plonk_wire_to_rust(wires[4]),
               caml_plonk_wire_to_rust(wires[5]),
               caml_plonk_wire_to_rust(wires[6]),
               caml_plonk_wire_to_rust(wires[7]))}
    function caml_fp_plonk_gate_to_rust(gate)
     {return new
              (plonk_wasm.WasmFpGate)
              (gate[1],
               caml_plonk_wires_to_rust(gate[2]),
               caml_u8array_vector_to_rust_flat_vector(gate[3]))}
    function caml_pasta_fp_plonk_gate_vector_add(v,x)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_add
              (v,caml_fp_plonk_gate_to_rust(x))}
    function core_kernel_gc_minor_words(){return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_fp_vector_get(v,i)
     {return new (joo_global_object.Uint8Array)(v[i + 1])}
    function integers_uint32_to_int(i){return i.value | 0}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function Base_hash_string(s){return caml_hash(1,1,0,s)}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_string_of_bytes(s){return s}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function core_md5_fd(fd)
     {var ic=caml_ml_open_descriptor_in(fd);
      try {return caml_md5_chan(ic,- 1)}finally {caml_ml_close_channel(ic)}}
    var caml_ephe_key_offset=3;
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function jsoo_z_of_js_string_base(base,s)
     {if(base == 0)
       {base = 10;
        var p=0,sign=1;
        if(s[p] == "-"){sign = - 1;p++}else if(s[p] == "+")p++;
        if(s[p] == "0")
         {p++;
          if(s.length == p)
           return 0;
          else
           {var bc=s[p];
            if(bc == "o" || bc == "O")
             base = 8;
            else
             if(bc == "x" || bc == "X")
              base = 16;
             else
              if(bc == "b" || bc == "B")base = 2;
            if(base != 10){s = s.substring(p + 1);if(sign == - 1)s = "-" + s}}}}
      if(s[0] == "+")s = s.substring(1);
      s = s.replace(/^0+/,"");
      if(s == "-" || s == "")s = "0";
      function digit(code)
       {if(code >= 48 && code <= 57)return code - 48;
        if(code >= 97 && code <= 102)return code - 97 + 10;
        if(code >= 65 && code <= 70)return code - 65 + 10}
      var i=0;
      if(s[i] == "-")i++;
      for(;i < s.length;i++)
       {var c=digit(s.charCodeAt(i));
        if(c == undefined || c >= base)
         caml_invalid_argument("Z.of_substring_base: invalid digit")}
      return ml_z_normalize(bigInt(s,base))}
    function ml_z_of_substring_base(base,s,pos,len)
     {if(pos != 0 || len != caml_ml_string_length(s))
       {s = caml_array_of_string(s);
        if(s.length - pos < len)
         caml_invalid_argument
          ("Z.of_substring_base: invalid offset or length");
        s = caml_string_of_array(s.slice(pos,pos + len))}
      return jsoo_z_of_js_string_base(base,caml_to_js_string(s))}
    var
     caml_pasta_fp_plonk_index_domain_d8_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d8_size;
    function caml_bytes_to_uint8array(ocaml_bytes)
     {var
       length=caml_ml_bytes_length(ocaml_bytes),
       bytes=new (joo_global_object.Uint8Array)(length);
      for(var i=0;i < length;i++)
       bytes[i] = caml_bytes_unsafe_get(ocaml_bytes,i);
      return bytes}
    function caml_pasta_fq_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_pasta_fq_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    function win_cleanup(){}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function unix_inet_addr_of_string(){return 0}
    var
     caml_pasta_fq_plonk_index_domain_d1_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d1_size;
    function ml_z_gcdext_intern(z1,z2)
     {z1 = bigInt(z1);
      z2 = bigInt(z2);
      var
       gcd=bigInt.gcd(z1,z2),
       a=z1,
       b=z2,
       x=bigInt(0),
       lastx=bigInt(1),
       y=bigInt(1),
       lasty=bigInt(1),
       q,
       t,
       r;
      if(z1.equals(bigInt(0)))caml_raise_zero_divide();
      while(! b.equals(bigInt(0)))
       {q = a.divide(b);
        r = a.subtract(q.multiply(b));
        t = x;
        x = lastx.subtract(q.multiply(x));
        lastx = t;
        t = y;
        y = lasty.subtract(q.multiply(y));
        lasty = t;
        a = b;
        b = r}
      return a.lt(bigInt(0))
              ?[0,ml_z_normalize(a.negate()),ml_z_normalize(lastx.negate()),1]
              :[0,ml_z_normalize(a),ml_z_normalize(lastx),1]}
    function integers_uint8_deserialize(reader,size)
     {size[0] = 1;return reader.read8u()}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function integers_uint32_max(unit){return new UInt32(0xFFFFFFFF)}
    function ml_z_abs(z1){return ml_z_normalize(bigInt(z1).abs())}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    var Base_internalhash_fold_float=caml_hash_mix_float;
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_int64_or(x,y){return x.or(y)}
    function integers_uint64_logor(x,y)
     {return new UInt64(caml_int64_or(x.value,y.value))}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.data2 != null)
       caml_invalid_argument("bigstring_destroy: unsupported kind");
      if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      var
       destroyed_data=new (v_bstr.data.__proto__.constructor)(0),
       destroyed_bigstring=
        caml_ba_create_from
         (destroyed_data,null,v_bstr.data_type,v_bstr.kind,v_bstr.layout,[0]);
      destroyed_bigstring.__is_deallocated = true;
      Object.assign(v_bstr,destroyed_bigstring);
      return 0}
    function bigstring_realloc(bigstring,size)
     {if(bigstring.data2 != null)
       caml_invalid_argument
        ("Bigstring.unsafe_destroy_and_resize: unsupported kind");
      if(bigstring.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_realloc: bigstring is already deallocated");
      var new_data=new (bigstring.data.__proto__.constructor)(size);
      new_data.set(bigstring.data.slice(0,size));
      var
       new_bigstring=
        caml_ba_create_from
         (new_data,
          null,
          bigstring.data_type,
          bigstring.kind,
          bigstring.layout,
          [size]);
      bigstring_destroy_stub(bigstring);
      return new_bigstring}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function integers_uint32_of_int32(i){return new UInt32(i)}
    function caml_fp_srs_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_fp_srs_write
              (append,t,caml_jsstring_of_string(path))}
    function ml_z_rem(z1,z2)
     {z2 = bigInt(z2);
      if(z2.equals(bigInt(0)))caml_raise_zero_divide();
      return ml_z_normalize(bigInt(z1).mod(z2))}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function deferred_is_determined(deferred){return deferred.isDetermined}
    function caml_vesta_of_affine(pt)
     {var
       res=
        plonk_wasm.caml_vesta_of_affine
         (rust_affine_of_caml_affine(pt,plonk_wasm.caml_vesta_affine_one));
      free_on_finalize(res);
      return res}
    function integers_uint64_div(x,y)
     {if(y.value.isZero())caml_raise_zero_divide();
      x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return new UInt64(x.value.udivmod(y.value).quotient)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_pallas_poly_comm_to_rust(x)
     {return caml_poly_comm_to_rust_poly_comm
              (x,plonk_wasm.WasmFqPolyComm,plonk_wasm.caml_pallas_affine_one)}
    function caml_pasta_fq_commitments_to_rust(x)
     {function convertArray(v)
       {var n=v.length - 1,res=new Array(n);
        for(var i=0;i < n;++i)
         res[i] = caml_pallas_poly_comm_to_rust(v[i + 1]);
        return js_class_vector_to_rust_vector(res)}
      var
       w_comm=convertArray(x[1]),
       z_comm=caml_pallas_poly_comm_to_rust(x[2]),
       t_comm=caml_pallas_poly_comm_to_rust(x[3]);
      return new (plonk_wasm.WasmFqProverCommitments)(w_comm,z_comm,t_comm)}
    function caml_pasta_fq_opening_proof_to_rust(x)
     {function convert_affines(affines)
       {return caml_array_to_rust_vector
                (affines,
                 rust_affine_of_caml_affine,
                 plonk_wasm.caml_pallas_affine_one)}
      var
       lr=x[1],
       delta=
        rust_affine_of_caml_affine(x[2],plonk_wasm.caml_pallas_affine_one),
       z1=x[3],
       z2=x[4],
       sg=rust_affine_of_caml_affine(x[5],plonk_wasm.caml_pallas_affine_one),
       len=lr.length,
       l_ocaml=new Array(len),
       r_ocaml=new Array(len);
      for(var i=1;i < len;i++){l_ocaml[i] = lr[i][1];r_ocaml[i] = lr[i][2]}
      var l=convert_affines(l_ocaml),r=convert_affines(r_ocaml);
      return new (plonk_wasm.WasmFqOpeningProof)(l,r,delta,z1,z2,sg)}
    function caml_fq_vector_to_rust(v)
     {return caml_u8array_vector_to_rust_flat_vector(v)}
    function caml_pasta_fq_proof_evaluations_to_rust(x)
     {var w=new (plonk_wasm.WasmVecVecFq)(COLUMNS);
      for(var i=0;i < COLUMNS;++i)w.push(caml_fq_vector_to_rust(x[1][i + 1]));
      var
       z=caml_fq_vector_to_rust(x[2]),
       s=new (plonk_wasm.WasmVecVecFq)(PERMUTS_MINUS_1);
      for(i = 0;i < PERMUTS_MINUS_1;++i)
       s.push(caml_fq_vector_to_rust(x[3][i + 1]));
      var
       generic_selector=caml_fq_vector_to_rust(x[4]),
       poseidon_selector=caml_fq_vector_to_rust(x[5]);
      return new
              (plonk_wasm.WasmFqProofEvaluations)
              (w,z,s,generic_selector,poseidon_selector)}
    function caml_pasta_fq_proof_to_rust(x)
     {var
       messages=caml_pasta_fq_commitments_to_rust(x[1]),
       proof=caml_pasta_fq_opening_proof_to_rust(x[2]),
       evals0=caml_pasta_fq_proof_evaluations_to_rust(x[3][1]),
       evals1=caml_pasta_fq_proof_evaluations_to_rust(x[3][2]),
       ft_eval1=x[4],
       public_=caml_fq_vector_to_rust(x[5]),
       prev_challenges=x[6],
       chals_len=prev_challenges.length,
       prev_challenges_scalars=new (plonk_wasm.WasmVecVecFq)(chals_len - 1),
       prev_challenges_comms=new Array(chals_len - 1);
      for(var i=1;i < chals_len;i++)
       {prev_challenges_scalars.push
         (caml_fq_vector_to_rust(prev_challenges[i][1]));
        prev_challenges_comms[i - 1]
        =
        caml_pallas_poly_comm_to_rust(prev_challenges[i][2])}
      prev_challenges_comms
      =
      js_class_vector_to_rust_vector(prev_challenges_comms);
      return new
              (plonk_wasm.WasmFqProverProof)
              (messages,
               proof,
               evals0,
               evals1,
               ft_eval1,
               public_,
               prev_challenges_scalars,
               prev_challenges_comms)}
    function caml_pasta_fq_plonk_proof_verify(index,proof)
     {index = caml_pasta_fq_plonk_verifier_index_to_rust(index);
      proof = caml_pasta_fq_proof_to_rust(proof);
      return plonk_wasm.caml_pasta_fq_plonk_proof_verify(index,proof)}
    function integers_uint32_logxor(x,y){return new UInt32(x.value ^ y.value)}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function deferred_create(promise_creator)
     {var
       deferred=
        {promise:
         new Promise(function(resolve){promise_creator(resolve)}).then
           (function(value)
             {deferred.value = value;deferred.isDetermined = true}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function Base_am_testing(x){return 0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    var
     caml_pasta_fp_plonk_index_public_inputs=
      plonk_wasm.caml_pasta_fp_plonk_index_public_inputs;
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_pallas_affine_deep_copy(pt)
     {return rust_affine_to_caml_affine
              (plonk_wasm.caml_pallas_affine_deep_copy
                (rust_affine_of_caml_affine
                  (pt,plonk_wasm.caml_pallas_affine_one)))}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_bigint_256_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_bigint_256_to_string(x))}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_vesta_to_affine(pt)
     {var res=plonk_wasm.caml_vesta_to_affine(pt);
      return rust_affine_to_caml_affine(res)}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function integers_uint32_add(x,y){return new UInt32(x.value + y.value)}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_pallas_double(x)
     {var res=plonk_wasm.caml_pallas_double(x);
      free_on_finalize(res);
      return res}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_vesta_add(x,y)
     {var res=plonk_wasm.caml_vesta_add(x,y);free_on_finalize(res);return res}
    function caml_bigint_256_test_bit(x,i)
     {return caml_js_to_bool(plonk_wasm.caml_bigint_256_test_bit(x,i))}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    var caml_pasta_fq_compare=plonk_wasm.caml_pasta_fq_compare;
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function integers_uint32_to_int64(i)
     {return caml_int64_create_lo_mi_hi
              (i.value & 0xffffff,
               i.value >>> 24 & 0xffffff,
               i.value >>> 31 & 0xffff)}
    function integers_uint32_mul(x,y)
     {var x_64=integers_uint32_to_int64(x),y_64=integers_uint32_to_int64(y);
      return new UInt32(caml_int64_to_int32(caml_int64_mul(x_64,y_64)))}
    function caml_pasta_fq_commitments_of_rust(x)
     {function convertArray(v)
       {var
         a=js_class_vector_of_rust_vector(v,plonk_wasm.WasmFqPolyComm),
         res=[0];
        for(var i=0;i < a.length;++i)
         res.push(caml_pallas_poly_comm_of_rust(a[i]));
        return res}
      var
       w_comm=convertArray(x.w_comm),
       z_comm=caml_pallas_poly_comm_of_rust(x.z_comm),
       t_comm=caml_pallas_poly_comm_of_rust(x.t_comm);
      x.free();
      return [0,w_comm,z_comm,t_comm]}
    function caml_pasta_fq_opening_proof_of_rust(x)
     {function convert_affines(affines)
       {return caml_array_of_rust_vector
                (affines,
                 plonk_wasm.WasmGPallas,
                 rust_affine_to_caml_affine,
                 false)}
      var
       l=convert_affines(x.lr_0),
       r=convert_affines(x.lr_1),
       delta=rust_affine_to_caml_affine(x.delta),
       z1=x.z1,
       z2=x.z2,
       sg=rust_affine_to_caml_affine(x.sg);
      x.free();
      var len=l.length;
      if(len !== r.length)throw new Error("l and r lengths don't match");
      var lr=new Array(len);
      lr[0] = 0;
      for(var i=1;i < len;i++)
       {var tuple=new Array(3);
        tuple[0] = 0;
        tuple[1] = l[i];
        tuple[2] = r[i];
        lr[i] = tuple}
      return [0,lr,delta,z1,z2,sg]}
    function caml_fq_vector_of_rust(v)
     {return caml_u8array_vector_of_rust_flat_vector(v,32)}
    function caml_pasta_fq_proof_evaluations_of_rust(x)
     {function convertArray(v,n)
       {var res=[0];
        for(var i=0;i < n;++i)res.push(caml_fq_vector_of_rust(v.get(i)));
        return res}
      var
       w=convertArray(x.w,COLUMNS),
       z=caml_fq_vector_of_rust(x.z),
       s=convertArray(x.s,PERMUTS_MINUS_1),
       generic_selector=caml_fq_vector_of_rust(x.generic_selector),
       poseidon_selector=caml_fq_vector_of_rust(x.poseidon_selector);
      x.free();
      return [0,w,z,s,generic_selector,poseidon_selector]}
    function caml_pasta_fq_proof_of_rust(x)
     {var
       messages=caml_pasta_fq_commitments_of_rust(x.commitments),
       proof=caml_pasta_fq_opening_proof_of_rust(x.proof),
       evals0=caml_pasta_fq_proof_evaluations_of_rust(x.evals0),
       evals1=caml_pasta_fq_proof_evaluations_of_rust(x.evals1),
       ft_eval1=x.ft_eval1,
       public_=caml_fq_vector_of_rust(x.public_),
       prev_challenges_scalars=x.prev_challenges_scalars,
       prev_challenges_comms=
        js_class_vector_of_rust_vector
         (x.prev_challenges_comms,plonk_wasm.WasmFqPolyComm),
       chals_len=prev_challenges_comms.length,
       prev_challenges=new Array(chals_len);
      prev_challenges[0] = 0;
      for(var i=1;i < chals_len;i++)
       {var res=new Array(3);
        res[0] = 0;
        res[1] = caml_fq_vector_of_rust(prev_challenges_scalars.get(i - 1));
        res[2] = caml_pallas_poly_comm_of_rust(prev_challenges_comms[i]);
        prev_challenges[i] = res}
      return [0,
              messages,
              proof,
              [0,evals0,evals1],
              ft_eval1,
              public_,
              prev_challenges]}
    function caml_pasta_fq_plonk_proof_create
     (index,witness_cols,prev_challenges,prev_sgs)
     {var w=new (plonk_wasm.WasmVecVecFq)(witness_cols.length - 1);
      for(var i=1;i < witness_cols.length;i++)
       w.push(caml_fq_vector_to_rust(witness_cols[i]));
      witness_cols = w;
      prev_challenges = caml_fq_vector_to_rust(prev_challenges);
      prev_sgs
      =
      caml_array_to_rust_vector
       (prev_sgs,rust_affine_of_caml_affine,plonk_wasm.caml_pallas_affine_one);
      var
       res=
        plonk_wasm.caml_pasta_fq_plonk_proof_create
         (index,witness_cols,prev_challenges,prev_sgs),
       proof=caml_pasta_fq_proof_of_rust(res);
      return proof}
    function caml_int64_is_zero(x){return + x.isZero()}
    function Base_int_math_int64_pow_stub(base,exponent)
     {var one=[255,1,0,0],mul=[one,base,one,one],res=one;
      while(! caml_int64_is_zero(exponent))
       {mul[1] = caml_int64_mul(mul[1],mul[3]);
        mul[2] = caml_int64_mul(mul[1],mul[1]);
        mul[3] = caml_int64_mul(mul[2],mul[1]);
        res = caml_int64_mul(res,mul[exponent[1] & 3]);
        exponent = caml_int64_shift_right_unsigned(exponent,2)}
      return res}
    function caml_sys_const_word_size(){return 32}
    function integers_uint64_to_int64(i)
     {i = i.value;return caml_int64_create_lo_mi_hi(i.lo,i.mi,i.hi | 0)}
    function ml_z_popcount(z)
     {z = bigInt(z);
      var zero=bigInt(0),one=bigInt(1);
      if(z.lt(zero))caml_raise_constant(caml_named_value("ml_z_overflow"));
      var i;
      for(i = 0;! z.equals(zero);i++)z = z.and(z.prev());
      if(i != (i | 0))caml_raise_constant(caml_named_value("ml_z_overflow"));
      return i | 0}
    function ml_z_hamdist(z1,z2)
     {if(bigInt(z1).isNegative() != bigInt(z2).isNegative())
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      if
       ((z1 != (z1 | 0) || z2 != (z2 | 0))
        &&
        (bigInt(z1).isNegative() || bigInt(z2).isNegative()))
       caml_invalid_argument("Z.hamdist: negative arguments");
      return ml_z_popcount(bigInt(z1).xor(bigInt(z2)))}
    function ml_z_mul(z1,z2)
     {return ml_z_normalize(bigInt(z1).multiply(bigInt(z2)))}
    function ml_z_pow(z1,i1)
     {i1 = bigInt(i1);
      if(i1.lt(bigInt(0)))
       caml_invalid_argument("Z.pow: exponent must be nonnegative");
      return ml_z_normalize(bigInt(z1).pow(i1))}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function deferred_peek(deferred)
     {if(! deferred.isDetermined || deferred.isError)return 0;
      return [0,deferred.value]}
    function ml_z_logand(z1,z2)
     {return ml_z_normalize(bigInt(z1).and(bigInt(z2)))}
    function caml_vesta_of_affine_coordinates(x,y)
     {var res=plonk_wasm.caml_vesta_of_affine_coordinates(x,y);
      free_on_finalize(res);
      return res}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function deferred_to_promise(deferred){return deferred.promise}
    var expect_test_collector_saved_stderr,expect_test_collector_saved_stdout;
    function expect_test_collector_after_test(vstdout,vstderr)
     {caml_ml_channels[vstdout] = expect_test_collector_saved_stdout;
      caml_ml_channels[vstderr] = expect_test_collector_saved_stderr;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function ml_z_fits_int(z1){return z1 == (z1 | 0)?1:0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    var Base_internalhash_fold_int=caml_hash_mix_int;
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_bigint_256_of_decimal_string(s)
     {return plonk_wasm.caml_bigint_256_of_decimal_string
              (caml_jsstring_of_string(s))}
    function Base_int_math_int32_clz(x)
     {var n=32,y;
      y = x >> 16;
      if(y != 0){n = n - 16;x = y}
      y = x >> 8;
      if(y != 0){n = n - 8;x = y}
      y = x >> 4;
      if(y != 0){n = n - 4;x = y}
      y = x >> 2;
      if(y != 0){n = n - 2;x = y}
      y = x >> 1;
      if(y != 0)return n - 2;
      return n - x}
    function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x)}
    var caml_pasta_fp_add=plonk_wasm.caml_pasta_fp_add;
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function core_kernel_time_ns_format(time,format)
     {var
       d=new Date(time * 1000),
       formatjs=caml_to_js_string(format),
       jstring=joo_global_object.strftime(formatjs,d);
      return caml_js_to_string(jstring)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_pasta_fp_plonk_verifier_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fp_plonk_verifier_index_write
              (append,
               caml_pasta_fp_plonk_verifier_index_to_rust(t),
               caml_jsstring_of_string(path))}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function integers_uint16_deserialize(reader,size)
     {size[0] = 2;return reader.read16u()}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    var internalhash_fold_bigstring=caml_hash_mix_bigstring;
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function ml_z_sign(z1){return bigInt(z1).compare(bigInt.zero)}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_fp_srs_b_poly_commitment(srs,chals)
     {var
       res=
        plonk_wasm.caml_fp_srs_b_poly_commitment
         (srs,caml_u8array_vector_to_rust_flat_vector(chals));
      return caml_vesta_poly_comm_of_rust(res)}
    function ml_z_nextprime(z1)
     {z1 = bigInt(z1);
      var one=bigInt(1),two=bigInt(2);
      if(z1.lt(one) || z1.equals(one))return 2;
      if(z1.and(one).equals(one))z1 = z1.add(two);else z1 = z1.add(one);
      while(true)
       if(z1.isProbablePrime(25))
        return ml_z_normalize(z1);
       else
        z1 = z1.add(two)}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    var caml_pasta_fq_equal=plonk_wasm.caml_pasta_fq_equal;
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function fq_oracles_create(lgr_comm,verifier_index,proof)
     {return caml_oracles_of_rust
              (plonk_wasm.fq_oracles_create
                (caml_array_to_rust_vector
                  (lgr_comm,caml_pallas_poly_comm_to_rust),
                 caml_pasta_fq_plonk_verifier_index_to_rust(verifier_index),
                 caml_pasta_fq_proof_to_rust(proof)))}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    var
     caml_pasta_fp_plonk_index_domain_d1_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d1_size;
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_vesta_negate(x)
     {var res=plonk_wasm.caml_vesta_negate(x);
      free_on_finalize(res);
      return res}
    function ml_z_div(z1,z2)
     {z2 = bigInt(z2);
      if(z2.equals(bigInt(0)))caml_raise_zero_divide();
      return ml_z_normalize(bigInt(z1).divide(bigInt(z2)))}
    function ml_z_divexact(z1,z2){return ml_z_div(z1,z2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_vesta_rng(i)
     {var res=plonk_wasm.caml_vesta_rng(i);free_on_finalize(res);return res}
    function caml_pasta_fp_plonk_verifier_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return caml_pasta_fp_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_read
                (offset,urs,caml_jsstring_of_string(path)))}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_fq_srs_read(offset,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      var
       res=
        plonk_wasm.caml_fq_srs_read(offset,caml_jsstring_of_string(path));
      return res?[0,res]:0}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_pasta_fp_mut_add(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_add(x,y))}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_zarith_marshal(writer,v,sz)
     {v = bigInt(v);
      var bits=v.toArray(Math.pow(2,32));
      writer.write(8,bits.isNegative?1:0);
      var block=bits.value.length,len=block * 4;
      writer.write(32,len);
      for(var i=block - 1;i >= 0;i--)
       {writer.write(8,bits.value[i] >>> 0 & 0xff);
        writer.write(8,bits.value[i] >>> 8 & 0xff);
        writer.write(8,bits.value[i] >>> 16 & 0xff);
        writer.write(8,bits.value[i] >>> 24 & 0xff)}
      sz[0] = 4 * (1 + ((len + 3) / 4 | 0));
      sz[1] = 8 * (1 + ((len + 7) / 8 | 0))}
    function caml_fp_vector_emplace_back(v,x){v.push(x)}
    var
     Base_internalhash_fold_int64=caml_hash_mix_int64,
     caml_vesta_endo_scalar=plonk_wasm.caml_vesta_endo_scalar;
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    function caml_fq_srs_b_poly_commitment(srs,chals)
     {var
       res=
        plonk_wasm.caml_fq_srs_b_poly_commitment
         (srs,caml_u8array_vector_to_rust_flat_vector(chals));
      return caml_pallas_poly_comm_of_rust(res)}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_js_equals(x,y){return + (x == y)}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function bigstring_to_typed_array(bs){return bs.data}
    function integers_uint16_of_string(x)
     {var y=integers_uint32_of_string(x);return y.value & 0xFFFF}
    function ml_z_fits_nativeint(z1){return ml_z_fits_int(z1)}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function integers_uint64_logxor(x,y)
     {return new UInt64(caml_int64_xor(x.value,y.value))}
    function integers_uint32_of_int(i){return new UInt32(i)}
    function caml_pallas_of_affine(pt)
     {var
       res=
        plonk_wasm.caml_pallas_of_affine
         (rust_affine_of_caml_affine(pt,plonk_wasm.caml_pallas_affine_one));
      free_on_finalize(res);
      return res}
    var caml_pasta_fp_compare=plonk_wasm.caml_pasta_fp_compare;
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_out_channel_pos_fd(chan)
     {var info=caml_ml_channels[chan];return info.offset}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function integers_uint64_to_string(i)
     {return caml_int64_format(caml_new_string("%u"),i.value)}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function integers_uint32_serialize(writer,v,size)
     {writer.write(32,v.value);size[0] = 4;size[1] = 4}
    function caml_pasta_fp_poseidon_params_create(){return [0]}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_pasta_fq_sqrt(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fq_sqrt(x))}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function ml_z_hash(z1)
     {var a=bigInt(z1).toArray(Math.pow(2,32)),acc=0;
      for(var i=0;i < a.value.length;i++)
       acc = caml_hash_mix_int(acc,a.value[i]);
      if(a.value.length % 2 != 0)acc = caml_hash_mix_int(acc,0);
      if(a.isNegative)acc = acc + 1;
      return acc | 0}
    function integers_uint64_logand(x,y)
     {return new UInt64(caml_int64_and(x.value,y.value))}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_fq_vector_emplace_back(v,x){v.push(x)}
    function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x)}
    var caml_pasta_fp_of_bigint=plonk_wasm.caml_pasta_fp_of_bigint;
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function ml_z_root(z,i)
     {var zero=bigInt(0),one=bigInt(1);
      z = bigInt(z);
      if(i % 2 === 0 && z.lt(zero))
       caml_invalid_argument("Z.root: even root of a negative number");
      if(z.equals(zero) || z.equals(one))return ml_z_normalize(z);
      var start=zero,end=z,ans=null,two=bigInt(2);
      while(start.leq(end))
       {var mid=start.add(end).divide(two),po=mid.pow(i);
        if(po.equals(z))
         return ml_z_normalize(mid);
        else
         if(po.lt(z)){start = mid.next();ans = mid}else end = mid.prev()}
      return ml_z_normalize(ans)}
    function ml_z_sqrt_rem(z)
     {z = bigInt(z);
      var zero=bigInt(0);
      if(z.lt(zero))
       caml_invalid_argument("Z.sqrt_rem: square root of a negative number");
      var
       root=bigInt(ml_z_root(z,2)),
       mul=root.multiply(root),
       diff=z.subtract(mul);
      return [0,ml_z_normalize(root),ml_z_normalize(diff)]}
    var caml_ephe_data_offset=2;
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    var
     caml_pasta_fp_plonk_index_max_degree=
      plonk_wasm.caml_pasta_fp_plonk_index_max_degree;
    function caml_raw_backtrace_next_slot(){return 0}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    var caml_pasta_fq_add=plonk_wasm.caml_pasta_fq_add;
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_vesta_affine_deep_copy(pt)
     {return rust_affine_to_caml_affine
              (plonk_wasm.caml_vesta_affine_deep_copy
                (rust_affine_of_caml_affine
                  (pt,plonk_wasm.caml_vesta_affine_one)))}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function bin_prot_blit_buf_bytes_stub
     (v_src_pos,v_buf,v_dst_pos,v_str,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {c = caml_ba_get_1(v_buf,v_src_pos + i);
        caml_string_unsafe_set(v_str,v_dst_pos + i,c)}
      return 0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function ml_z_of_bits(z1)
     {var r=bigInt.zero,base1=bigInt(256),base=bigInt.one;
      for(var i=0;i < caml_ml_string_length(z1);i++)
       {var d=caml_string_unsafe_get(z1,i);
        r = bigInt(base).multiply(d).add(r);
        base = bigInt(base).multiply(base1)}
      return ml_z_normalize(r)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_pasta_fq_plonk_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return plonk_wasm.caml_pasta_fq_plonk_index_read
              (offset,urs,caml_jsstring_of_string(path))}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_zarith_unmarshal(reader,sz)
     {var negate;
      switch(reader.read8u())
       {case 1:negate = true;break;
        case 0:negate = false;break;
        default:caml_failwith("input_value: z (malformed input)")}
      var len=reader.read32u(),x=bigInt(0);
      for(var i=0;i < len / 4;i++)
       {var y=bigInt(reader.read8u());
        y = y.add(reader.read8u() << 8);
        y = y.add(reader.read8u() << 16);
        y = y.add(reader.read8u() << 24 >>> 0);
        x = y.shiftLeft(i * 32).add(x)}
      if(negate)x = x.negate();
      sz[0] = len + 4;
      return ml_z_normalize(x)}
    function caml_get_current_callstack(){return [0]}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    var caml_pasta_fq_of_int=plonk_wasm.caml_pasta_fq_of_int;
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function integers_uint8_of_string(x)
     {var y=integers_uint32_of_string(x);return x.value & 0xFF}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function integers_uint32_sub(x,y){return new UInt32(x.value - y.value)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function caml_pasta_fq_plonk_gate_vector_create()
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fq_plonk_gate_vector_create())}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function integers_uint32_div(x,y){return new UInt32(x.value / y.value)}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function fp_oracles_create(lgr_comm,verifier_index,proof)
     {return caml_oracles_of_rust
              (plonk_wasm.fp_oracles_create
                (caml_array_to_rust_vector
                  (lgr_comm,caml_vesta_poly_comm_to_rust),
                 caml_pasta_fp_plonk_verifier_index_to_rust(verifier_index),
                 caml_pasta_fp_proof_to_rust(proof)))}
    function caml_fq_vector_get(v,i)
     {return new (joo_global_object.Uint8Array)(v[i + 1])}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function bigstring_blit_string_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1
        (v_bstr,v_dst_pos + i,caml_string_get(v_str,v_src_pos + i));
      return 0}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_fp_vector_create(){return [0]}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_pallas_to_affine(pt)
     {var res=plonk_wasm.caml_pallas_to_affine(pt);
      return rust_affine_to_caml_affine(res)}
    function caml_fq_srs_create(i)
     {return free_on_finalize(plonk_wasm.caml_fq_srs_create(i))}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    var core_array_unsafe_float_blit=caml_array_blit;
    function caml_spacetime_enabled(_unit){return 0}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function integers_uint64_marshal(writer,v,sizes)
     {caml_int64_marshal(writer,v.value,sizes)}
    function caml_bytes_of_uint8array(uint8array)
     {var length=uint8array.length,ocaml_bytes=caml_create_bytes(length);
      for(var i=0;i < length;i++)
       caml_bytes_unsafe_set(ocaml_bytes,i,uint8array[i]);
      return ocaml_bytes}
    function caml_pasta_fq_plonk_gate_vector_digest(gate_vector)
     {var
       uint8array=
        plonk_wasm.caml_pasta_fq_plonk_gate_vector_digest(gate_vector);
      return caml_bytes_of_uint8array(uint8array)}
    function core_kernel_gc_compactions(){return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    var
     caml_pasta_fq_plonk_index_domain_d4_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d4_size;
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_pasta_fp_plonk_gate_vector_digest(gate_vector)
     {var
       uint8array=
        plonk_wasm.caml_pasta_fp_plonk_gate_vector_digest(gate_vector);
      return caml_bytes_of_uint8array(uint8array)}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function fp_oracles_dummy()
     {return caml_oracles_of_rust(plonk_wasm.fp_oracles_dummy())}
    function Base_clear_caml_backtrace_pos(x){return 0}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    var caml_bigint_256_compare=plonk_wasm.caml_bigint_256_compare;
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function Core_kernel_heap_block_is_heap_block(x)
     {return + (x instanceof Array)}
    function bigstring_blit_bytes_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1(v_bstr,v_dst_pos + i,caml_bytes_get(v_str,v_src_pos + i));
      return 0}
    function ml_z_pred(z1){return ml_z_normalize(bigInt(z1).prev())}
    function ml_z_extract(z1,pos,len)
     {z1 = bigInt(z1);
      return ml_z_normalize
              (z1.shiftRight(pos).and(bigInt(2).pow(len).subtract(1)))}
    function ml_z_lognot(z1){return ml_z_normalize(bigInt(z1).not())}
    var caml_pasta_fq_rng=plonk_wasm.caml_pasta_fq_rng;
    function caml_oracles_to_rust(x,klass,roKlass)
     {return new
              klass
              (caml_random_oracles_to_rust(x[1],roKlass),
               x[2][1],
               x[2][2],
               caml_u8array_vector_to_rust_flat_vector(x[3]),
               x[4])}
    function fp_oracles_deep_copy(x)
     {return caml_oracles_of_rust
              (plonk_wasm.fp_oracles_deep_copy
                (caml_oracles_to_rust
                  (x,plonk_wasm.WasmFpOracles,plonk_wasm.WasmFpRandomOracles)))}
    function caml_pasta_fp_is_square(x)
     {return caml_js_to_bool(plonk_wasm.caml_pasta_fp_is_square(x))}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function core_kernel_gc_top_heap_words(){return 0}
    function caml_pasta_fq_poseidon_params_create(){return [0]}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_fq_srs_lagrange_commitment(t,domain_size,i)
     {var res=plonk_wasm.caml_fq_srs_lagrange_commitment(t,domain_size,i);
      return caml_pallas_poly_comm_of_rust(res)}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    var caml_pallas_endo_scalar=plonk_wasm.caml_pallas_endo_scalar;
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    var caml_bigint_256_print=plonk_wasm.caml_bigint_256_print;
    function caml_bigint_256_of_numeral(s,len,base)
     {return plonk_wasm.caml_bigint_256_of_numeral
              (caml_jsstring_of_string(s),len,base)}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    var caml_pasta_fq_square=plonk_wasm.caml_pasta_fq_square;
    function caml_pasta_fq_mut_square(x)
     {caml_pasta_fq_copy(x,caml_pasta_fq_square(x))}
    function ml_z_numbits(z1)
     {z1 = bigInt(z1).abs();
      var n=0,upperBound=bigInt.one;
      while(upperBound.leq(z1)){n += 1;upperBound = upperBound.multiply(2)}
      return n}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_pasta_fq_poseidon_block_cipher(_fake_params,fq_vector)
     {var
       wasm_flat_vector=
        plonk_wasm.caml_pasta_fq_poseidon_block_cipher
         (caml_fq_vector_to_rust(fq_vector)),
       new_fq_vector=caml_fq_vector_of_rust(wasm_flat_vector);
      new_fq_vector.forEach(function(a,i){fq_vector[i] = a})}
    function caml_lazy_make_forward(v){return [250,v]}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function integers_uint64_mul(x,y)
     {return new UInt64(caml_int64_mul(x.value,y.value))}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function ml_z_init(unit)
     {caml_custom_ops["_z"]
      =
      {serialize:caml_zarith_marshal,
       deserialize:caml_zarith_unmarshal,
       hash:ml_z_hash};
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_pasta_fp_plonk_index_read(offset,urs,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      return plonk_wasm.caml_pasta_fp_plonk_index_read
              (offset,urs,caml_jsstring_of_string(path))}
    var caml_pasta_fp_negate=plonk_wasm.caml_pasta_fp_negate;
    function bin_prot_blit_string_buf_stub
     (v_src_pos,v_str,v_dst_pos,v_buf,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {c = caml_string_unsafe_get(v_str,v_src_pos + i);
        caml_ba_set_1(v_buf,v_dst_pos + i,c)}
      return 0}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    var caml_pasta_fp_sub=plonk_wasm.caml_pasta_fp_sub;
    function caml_pasta_fp_mut_sub(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_sub(x,y))}
    function caml_return_exn_constant(tag){return tag}
    function integers_uint64_unmarshal(reader,size)
     {return new UInt64(caml_int64_unmarshal(reader,size))}
    function ml_z_size(z1)
     {return bigInt(z1).toArray(Math.pow(2,32)).value.length}
    function ml_z_fits_int64(z1)
     {z1 = bigInt(z1);
      return z1.compare(bigInt("9223372036854775807"))
              <=
              0
              &&
              z1.compare(bigInt("-9223372036854775808"))
              >=
              0
              ?1
              :0}
    function ml_z_to_int64(z1)
     {z1 = bigInt(z1);
      if(! ml_z_fits_int64(z1))
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      var
       a=z1.and(bigInt(0xffffff)).toJSNumber() | 0,
       b=z1.shiftRight(24).and(bigInt(0xffffff)).toJSNumber() | 0,
       c=z1.shiftRight(48).and(bigInt(0xffff)).toJSNumber() | 0,
       x=[255,a,b,c];
      return x}
    function caml_backtrace_status(){return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_fp_srs_commit_evaluations(t,domain_size,fps)
     {var
       res=
        plonk_wasm.caml_fp_srs_commit_evaluations
         (t,domain_size,caml_fp_vector_to_rust(fps));
      return caml_vesta_poly_comm_of_rust(res)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_pasta_fp_plonk_proof_create
     (index,witness_cols,prev_challenges,prev_sgs)
     {var w=new (plonk_wasm.WasmVecVecFp)(witness_cols.length - 1);
      for(var i=1;i < witness_cols.length;i++)
       w.push(caml_fp_vector_to_rust(witness_cols[i]));
      witness_cols = w;
      prev_challenges = caml_fp_vector_to_rust(prev_challenges);
      prev_sgs
      =
      caml_array_to_rust_vector
       (prev_sgs,rust_affine_of_caml_affine,plonk_wasm.caml_vesta_affine_one);
      var
       res=
        plonk_wasm.caml_pasta_fp_plonk_proof_create
         (index,witness_cols,prev_challenges,prev_sgs),
       proof=caml_pasta_fp_proof_of_rust(res);
      return proof}
    var
     caml_pasta_fq_two_adic_root_of_unity=
      plonk_wasm.caml_pasta_fq_two_adic_root_of_unity;
    function caml_vesta_scale(x,y)
     {var res=plonk_wasm.caml_vesta_scale(x,y);
      free_on_finalize(res);
      return res}
    function ml_z_install_frametable(unit){return 0}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(s2,i2 + i,caml_ba_get_1(s1,i1 + i));
      return 0}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_pasta_fp_sqrt(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fp_sqrt(x))}
    function Base_int_math_int_popcount(v)
     {v = v - (v >>> 1 & 0x55555555);
      v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
      return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    var caml_pasta_fp_rng=plonk_wasm.caml_pasta_fp_rng;
    function caml_pasta_fp_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_pasta_fp_to_string(x))}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    function deferred_of_promise(promise)
     {var
       deferred=
        {promise:
         promise.then
           (function(value)
             {deferred.value = value;
              deferred.isDetermined = true;
              return value}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    var caml_pasta_fp_equal=plonk_wasm.caml_pasta_fp_equal;
    function integers_uint32_deserialize(reader,size)
     {size[0] = 4;return new UInt32(reader.read32u())}
    var caml_bigint_256_div=plonk_wasm.caml_bigint_256_div;
    function integers_uint32_to_string(i)
     {return caml_new_string(i.value.toString())}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_vesta_sub(x,y)
     {var res=plonk_wasm.caml_vesta_sub(x,y);free_on_finalize(res);return res}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function bigstringaf_memcmp_bigstring(ba1,ba1_off,ba2,ba2_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba1,ba1_off + i),caml_ba_get_1(ba2,ba2_off + i));
        if(c != 0)return c}
      return 0}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    var Base_internalhash_fold_string=caml_hash_mix_string;
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_fq_srs_batch_accumulator_check(srs,comms,chals)
     {var
       rust_comms=
        caml_array_to_rust_vector
         (comms,rust_affine_of_caml_affine,plonk_wasm.caml_pallas_affine_one),
       rust_chals=caml_fq_vector_to_rust(chals),
       ok=
        plonk_wasm.caml_fq_srs_batch_accumulator_check
         (srs,rust_comms,rust_chals);
      return ok}
    var caml_pasta_fp_deep_copy=plonk_wasm.caml_pasta_fp_deep_copy;
    function ml_z_add(z1,z2)
     {return ml_z_normalize(bigInt(z1).add(bigInt(z2)))}
    function ml_z_cdiv(z1,z2)
     {var z1_pos=ml_z_sign(z1),z2_pos=ml_z_sign(z2);
      if(z1_pos * z2_pos > 0)
       if(! bigInt(z1).mod(bigInt(z2)).equals(bigInt(0)))
        return ml_z_add(ml_z_div(z1,z2),bigInt(1));
      return ml_z_div(z1,z2)}
    function bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(dst,dst_off + i,caml_string_unsafe_get(src,src_off + i))}
    function caml_fq_srs_commit_evaluations(t,domain_size,fqs)
     {var
       res=
        plonk_wasm.caml_fq_srs_commit_evaluations
         (t,domain_size,caml_fq_vector_to_rust(fqs));
      return caml_pallas_poly_comm_of_rust(res)}
    function caml_pasta_fp_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_pasta_fp_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function integers_uint32_hash(v){return v.value}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    var caml_pasta_fq_mul=plonk_wasm.caml_pasta_fq_mul;
    function ml_z_of_int64(i64)
     {var neg=false;
      if(caml_int64_compare(i64,[255,0,0,0]) < 0)
       {neg = true;i64 = caml_int64_neg(i64)}
      var
       x=
        bigInt(i64[1]).add(bigInt(i64[2]).shiftLeft(24)).add
         (bigInt(i64[3]).shiftLeft(48));
      if(neg)x = x.negate();
      return ml_z_normalize(x)}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function integers_uint64_of_int(i)
     {return new UInt64(caml_int64_of_int32(i))}
    function ml_z_neg(z1){return ml_z_normalize(bigInt(z1).negate())}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    function expect_test_collector_before_test(voutput,vstdout,vstderr)
     {expect_test_collector_saved_stderr = caml_ml_channels[vstderr];
      expect_test_collector_saved_stdout = caml_ml_channels[vstdout];
      var output=caml_ml_channels[voutput];
      caml_ml_channels[vstdout] = output;
      caml_ml_channels[vstderr] = output;
      return 0}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function ml_z_of_int(i){return i | 0}
    function ml_z_of_int32(i32){return ml_z_of_int(i32)}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_pasta_fq_to_bytes(x)
     {var res=plonk_wasm.caml_pasta_fq_to_bytes(x);
      return caml_bytes_of_uint8array(plonk_wasm.caml_pasta_fq_to_bytes(x))}
    function caml_pallas_sub(x,y)
     {var res=plonk_wasm.caml_pallas_sub(x,y);
      free_on_finalize(res);
      return res}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function caml_pasta_fq_mut_add(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_add(x,y))}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function integers_uint64_rem(x,y)
     {if(y.value.isZero())caml_raise_zero_divide();
      x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return new UInt64(x.value.udivmod(y.value).modulus)}
    function ml_z_logor(z1,z2)
     {return ml_z_normalize(bigInt(z1).or(bigInt(z2)))}
    function ml_z_fits_int32(z1){return ml_z_fits_int(z1)}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_pasta_fq_mut_mul(x,y)
     {caml_pasta_fq_copy(x,caml_pasta_fq_mul(x,y))}
    var
     caml_pasta_fp_size=plonk_wasm.caml_pasta_fp_size,
     caml_bigint_256_num_limbs=plonk_wasm.caml_bigint_256_num_limbs;
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_pasta_fp_of_int=plonk_wasm.caml_pasta_fp_of_int;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function integers_ulong_size(unit){return 4}
    function caml_pasta_fp_plonk_verifier_index_deep_copy(x)
     {return caml_pasta_fp_plonk_verifier_index_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_deep_copy
                (caml_pasta_fp_plonk_verifier_index_to_rust(x)))}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function integers_uint32_shift_left(x,y){return new UInt32(x.value << y)}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function bin_prot_blit_float_array_buf_stub
     (v_src_pos,v_arr,v_dst_pos,v_buf,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {var
         f=caml_array_get(v_arr,v_src_pos + i),
         a=caml_int64_to_bytes(caml_int64_bits_of_float(f));
        for(var j=0;j < 8;j++)
         caml_ba_set_1(v_buf,v_dst_pos + j + i * 8,a[7 - j])}
      return 0}
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function Base_int_math_int_pow_stub(base,exponent)
     {var one=1,mul=[one,base,one,one],res=one;
      while(! exponent == 0)
       {mul[1] = mul[1] * mul[3] | 0;
        mul[2] = mul[1] * mul[1] | 0;
        mul[3] = mul[2] * mul[1] | 0;
        res = res * mul[exponent & 3] | 0;
        exponent = exponent >> 2}
      return res}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_pasta_fp_poseidon_block_cipher(_fake_params,fp_vector)
     {var
       wasm_flat_vector=
        plonk_wasm.caml_pasta_fp_poseidon_block_cipher
         (caml_fp_vector_to_rust(fp_vector)),
       new_fp_vector=caml_fp_vector_of_rust(wasm_flat_vector);
      new_fp_vector.forEach(function(a,i){fp_vector[i] = a})}
    function caml_vesta_double(x)
     {var res=plonk_wasm.caml_vesta_double(x);
      free_on_finalize(res);
      return res}
    function caml_pasta_fp_of_string(x)
     {return plonk_wasm.caml_pasta_fp_of_string(caml_jsstring_of_string(x))}
    function ml_z_testbit(z,pos)
     {z = bigInt(z);return z.shiftRight(pos).and(bigInt(1)).toJSNumber() | 0}
    function core_kernel_gc_major_plus_minor_words(){return 0}
    function caml_pasta_fp_plonk_verifier_index_shifts(log2_size)
     {return caml_plonk_verification_shifts_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_verifier_index_shifts(log2_size))}
    function bin_prot_blit_bytes_buf_stub
     (v_src_pos,v_str,v_dst_pos,v_buf,v_len)
     {var c;
      for(var i=0;i < v_len;i++)
       {c = caml_string_unsafe_get(v_str,v_src_pos + i);
        caml_ba_set_1(v_buf,v_dst_pos + i,c)}
      return 0}
    function caml_int64_sub(x,y){return x.sub(y)}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function bin_prot_blit_buf_stub(v_src_pos,v_src,v_dst_pos,v_dst,v_len)
     {var
       v_src2=bigstring_of_array_buffer(v_src.data.buffer),
       v_dst2=bigstring_of_array_buffer(v_dst.data.buffer),
       c;
      for(var i=0;i < v_len;i++)
       {c = caml_ba_get_1(v_src2,v_src_pos + i);
        caml_ba_set_1(v_dst2,v_dst_pos + i,c)}
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_sys_const_int_size(){return 32}
    function caml_fp_srs_lagrange_commitment(t,domain_size,i)
     {var res=plonk_wasm.caml_fp_srs_lagrange_commitment(t,domain_size,i);
      return caml_vesta_poly_comm_of_rust(res)}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function ml_z_sqrt(z1)
     {var z=bigInt(z1),zero=bigInt(0);
      if(z.lt(zero))
       caml_invalid_argument("Z.sqrt: square root of a negative number");
      return ml_z_root(z,2)}
    function caml_fp_srs_batch_accumulator_check(srs,comms,chals)
     {var
       rust_comms=
        caml_array_to_rust_vector
         (comms,rust_affine_of_caml_affine,plonk_wasm.caml_vesta_affine_one),
       rust_chals=caml_fp_vector_to_rust(chals),
       ok=
        plonk_wasm.caml_fp_srs_batch_accumulator_check
         (srs,rust_comms,rust_chals);
      return ok}
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function deferred_value_exn(deferred)
     {if(! deferred.isDetermined)
       throw Error("Deferred has not returned yet.");
      if(deferred.isError)throw deferred.error;
      return deferred.value}
    function ml_z_probab_prime(z,i){return bigInt(z).isProbablePrime(i)?1:0}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    var caml_bigint_256_deep_copy=plonk_wasm.caml_bigint_256_deep_copy;
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    var caml_pasta_fq_of_bigint=plonk_wasm.caml_pasta_fq_of_bigint;
    function caml_fq_vector_length(v){return v.length - 1}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_pasta_fp_plonk_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fp_plonk_index_write
              (append,t,caml_jsstring_of_string(path))}
    function caml_fp_vector_length(v){return v.length - 1}
    function caml_pasta_fq_inv(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fq_inv(x))}
    function ml_z_to_int(z1)
     {if(z1 == (z1 | 0))return z1 | 0;
      caml_raise_constant(caml_named_value("ml_z_overflow"))}
    function bigstringaf_blit_to_bytes(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_string_unsafe_set(dst,dst_off + i,caml_ba_get_1(src,src_off + i))}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_pasta_fp_inv(x)
     {return caml_option_of_maybe_undefined(plonk_wasm.caml_pasta_fp_inv(x))}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_const_big_endian(){return 0}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function core_kernel_gc_major_words(){return 0}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function integers_uint32_logand(x,y){return new UInt32(x.value & y.value)}
    function ml_z_succ(z1){return ml_z_normalize(bigInt(z1).next())}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_pasta_fq_plonk_proof_dummy()
     {return caml_pasta_fq_proof_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_proof_dummy())}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function integers_uint64_max(unit)
     {var x=caml_int64_create_lo_mi_hi(0xffffff,0xffffff,0xffff);
      x.hi = x.hi >>> 0;
      return new UInt64(x)}
    function integers_uint64_of_int64(i)
     {return new UInt64(caml_int64_create_lo_mi_hi(i.lo,i.mi,i.hi >>> 0))}
    function ml_z_gcd(z1,z2)
     {return ml_z_normalize(bigInt.gcd(bigInt(z1),bigInt(z2)).abs())}
    function caml_pasta_fp_to_bytes(x)
     {var res=plonk_wasm.caml_pasta_fp_to_bytes(x);
      return caml_bytes_of_uint8array(plonk_wasm.caml_pasta_fp_to_bytes(x))}
    function integers_size_t_size(unit){return 4}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    var
     caml_pasta_fp_plonk_index_domain_d4_size=
      plonk_wasm.caml_pasta_fp_plonk_index_domain_d4_size;
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function ml_z_div_rem(z1,z2){return [0,ml_z_div(z1,z2),ml_z_rem(z1,z2)]}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_pallas_rng(i)
     {var res=plonk_wasm.caml_pallas_rng(i);free_on_finalize(res);return res}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_pasta_fq_plonk_index_create(gates,public_inputs,urs)
     {return free_on_finalize
              (plonk_wasm.caml_pasta_fq_plonk_index_create
                (gates,public_inputs,urs))}
    function caml_ml_set_channel_name(){return 0}
    var caml_pasta_fp_mul=plonk_wasm.caml_pasta_fp_mul;
    function caml_pasta_fp_mut_mul(x,y)
     {caml_pasta_fp_copy(x,caml_pasta_fp_mul(x,y))}
    var caml_pasta_fp_print=plonk_wasm.caml_pasta_fp_print;
    function bigstring_memset_stub(bigstring,v_pos,v_len,v_char)
     {for(var i=0;i < v_len;i++)caml_ba_set_1(bigstring,v_pos + i,v_char)}
    var
     caml_pasta_fq_plonk_index_domain_d8_size=
      plonk_wasm.caml_pasta_fq_plonk_index_domain_d8_size,
     caml_pasta_fp_size_in_bits=plonk_wasm.caml_pasta_fp_size_in_bits;
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_fq_plonk_gate_to_rust(gate)
     {return new
              (plonk_wasm.WasmFqGate)
              (gate[1],
               caml_plonk_wires_to_rust(gate[2]),
               caml_u8array_vector_to_rust_flat_vector(gate[3]))}
    function caml_pasta_fq_plonk_gate_vector_add(v,x)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_add
              (v,caml_fq_plonk_gate_to_rust(x))}
    function caml_vesta_one()
     {var res=plonk_wasm.caml_vesta_one();free_on_finalize(res);return res}
    function Base_int_math_int64_clz(x)
     {var n=64,y;
      y = caml_int64_shift_right_unsigned(x,32);
      if(! caml_int64_is_zero(y)){n = n - 32;x = y}
      y = caml_int64_shift_right_unsigned(x,16);
      if(! caml_int64_is_zero(y)){n = n - 16;x = y}
      y = caml_int64_shift_right_unsigned(x,8);
      if(! caml_int64_is_zero(y)){n = n - 8;x = y}
      y = caml_int64_shift_right_unsigned(x,4);
      if(! caml_int64_is_zero(y)){n = n - 4;x = y}
      y = caml_int64_shift_right_unsigned(x,2);
      if(! caml_int64_is_zero(y)){n = n - 2;x = y}
      y = caml_int64_shift_right_unsigned(x,1);
      if(! caml_int64_is_zero(y))return n - 2;
      return n - caml_int64_to_int32(x)}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    var
     caml_pallas_endo_base=plonk_wasm.caml_pallas_endo_base,
     caml_pasta_fp_div=plonk_wasm.caml_pasta_fp_div;
    function ml_z_sub(z1,z2)
     {return ml_z_normalize(bigInt(z1).subtract(bigInt(z2)))}
    function ml_z_fdiv(z1,z2)
     {var z1_pos=ml_z_sign(z1),z2_pos=ml_z_sign(z2);
      if(z1_pos * z2_pos < 0)
       if(! bigInt(z1).mod(bigInt(z2)).equals(bigInt(0)))
        return ml_z_sub(ml_z_div(z1,z2),bigInt(1));
      return ml_z_div(z1,z2)}
    function caml_fq_srs_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_fq_srs_write
              (append,t,caml_jsstring_of_string(path))}
    function ml_z_to_bits(z1)
     {z1 = bigInt(z1).abs();
      var res="";
      while(! z1.equals(bigInt(0)))
       {res += String.fromCharCode(z1.mod(bigInt(256)));
        z1 = z1.divide(bigInt(256))}
      while(res.length % 4 != 0)res += String.fromCharCode(0);
      return caml_new_string(res)}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    var
     caml_pasta_fp_domain_generator=
      plonk_wasm.caml_pasta_fp_domain_generator;
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function deferred_upon_exn(deferred,func)
     {deferred.promise.then(function(){func(deferred.value)})}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function integers_uint64_to_int(i){return caml_int64_to_int32(i.value)}
    function caml_pasta_fq_plonk_gate_vector_wrap(v,x,y)
     {return plonk_wasm.caml_pasta_fq_plonk_gate_vector_wrap
              (v,caml_plonk_wire_to_rust(x),caml_plonk_wire_to_rust(y))}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function core_kernel_gc_promoted_words(){return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_bigint_256_to_bytes(x)
     {return caml_bytes_of_uint8array(plonk_wasm.caml_bigint_256_to_bytes(x))}
    function core_kernel_gc_heap_chunks(){return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function ml_z_of_nativeint(z){return ml_z_of_int(z)}
    function ml_z_invert(a,n)
     {a = bigInt(a);
      n = bigInt(n);
      var zero=bigInt(0),one=bigInt(1);
      if(n.abs().equals(one))return 0;
      if(n.equals(zero) && a.abs().equals(one))return a;
      if(n.equals(zero) || a.equals(zero))caml_raise_zero_divide();
      var
       x=ml_z_gcdext_intern(a,n),
       r=bigInt(x[2]),
       tmp=bigInt(a).multiply(r).mod(n);
      if(tmp.lt(zero))tmp = tmp.add(n.abs());
      if(r.lt(zero))r = r.add(n.abs());
      if(tmp.equals(one))return ml_z_normalize(r);
      caml_raise_zero_divide()}
    function ml_z_powm(z1,z2,z3)
     {var zero=bigInt(0),one=bigInt(1);
      z1 = bigInt(z1);
      z2 = bigInt(z2);
      z3 = bigInt(z3);
      if(z3.equals(zero))caml_raise_zero_divide();
      if(z3.abs().equals(one))return 0;
      if(z2.equals(zero))return 1;
      if(z2.lt(0))
       {var inv=bigInt(ml_z_invert(z1,z3)),r=inv.modPow(z2.negate(),z3);
        if(r.lt(zero))r = r.add(z3.abs());
        return ml_z_normalize(r)}
      else
       {var r=bigInt(z1).modPow(z2,z3);
        if(r.lt(zero))r = r.add(z3.abs());
        return ml_z_normalize(r)}}
    function ml_z_powm_sec(z1,z2,z3)
     {z3 = bigInt(z3).abs();
      var one=bigInt(1);
      if(bigInt(z2).lt(one))
       caml_invalid_argument("Z.powm_sec: exponent must be positive");
      if(! bigInt(z3).and(one).equals(one))
       caml_invalid_argument("Z.powm_sec: modulus must be odd");
      return ml_z_powm(z1,z2,z3)}
    function caml_js_pure_expr(f){return f()}
    var core_array_unsafe_int_blit=caml_array_blit;
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_sigio_handler(){return 0}
    var caml_pasta_fq_to_bigint=plonk_wasm.caml_pasta_fq_to_bigint;
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_fp_srs_read(offset,path)
     {if(offset === 0)offset = undefined;else offset = offset[1];
      var
       res=
        plonk_wasm.caml_fp_srs_read(offset,caml_jsstring_of_string(path));
      return res?[0,res]:0}
    function deferred_bind(deferred,func)
     {var
       newDeferred=
        {promise:
         deferred.promise.then(func).then
            (function(anotherDeferred){return anotherDeferred.promise}).then
           (function(value)
             {newDeferred.value = value;
              newDeferred.isDetermined = true;
              return value}).catch
          (function(err)
            {newDeferred.error = err;
             newDeferred.isError = true;
             newDeferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return newDeferred}
    function caml_bigint_256_of_bytes(ocaml_bytes)
     {return plonk_wasm.caml_bigint_256_of_bytes
              (caml_bytes_to_uint8array(ocaml_bytes))}
    var
     caml_pasta_fq_plonk_index_max_degree=
      plonk_wasm.caml_pasta_fq_plonk_index_max_degree;
    function core_kernel_gc_minor_collections(){return 0}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    var caml_pasta_fq_size_in_bits=plonk_wasm.caml_pasta_fq_size_in_bits;
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_get_exception_backtrace(){return 0}
    function integers_uint64_compare(x,y)
     {x.value.hi = x.value.hi >>> 0;
      y.value.hi = y.value.hi >>> 0;
      return x.value.ucompare(y.value)}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function ml_z_equal(z1,z2){return bigInt(z1).equals(bigInt(z2))}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function ml_z_perfect_square(z)
     {z = bigInt(z);
      if(z.lt(bigInt(0)))return 0;
      var root=bigInt(ml_z_root(z,2));
      return root.multiply(root).eq(z)?1:0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function ml_z_to_nativeint(z1){return ml_z_to_int(z1)}
    function bigstringaf_memcmp_string(ba,ba_off,str,str_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba,ba_off + i),
            caml_string_unsafe_get(str,str_off + i));
        if(c != 0)return c}
      return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function core_md5_digest_subbigstring(buf,ofs,len,res)
     {var bytes=caml_create_bytes(len);
      bigstring_blit_bigstring_bytes_stub(buf,ofs,bytes,0,len);
      var res2=caml_md5_string(bytes,0,len);
      caml_blit_string(res2,0,res,0,16);
      return 0}
    function caml_fp_srs_create(i)
     {return free_on_finalize(plonk_wasm.caml_fp_srs_create(i))}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_pallas_of_affine_coordinates(x,y)
     {var res=plonk_wasm.caml_pallas_of_affine_coordinates(x,y);
      free_on_finalize(res);
      return res}
    function deferred_map(deferred,func)
     {var
       newDeferred=
        {promise:
         deferred.promise.then(func).then
           (function(value)
             {newDeferred.value = value;
              newDeferred.isDetermined = true;
              return value}).catch
          (function(err)
            {newDeferred.error = err;
             newDeferred.isError = true;
             newDeferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return newDeferred}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function integers_uint64_shift_left(x,y)
     {return new UInt64(caml_int64_shift_left(x.value,y))}
    function caml_vesta_random()
     {var res=plonk_wasm.caml_vesta_random();free_on_finalize(res);return res}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_pasta_fq_div=plonk_wasm.caml_pasta_fq_div;
    function ml_z_logxor(z1,z2)
     {return ml_z_normalize(bigInt(z1).xor(bigInt(z2)))}
    var
     caml_pasta_fq_size=plonk_wasm.caml_pasta_fq_size,
     caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function ml_z_trailing_zeros(z)
     {z = bigInt(z).abs();
      var zero=bigInt(0),one=bigInt(1);
      if(z.equals(zero))return 0x7fffffff;
      var i=0;
      z = z.xor(z.prev()).shiftRight(1);
      for(i = 0;! z.equals(bigInt.zero);i++)z = z.shiftRight(1);
      return i}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_pallas_scale(x,y)
     {var res=plonk_wasm.caml_pallas_scale(x,y);
      free_on_finalize(res);
      return res}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_js_instanceof(o,c){return o instanceof c}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function integers_uint32_shift_right(x,y)
     {return new UInt32(x.value >>> y)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function integers_uint_size(unit){return 4}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_pasta_fq_plonk_proof_deep_copy(proof)
     {return caml_pasta_fq_proof_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_proof_deep_copy
                (caml_pasta_fq_proof_to_rust(proof)))}
    var caml_pasta_fq_negate=plonk_wasm.caml_pasta_fq_negate;
    function integers_ushort_size(unit){return 4}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function integers_uint32_rem(x,y)
     {if(y.value == 0)caml_raise_zero_divide();
      return new UInt32(x.value % y.value)}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_pasta_fq_plonk_verifier_index_shifts(log2_size)
     {return caml_plonk_verification_shifts_of_rust
              (plonk_wasm.caml_pasta_fq_plonk_verifier_index_shifts(log2_size))}
    function integers_uint64_shift_right(x,y)
     {return new UInt64(caml_int64_shift_right_unsigned(x.value,y))}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_pasta_fp_plonk_proof_dummy()
     {return caml_pasta_fp_proof_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_proof_dummy())}
    function Base_internalhash_get_hash_value(seed)
     {var h=caml_hash_mix_final(seed);return h & 0x3FFFFFFF}
    function integers_uint64_sub(x,y)
     {return new UInt64(caml_int64_sub(x.value,y.value))}
    function caml_pasta_fq_plonk_index_write(append,t,path)
     {if(append === 0)append = undefined;else append = append[1];
      return plonk_wasm.caml_pasta_fq_plonk_index_write
              (append,t,caml_jsstring_of_string(path))}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    var caml_pasta_fp_random=plonk_wasm.caml_pasta_fp_random;
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_pasta_fp_plonk_gate_vector_wrap(v,x,y)
     {return plonk_wasm.caml_pasta_fp_plonk_gate_vector_wrap
              (v,caml_plonk_wire_to_rust(x),caml_plonk_wire_to_rust(y))}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    function caml_fq_vector_create(){return [0]}
    var caml_pasta_fq_random=plonk_wasm.caml_pasta_fq_random;
    function ml_z_to_int32(z1){return ml_z_to_int(z1)}
    function caml_pasta_fp_plonk_verifier_index_dummy()
     {var res=plonk_wasm.caml_pasta_fp_plonk_verifier_index_dummy();
      return caml_pasta_fp_plonk_verifier_index_of_rust(res)}
    function deferred_upon(deferred,func)
     {deferred.promise.then(function(){func(deferred.value)}).catch
       (function(){})}
    function deferred_run(func)
     {var
       deferred=
        {promise:
         Promise.resolve().then(func).then
           (function(value)
             {deferred.value = value;
              deferred.isDetermined = true;
              return value}).catch
          (function(err)
            {deferred.error = err;
             deferred.isError = true;
             deferred.isDetermined = true;
             throw err}),
         isError:false,
         isDetermined:false};
      return deferred}
    function ml_z_compare(z1,z2){return bigInt(z1).compare(bigInt(z2))}
    function caml_pasta_fp_plonk_proof_batch_verify(indexes,proofs)
     {indexes
      =
      caml_array_to_rust_vector
       (indexes,caml_pasta_fp_plonk_verifier_index_to_rust);
      proofs = caml_array_to_rust_vector(proofs,caml_pasta_fp_proof_to_rust);
      return plonk_wasm.caml_pasta_fp_plonk_proof_batch_verify(indexes,proofs)}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function core_kernel_gc_major_collections(){return 0}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function ml_z_of_float(f1)
     {if(f1 == Infinity || f1 == - Infinity || f1 != f1)
       caml_raise_constant(caml_named_value("ml_z_overflow"));
      return ml_z_normalize(bigInt(f1 < 0?Math.ceil(f1):Math.floor(f1)))}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function fq_oracles_dummy()
     {return caml_oracles_of_rust(plonk_wasm.fq_oracles_dummy())}
    function deferred_return(value)
     {return {promise:Promise.resolve(value),
              value:value,
              isError:false,
              isDetermined:true}}
    function Base_hash_double(d){return caml_hash(1,1,0,d)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    var
     caml_pasta_fp_two_adic_root_of_unity=
      plonk_wasm.caml_pasta_fp_two_adic_root_of_unity;
    function caml_pasta_fq_of_string(x)
     {return plonk_wasm.caml_pasta_fq_of_string(caml_jsstring_of_string(x))}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function integers_uint64_hash(v){return caml_int64_hash(v.value)}
    function core_kernel_gc_heap_words(){return 0}
    function bigstringaf_blit_to_bigstring(src,src_off,dst,dst_off,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(dst,dst_off + i,caml_ba_get_1(src,src_off + i))}
    function caml_pallas_one()
     {var res=plonk_wasm.caml_pallas_one();free_on_finalize(res);return res}
    var ms_to_nano=caml_int64_of_int32(1000 * 1000);
    function time_now_nanoseconds_since_unix_epoch_or_zero()
     {var ms=Date.now(),ms_i63=caml_int64_of_float(ms * 2);
      return caml_int64_mul(ms_i63,ms_to_nano)}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    var
     caml_bigint_256_bytes_per_limb=
      plonk_wasm.caml_bigint_256_bytes_per_limb;
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_ba_layout(ba){return ba.layout}
    function integers_int32_of_uint32(i){return i.value | 0}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function ml_z_perfect_power(z)
     {z = bigInt(z);
      var zero=bigInt(0),one=bigInt(1);
      if(z.equals(zero) || z.equals(one) || z.equals(one.negate()))return 1;
      var log2z=ml_z_numbits(z.abs());
      for(var b=2;b <= log2z;b++)
       {if(z.lt(zero) && b % 2 == 0)continue;
        var zp=z.abs(),p=bigInt(ml_z_root(zp,b));
        if(z.lt(zero))p = p.negate();
        var r=bigInt(ml_z_pow(p,b));
        if(z.equals(r))return 1}
      return 0}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_pasta_fp_plonk_gate_vector_get(v,i)
     {return caml_plonk_gate_of_rust
              (plonk_wasm.caml_pasta_fp_plonk_gate_vector_get(v,i))}
    function integers_uint32_logor(x,y){return new UInt32(x.value | y.value)}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    var
     caml_pasta_fq_plonk_index_public_inputs=
      plonk_wasm.caml_pasta_fq_plonk_index_public_inputs;
    function caml_pasta_fq_to_string(x)
     {return caml_string_of_jsstring(plonk_wasm.caml_pasta_fq_to_string(x))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function ml_z_format(fmt,z1)
     {z1 = bigInt(z1);
      var
       fmt=fmt.toString(),
       base=10,
       cas=0,
       width=0,
       alt=0,
       dir=0,
       sign="",
       pad=" ",
       idx=0,
       prefix="";
      while(fmt[idx] == "%")idx++;
      for(;;idx++)
       if(fmt[idx] == "#")
        alt = 1;
       else
        if(fmt[idx] == "0")
         pad = "0";
        else
         if(fmt[idx] == "-")
          dir = 1;
         else
          if(fmt[idx] == " " || fmt[idx] == "+")sign = fmt[idx];else break;
      if(z1.lt(bigInt(0))){sign = "-";z1 = z1.negate()}
      for(;fmt[idx] >= "0" && fmt[idx] <= "9";idx++)
       width = 10 * width + + fmt[idx];
      switch(fmt[idx])
       {case "i":
        case "d":
        case "u":break;
        case "b":base = 2;if(alt)prefix = "0b";break;
        case "o":base = 8;if(alt)prefix = "0o";break;
        case "x":base = 16;if(alt)prefix = "0x";break;
        case "X":base = 16;if(alt)prefix = "0X";cas = 1;break;
        default:caml_failwith("Unsupported format '" + fmt + "'")}
      if(dir)pad = " ";
      var res=z1.toString(base);
      if(cas === 1)res = res.toUpperCase();
      var size=res.length;
      if(pad == " ")
       if(dir)
        {res = sign + prefix + res;for(;res.length < width;)res = res + pad}
       else
        {res = sign + prefix + res;for(;res.length < width;)res = pad + res}
      else
       {var pre=sign + prefix;
        for(;res.length + pre.length < width;)res = pad + res;
        res = pre + res}
      return caml_new_string(res)}
    function fq_oracles_deep_copy(x)
     {return caml_oracles_of_rust
              (plonk_wasm.fq_oracles_deep_copy
                (caml_oracles_to_rust
                  (x,plonk_wasm.WasmFqOracles,plonk_wasm.WasmFqRandomOracles)))}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function ml_z_shift_right_trunc(z1,z2)
     {return ml_z_div(bigInt(z1),bigInt(2).pow(z2))}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function integers_unsigned_init(unit)
     {caml_custom_ops["integers:uint8"]
      =
      {deserialize:integers_uint8_deserialize,fixed_length:1};
      caml_custom_ops["integers:uint16"]
      =
      {deserialize:integers_uint16_deserialize,fixed_length:2};
      caml_custom_ops["integers:uint32"]
      =
      {serialize:integers_uint32_serialize,
       deserialize:integers_uint32_deserialize,
       fixed_length:4,
       hash:integers_uint32_hash,
       compare:integers_uint32_compare};
      caml_custom_ops["integers:uint64"]
      =
      {serialize:integers_uint64_marshal,
       deserialize:integers_uint64_unmarshal,
       hash:integers_uint64_hash,
       compare:integers_uint64_compare};
      return unit}
    function integers_uint64_add(x,y)
     {return new UInt64(caml_int64_add(x.value,y.value))}
    function caml_pallas_add(x,y)
     {var res=plonk_wasm.caml_pallas_add(x,y);
      free_on_finalize(res);
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_pasta_fq_plonk_proof_batch_verify(indexes,proofs)
     {indexes
      =
      caml_array_to_rust_vector
       (indexes,caml_pasta_fq_plonk_verifier_index_to_rust);
      proofs = caml_array_to_rust_vector(proofs,caml_pasta_fq_proof_to_rust);
      return plonk_wasm.caml_pasta_fq_plonk_proof_batch_verify(indexes,proofs)}
    joo_global_object.jsoo_runtime
    =
    {plonk_wasm:plonk_wasm,
     startWorkers:startWorkers,
     wasm_ready:wasm_ready,
     _workers:_workers,
     worker_threads:worker_threads,
     integers_uint64_compare:integers_uint64_compare,
     integers_uint32_compare:integers_uint32_compare,
     integers_uint32_hash:integers_uint32_hash,
     integers_uint32_deserialize:integers_uint32_deserialize,
     integers_uint16_deserialize:integers_uint16_deserialize,
     integers_uint8_deserialize:integers_uint8_deserialize,
     integers_uint32_serialize:integers_uint32_serialize,
     integers_ushort_size:integers_ushort_size,
     integers_unsigned_init:integers_unsigned_init,
     integers_ulonglong_size:integers_ulonglong_size,
     integers_ulong_size:integers_ulong_size,
     integers_uint_size:integers_uint_size,
     integers_uint8_of_string:integers_uint8_of_string,
     integers_uint64_hash:integers_uint64_hash,
     integers_uint64_marshal:integers_uint64_marshal,
     integers_uint64_unmarshal:integers_uint64_unmarshal,
     integers_uint64_to_string:integers_uint64_to_string,
     integers_uint64_to_int64:integers_uint64_to_int64,
     integers_uint64_to_int:integers_uint64_to_int,
     integers_uint64_sub:integers_uint64_sub,
     integers_uint64_shift_right:integers_uint64_shift_right,
     integers_uint64_shift_left:integers_uint64_shift_left,
     integers_uint64_rem:integers_uint64_rem,
     integers_uint64_of_string:integers_uint64_of_string,
     integers_uint_of_string:integers_uint_of_string,
     integers_uint64_of_int64:integers_uint64_of_int64,
     integers_uint64_of_int:integers_uint64_of_int,
     integers_uint64_mul:integers_uint64_mul,
     integers_uint64_max:integers_uint64_max,
     integers_uint64_logxor:integers_uint64_logxor,
     integers_uint64_logor:integers_uint64_logor,
     integers_uint64_logand:integers_uint64_logand,
     integers_uint64_div:integers_uint64_div,
     integers_uint64_add:integers_uint64_add,
     UInt64:UInt64,
     integers_uint32_to_string:integers_uint32_to_string,
     integers_uint32_to_int64:integers_uint32_to_int64,
     integers_uint32_to_int:integers_uint32_to_int,
     integers_uint32_shift_right:integers_uint32_shift_right,
     integers_uint32_shift_left:integers_uint32_shift_left,
     integers_uint32_rem:integers_uint32_rem,
     integers_uint32_of_string:integers_uint32_of_string,
     integers_uint32_of_int64:integers_uint32_of_int64,
     integers_uint32_of_int32:integers_uint32_of_int32,
     integers_uint32_of_int:integers_uint32_of_int,
     integers_uint32_mul:integers_uint32_mul,
     integers_uint32_max:integers_uint32_max,
     integers_uint32_logxor:integers_uint32_logxor,
     integers_uint32_logor:integers_uint32_logor,
     integers_uint32_logand:integers_uint32_logand,
     integers_uint32_div:integers_uint32_div,
     integers_uint32_sub:integers_uint32_sub,
     integers_uint32_add:integers_uint32_add,
     integers_uint16_of_string:integers_uint16_of_string,
     integers_size_t_size:integers_size_t_size,
     integers_int32_of_uint32:integers_int32_of_uint32,
     UInt32:UInt32,
     caml_pasta_fq_poseidon_block_cipher:caml_pasta_fq_poseidon_block_cipher,
     caml_pasta_fp_poseidon_block_cipher:caml_pasta_fp_poseidon_block_cipher,
     caml_pasta_fq_poseidon_params_create:caml_pasta_fq_poseidon_params_create,
     caml_pasta_fp_poseidon_params_create:caml_pasta_fp_poseidon_params_create,
     fq_oracles_deep_copy:fq_oracles_deep_copy,
     fq_oracles_dummy:fq_oracles_dummy,
     fq_oracles_create:fq_oracles_create,
     fp_oracles_deep_copy:fp_oracles_deep_copy,
     fp_oracles_dummy:fp_oracles_dummy,
     fp_oracles_create:fp_oracles_create,
     caml_oracles_to_rust:caml_oracles_to_rust,
     caml_oracles_of_rust:caml_oracles_of_rust,
     caml_random_oracles_to_rust:caml_random_oracles_to_rust,
     caml_random_oracles_of_rust:caml_random_oracles_of_rust,
     caml_pasta_fq_plonk_proof_deep_copy:caml_pasta_fq_plonk_proof_deep_copy,
     caml_pasta_fq_plonk_proof_dummy:caml_pasta_fq_plonk_proof_dummy,
     caml_pasta_fq_plonk_proof_batch_verify:
     caml_pasta_fq_plonk_proof_batch_verify,
     caml_pasta_fq_plonk_proof_verify:caml_pasta_fq_plonk_proof_verify,
     caml_pasta_fq_plonk_proof_create:caml_pasta_fq_plonk_proof_create,
     caml_pasta_fq_proof_of_rust:caml_pasta_fq_proof_of_rust,
     caml_pasta_fq_proof_to_rust:caml_pasta_fq_proof_to_rust,
     caml_pasta_fq_commitments_of_rust:caml_pasta_fq_commitments_of_rust,
     caml_pasta_fq_commitments_to_rust:caml_pasta_fq_commitments_to_rust,
     caml_pasta_fq_opening_proof_of_rust:caml_pasta_fq_opening_proof_of_rust,
     caml_pasta_fq_opening_proof_to_rust:caml_pasta_fq_opening_proof_to_rust,
     caml_pasta_fq_proof_evaluations_of_rust:
     caml_pasta_fq_proof_evaluations_of_rust,
     caml_pasta_fq_proof_evaluations_to_rust:
     caml_pasta_fq_proof_evaluations_to_rust,
     caml_pasta_fp_plonk_proof_deep_copy:caml_pasta_fp_plonk_proof_deep_copy,
     caml_pasta_fp_plonk_proof_dummy:caml_pasta_fp_plonk_proof_dummy,
     caml_pasta_fp_plonk_proof_batch_verify:
     caml_pasta_fp_plonk_proof_batch_verify,
     caml_pasta_fp_plonk_proof_verify:caml_pasta_fp_plonk_proof_verify,
     caml_pasta_fp_plonk_proof_create:caml_pasta_fp_plonk_proof_create,
     caml_pasta_fp_proof_of_rust:caml_pasta_fp_proof_of_rust,
     caml_pasta_fp_proof_to_rust:caml_pasta_fp_proof_to_rust,
     caml_pasta_fp_commitments_of_rust:caml_pasta_fp_commitments_of_rust,
     caml_pasta_fp_commitments_to_rust:caml_pasta_fp_commitments_to_rust,
     caml_pasta_fp_opening_proof_of_rust:caml_pasta_fp_opening_proof_of_rust,
     caml_pasta_fp_opening_proof_to_rust:caml_pasta_fp_opening_proof_to_rust,
     caml_pasta_fp_proof_evaluations_of_rust:
     caml_pasta_fp_proof_evaluations_of_rust,
     caml_pasta_fp_proof_evaluations_to_rust:
     caml_pasta_fp_proof_evaluations_to_rust,
     PERMUTS_MINUS_1:PERMUTS_MINUS_1,
     COLUMNS:COLUMNS,
     caml_pasta_fq_plonk_verifier_index_deep_copy:
     caml_pasta_fq_plonk_verifier_index_deep_copy,
     caml_pasta_fq_plonk_verifier_index_dummy:
     caml_pasta_fq_plonk_verifier_index_dummy,
     caml_pasta_fq_plonk_verifier_index_shifts:
     caml_pasta_fq_plonk_verifier_index_shifts,
     caml_pasta_fq_plonk_verifier_index_write:
     caml_pasta_fq_plonk_verifier_index_write,
     caml_pasta_fq_plonk_verifier_index_read:
     caml_pasta_fq_plonk_verifier_index_read,
     caml_pasta_fq_plonk_verifier_index_create:
     caml_pasta_fq_plonk_verifier_index_create,
     caml_pasta_fq_plonk_verifier_index_to_rust:
     caml_pasta_fq_plonk_verifier_index_to_rust,
     caml_pasta_fq_plonk_verifier_index_of_rust:
     caml_pasta_fq_plonk_verifier_index_of_rust,
     caml_pasta_fp_plonk_verifier_index_deep_copy:
     caml_pasta_fp_plonk_verifier_index_deep_copy,
     caml_pasta_fp_plonk_verifier_index_dummy:
     caml_pasta_fp_plonk_verifier_index_dummy,
     caml_pasta_fp_plonk_verifier_index_shifts:
     caml_pasta_fp_plonk_verifier_index_shifts,
     caml_pasta_fp_plonk_verifier_index_write:
     caml_pasta_fp_plonk_verifier_index_write,
     caml_pasta_fp_plonk_verifier_index_read:
     caml_pasta_fp_plonk_verifier_index_read,
     caml_pasta_fp_plonk_verifier_index_create:
     caml_pasta_fp_plonk_verifier_index_create,
     caml_pasta_fp_plonk_verifier_index_to_rust:
     caml_pasta_fp_plonk_verifier_index_to_rust,
     caml_pasta_fp_plonk_verifier_index_of_rust:
     caml_pasta_fp_plonk_verifier_index_of_rust,
     caml_plonk_verifier_index_to_rust:caml_plonk_verifier_index_to_rust,
     caml_plonk_verifier_index_of_rust:caml_plonk_verifier_index_of_rust,
     None:None,
     linearization_of_rust:linearization_of_rust,
     wrap:wrap,
     index_term_of_rust:index_term_of_rust,
     polish_token_of_rust:polish_token_of_rust,
     variable_of_rust:variable_of_rust,
     column_of_rust:column_of_rust,
     caml_plonk_verification_shifts_to_rust:
     caml_plonk_verification_shifts_to_rust,
     caml_plonk_verification_shifts_of_rust:
     caml_plonk_verification_shifts_of_rust,
     caml_plonk_verification_evals_to_rust:
     caml_plonk_verification_evals_to_rust,
     caml_plonk_verification_evals_of_rust:
     caml_plonk_verification_evals_of_rust,
     caml_plonk_domain_to_rust:caml_plonk_domain_to_rust,
     caml_plonk_domain_of_rust:caml_plonk_domain_of_rust,
     caml_pasta_fq_plonk_index_write:caml_pasta_fq_plonk_index_write,
     caml_pasta_fq_plonk_index_read:caml_pasta_fq_plonk_index_read,
     caml_pasta_fq_plonk_index_domain_d8_size:
     caml_pasta_fq_plonk_index_domain_d8_size,
     caml_pasta_fq_plonk_index_domain_d4_size:
     caml_pasta_fq_plonk_index_domain_d4_size,
     caml_pasta_fq_plonk_index_domain_d1_size:
     caml_pasta_fq_plonk_index_domain_d1_size,
     caml_pasta_fq_plonk_index_public_inputs:
     caml_pasta_fq_plonk_index_public_inputs,
     caml_pasta_fq_plonk_index_max_degree:caml_pasta_fq_plonk_index_max_degree,
     caml_pasta_fq_plonk_index_create:caml_pasta_fq_plonk_index_create,
     caml_pasta_fp_plonk_index_write:caml_pasta_fp_plonk_index_write,
     caml_pasta_fp_plonk_index_read:caml_pasta_fp_plonk_index_read,
     caml_pasta_fp_plonk_index_domain_d8_size:
     caml_pasta_fp_plonk_index_domain_d8_size,
     caml_pasta_fp_plonk_index_domain_d4_size:
     caml_pasta_fp_plonk_index_domain_d4_size,
     caml_pasta_fp_plonk_index_domain_d1_size:
     caml_pasta_fp_plonk_index_domain_d1_size,
     caml_pasta_fp_plonk_index_public_inputs:
     caml_pasta_fp_plonk_index_public_inputs,
     caml_pasta_fp_plonk_index_max_degree:caml_pasta_fp_plonk_index_max_degree,
     caml_pasta_fp_plonk_index_create:caml_pasta_fp_plonk_index_create,
     caml_pasta_fq_plonk_gate_vector_digest:
     caml_pasta_fq_plonk_gate_vector_digest,
     caml_pasta_fq_plonk_gate_vector_wrap:caml_pasta_fq_plonk_gate_vector_wrap,
     caml_pasta_fq_plonk_gate_vector_get:caml_pasta_fq_plonk_gate_vector_get,
     caml_pasta_fq_plonk_gate_vector_add:caml_pasta_fq_plonk_gate_vector_add,
     caml_pasta_fq_plonk_gate_vector_create:
     caml_pasta_fq_plonk_gate_vector_create,
     caml_pasta_fp_plonk_gate_vector_digest:
     caml_pasta_fp_plonk_gate_vector_digest,
     caml_pasta_fp_plonk_gate_vector_wrap:caml_pasta_fp_plonk_gate_vector_wrap,
     caml_pasta_fp_plonk_gate_vector_get:caml_pasta_fp_plonk_gate_vector_get,
     caml_pasta_fp_plonk_gate_vector_add:caml_pasta_fp_plonk_gate_vector_add,
     caml_pasta_fp_plonk_gate_vector_create:
     caml_pasta_fp_plonk_gate_vector_create,
     caml_fq_plonk_gate_to_rust:caml_fq_plonk_gate_to_rust,
     caml_fp_plonk_gate_to_rust:caml_fp_plonk_gate_to_rust,
     caml_plonk_gate_of_rust:caml_plonk_gate_of_rust,
     caml_plonk_wires_to_rust:caml_plonk_wires_to_rust,
     caml_plonk_wires_of_rust:caml_plonk_wires_of_rust,
     caml_plonk_wire_to_rust:caml_plonk_wire_to_rust,
     caml_plonk_wire_of_rust:caml_plonk_wire_of_rust,
     caml_fq_srs_h:caml_fq_srs_h,
     caml_fq_srs_batch_accumulator_check:caml_fq_srs_batch_accumulator_check,
     caml_fq_srs_b_poly_commitment:caml_fq_srs_b_poly_commitment,
     caml_fq_srs_commit_evaluations:caml_fq_srs_commit_evaluations,
     caml_fq_srs_lagrange_commitment:caml_fq_srs_lagrange_commitment,
     caml_fq_srs_read:caml_fq_srs_read,
     caml_fq_srs_write:caml_fq_srs_write,
     caml_fq_srs_create:caml_fq_srs_create,
     caml_fp_srs_h:caml_fp_srs_h,
     caml_fp_srs_batch_accumulator_check:caml_fp_srs_batch_accumulator_check,
     caml_fp_srs_b_poly_commitment:caml_fp_srs_b_poly_commitment,
     caml_fp_srs_commit_evaluations:caml_fp_srs_commit_evaluations,
     caml_fp_srs_lagrange_commitment:caml_fp_srs_lagrange_commitment,
     caml_fp_srs_read:caml_fp_srs_read,
     caml_fp_srs_write:caml_fp_srs_write,
     caml_fp_srs_create:caml_fp_srs_create,
     caml_pallas_poly_comm_to_rust:caml_pallas_poly_comm_to_rust,
     caml_pallas_poly_comm_of_rust:caml_pallas_poly_comm_of_rust,
     caml_vesta_poly_comm_to_rust:caml_vesta_poly_comm_to_rust,
     caml_vesta_poly_comm_of_rust:caml_vesta_poly_comm_of_rust,
     caml_poly_comm_to_rust_poly_comm:caml_poly_comm_to_rust_poly_comm,
     caml_poly_comm_of_rust_poly_comm:caml_poly_comm_of_rust_poly_comm,
     caml_array_to_rust_vector:caml_array_to_rust_vector,
     caml_array_of_rust_vector:caml_array_of_rust_vector,
     caml_vesta_affine_deep_copy:caml_vesta_affine_deep_copy,
     caml_vesta_endo_scalar:caml_vesta_endo_scalar,
     caml_vesta_endo_base:caml_vesta_endo_base,
     caml_vesta_of_affine_coordinates:caml_vesta_of_affine_coordinates,
     caml_vesta_of_affine:caml_vesta_of_affine,
     caml_vesta_to_affine:caml_vesta_to_affine,
     caml_vesta_rng:caml_vesta_rng,
     caml_vesta_random:caml_vesta_random,
     caml_vesta_scale:caml_vesta_scale,
     caml_vesta_double:caml_vesta_double,
     caml_vesta_negate:caml_vesta_negate,
     caml_vesta_sub:caml_vesta_sub,
     caml_vesta_add:caml_vesta_add,
     caml_vesta_one:caml_vesta_one,
     caml_pallas_affine_deep_copy:caml_pallas_affine_deep_copy,
     caml_pallas_endo_scalar:caml_pallas_endo_scalar,
     caml_pallas_endo_base:caml_pallas_endo_base,
     caml_pallas_of_affine_coordinates:caml_pallas_of_affine_coordinates,
     caml_pallas_of_affine:caml_pallas_of_affine,
     caml_pallas_to_affine:caml_pallas_to_affine,
     caml_pallas_rng:caml_pallas_rng,
     caml_pallas_random:caml_pallas_random,
     caml_pallas_scale:caml_pallas_scale,
     caml_pallas_double:caml_pallas_double,
     caml_pallas_negate:caml_pallas_negate,
     caml_pallas_sub:caml_pallas_sub,
     caml_pallas_add:caml_pallas_add,
     caml_pallas_one:caml_pallas_one,
     rust_affine_of_caml_affine:rust_affine_of_caml_affine,
     rust_affine_to_caml_affine:rust_affine_to_caml_affine,
     free_on_finalize:free_on_finalize,
     free_finalization_registry:free_finalization_registry,
     caml_fq_vector_of_rust:caml_fq_vector_of_rust,
     caml_fq_vector_to_rust:caml_fq_vector_to_rust,
     caml_fq_vector_get:caml_fq_vector_get,
     caml_fq_vector_emplace_back:caml_fq_vector_emplace_back,
     caml_fq_vector_length:caml_fq_vector_length,
     caml_fq_vector_create:caml_fq_vector_create,
     caml_fp_vector_of_rust:caml_fp_vector_of_rust,
     caml_fp_vector_to_rust:caml_fp_vector_to_rust,
     caml_fp_vector_get:caml_fp_vector_get,
     caml_fp_vector_emplace_back:caml_fp_vector_emplace_back,
     caml_fp_vector_length:caml_fp_vector_length,
     caml_fp_vector_create:caml_fp_vector_create,
     js_class_vector_of_rust_vector:js_class_vector_of_rust_vector,
     js_class_vector_to_rust_vector:js_class_vector_to_rust_vector,
     caml_u8array_vector_of_rust_flat_vector:
     caml_u8array_vector_of_rust_flat_vector,
     caml_u8array_vector_to_rust_flat_vector:
     caml_u8array_vector_to_rust_flat_vector,
     caml_pasta_fq_deep_copy:caml_pasta_fq_deep_copy,
     caml_pasta_fq_of_bytes:caml_pasta_fq_of_bytes,
     caml_pasta_fq_to_bytes:caml_pasta_fq_to_bytes,
     caml_pasta_fq_domain_generator:caml_pasta_fq_domain_generator,
     caml_pasta_fq_two_adic_root_of_unity:caml_pasta_fq_two_adic_root_of_unity,
     caml_pasta_fq_of_bigint:caml_pasta_fq_of_bigint,
     caml_pasta_fq_to_bigint:caml_pasta_fq_to_bigint,
     caml_pasta_fq_rng:caml_pasta_fq_rng,
     caml_pasta_fq_random:caml_pasta_fq_random,
     caml_pasta_fq_equal:caml_pasta_fq_equal,
     caml_pasta_fq_compare:caml_pasta_fq_compare,
     caml_pasta_fq_mut_square:caml_pasta_fq_mut_square,
     caml_pasta_fq_mut_mul:caml_pasta_fq_mut_mul,
     caml_pasta_fq_mut_sub:caml_pasta_fq_mut_sub,
     caml_pasta_fq_mut_add:caml_pasta_fq_mut_add,
     caml_pasta_fq_print:caml_pasta_fq_print,
     caml_pasta_fq_of_string:caml_pasta_fq_of_string,
     caml_pasta_fq_to_string:caml_pasta_fq_to_string,
     caml_pasta_fq_of_int:caml_pasta_fq_of_int,
     caml_pasta_fq_sqrt:caml_pasta_fq_sqrt,
     caml_pasta_fq_is_square:caml_pasta_fq_is_square,
     caml_pasta_fq_square:caml_pasta_fq_square,
     caml_pasta_fq_inv:caml_pasta_fq_inv,
     caml_pasta_fq_div:caml_pasta_fq_div,
     caml_pasta_fq_mul:caml_pasta_fq_mul,
     caml_pasta_fq_negate:caml_pasta_fq_negate,
     caml_pasta_fq_sub:caml_pasta_fq_sub,
     caml_pasta_fq_add:caml_pasta_fq_add,
     caml_pasta_fq_size:caml_pasta_fq_size,
     caml_pasta_fq_size_in_bits:caml_pasta_fq_size_in_bits,
     caml_pasta_fq_copy:caml_pasta_fq_copy,
     caml_pasta_fp_deep_copy:caml_pasta_fp_deep_copy,
     caml_pasta_fp_of_bytes:caml_pasta_fp_of_bytes,
     caml_pasta_fp_to_bytes:caml_pasta_fp_to_bytes,
     caml_pasta_fp_domain_generator:caml_pasta_fp_domain_generator,
     caml_pasta_fp_two_adic_root_of_unity:caml_pasta_fp_two_adic_root_of_unity,
     caml_pasta_fp_of_bigint:caml_pasta_fp_of_bigint,
     caml_pasta_fp_to_bigint:caml_pasta_fp_to_bigint,
     caml_pasta_fp_rng:caml_pasta_fp_rng,
     caml_pasta_fp_random:caml_pasta_fp_random,
     caml_pasta_fp_equal:caml_pasta_fp_equal,
     caml_pasta_fp_compare:caml_pasta_fp_compare,
     caml_pasta_fp_mut_square:caml_pasta_fp_mut_square,
     caml_pasta_fp_mut_mul:caml_pasta_fp_mut_mul,
     caml_pasta_fp_mut_sub:caml_pasta_fp_mut_sub,
     caml_pasta_fp_mut_add:caml_pasta_fp_mut_add,
     caml_pasta_fp_print:caml_pasta_fp_print,
     caml_pasta_fp_of_string:caml_pasta_fp_of_string,
     caml_pasta_fp_to_string:caml_pasta_fp_to_string,
     caml_pasta_fp_of_int:caml_pasta_fp_of_int,
     caml_pasta_fp_sqrt:caml_pasta_fp_sqrt,
     caml_pasta_fp_is_square:caml_pasta_fp_is_square,
     caml_pasta_fp_square:caml_pasta_fp_square,
     caml_pasta_fp_inv:caml_pasta_fp_inv,
     caml_pasta_fp_div:caml_pasta_fp_div,
     caml_pasta_fp_mul:caml_pasta_fp_mul,
     caml_pasta_fp_negate:caml_pasta_fp_negate,
     caml_pasta_fp_sub:caml_pasta_fp_sub,
     caml_pasta_fp_add:caml_pasta_fp_add,
     caml_pasta_fp_size:caml_pasta_fp_size,
     caml_pasta_fp_size_in_bits:caml_pasta_fp_size_in_bits,
     caml_option_to_maybe_undefined:caml_option_to_maybe_undefined,
     caml_option_of_maybe_undefined:caml_option_of_maybe_undefined,
     caml_pasta_fp_copy:caml_pasta_fp_copy,
     caml_bigint_256_deep_copy:caml_bigint_256_deep_copy,
     caml_bigint_256_of_bytes:caml_bigint_256_of_bytes,
     caml_bigint_256_to_bytes:caml_bigint_256_to_bytes,
     caml_bigint_256_test_bit:caml_bigint_256_test_bit,
     caml_bigint_256_to_string:caml_bigint_256_to_string,
     caml_bigint_256_print:caml_bigint_256_print,
     caml_bigint_256_compare:caml_bigint_256_compare,
     caml_bigint_256_div:caml_bigint_256_div,
     caml_bigint_256_bytes_per_limb:caml_bigint_256_bytes_per_limb,
     caml_bigint_256_num_limbs:caml_bigint_256_num_limbs,
     caml_bigint_256_of_decimal_string:caml_bigint_256_of_decimal_string,
     caml_bigint_256_of_numeral:caml_bigint_256_of_numeral,
     caml_bytes_to_uint8array:caml_bytes_to_uint8array,
     caml_bytes_of_uint8array:caml_bytes_of_uint8array,
     deferred_of_promise:deferred_of_promise,
     deferred_to_promise:deferred_to_promise,
     deferred_create:deferred_create,
     deferred_return:deferred_return,
     deferred_value_exn:deferred_value_exn,
     deferred_peek:deferred_peek,
     deferred_is_determined:deferred_is_determined,
     deferred_upon_exn:deferred_upon_exn,
     deferred_upon:deferred_upon,
     deferred_bind:deferred_bind,
     deferred_map:deferred_map,
     deferred_run:deferred_run,
     bigstringaf_memcmp_string:bigstringaf_memcmp_string,
     bigstringaf_memcmp_bigstring:bigstringaf_memcmp_bigstring,
     bigstringaf_blit_from_bytes:bigstringaf_blit_from_bytes,
     bigstringaf_blit_to_bigstring:bigstringaf_blit_to_bigstring,
     bigstringaf_blit_to_bytes:bigstringaf_blit_to_bytes,
     caml_zarith_unmarshal:caml_zarith_unmarshal,
     caml_zarith_marshal:caml_zarith_marshal,
     ml_z_divexact:ml_z_divexact,
     ml_z_size:ml_z_size,
     ml_z_hamdist:ml_z_hamdist,
     ml_z_popcount:ml_z_popcount,
     ml_z_trailing_zeros:ml_z_trailing_zeros,
     ml_z_sqrt_rem:ml_z_sqrt_rem,
     ml_z_sqrt:ml_z_sqrt,
     ml_z_gcdext_intern:ml_z_gcdext_intern,
     ml_z_extract:ml_z_extract,
     ml_z_nextprime:ml_z_nextprime,
     ml_z_probab_prime:ml_z_probab_prime,
     ml_z_perfect_square:ml_z_perfect_square,
     ml_z_perfect_power:ml_z_perfect_power,
     ml_z_invert:ml_z_invert,
     ml_z_root:ml_z_root,
     ml_z_powm_sec:ml_z_powm_sec,
     ml_z_of_bits:ml_z_of_bits,
     ml_z_to_bits:ml_z_to_bits,
     ml_z_hash:ml_z_hash,
     ml_z_pow:ml_z_pow,
     ml_z_powm:ml_z_powm,
     ml_z_fits_nativeint:ml_z_fits_nativeint,
     ml_z_fits_int64:ml_z_fits_int64,
     ml_z_fits_int32:ml_z_fits_int32,
     ml_z_fits_int:ml_z_fits_int,
     ml_z_numbits:ml_z_numbits,
     ml_z_gcd:ml_z_gcd,
     ml_z_sign:ml_z_sign,
     ml_z_equal:ml_z_equal,
     ml_z_compare:ml_z_compare,
     ml_z_of_substring_base:ml_z_of_substring_base,
     jsoo_z_of_js_string_base:jsoo_z_of_js_string_base,
     ml_z_format:ml_z_format,
     ml_z_to_nativeint:ml_z_to_nativeint,
     ml_z_testbit:ml_z_testbit,
     ml_z_to_int64:ml_z_to_int64,
     ml_z_to_int32:ml_z_to_int32,
     ml_z_to_int:ml_z_to_int,
     ml_z_of_float:ml_z_of_float,
     ml_z_of_int64:ml_z_of_int64,
     ml_z_of_nativeint:ml_z_of_nativeint,
     ml_z_of_int32:ml_z_of_int32,
     ml_z_of_int:ml_z_of_int,
     ml_z_shift_right_trunc:ml_z_shift_right_trunc,
     ml_z_shift_right:ml_z_shift_right,
     ml_z_shift_left:ml_z_shift_left,
     ml_z_lognot:ml_z_lognot,
     ml_z_logxor:ml_z_logxor,
     ml_z_logor:ml_z_logor,
     ml_z_logand:ml_z_logand,
     ml_z_abs:ml_z_abs,
     ml_z_pred:ml_z_pred,
     ml_z_succ:ml_z_succ,
     ml_z_div_rem:ml_z_div_rem,
     ml_z_rem:ml_z_rem,
     ml_z_fdiv:ml_z_fdiv,
     ml_z_cdiv:ml_z_cdiv,
     ml_z_div:ml_z_div,
     ml_z_mul:ml_z_mul,
     ml_z_sub:ml_z_sub,
     ml_z_add:ml_z_add,
     ml_z_neg:ml_z_neg,
     ml_z_install_frametable:ml_z_install_frametable,
     ml_z_init:ml_z_init,
     ml_z_normalize:ml_z_normalize,
     bigInt:bigInt,
     bigstring_realloc:bigstring_realloc,
     bigstring_destroy_stub:bigstring_destroy_stub,
     core_md5_digest_subbigstring:core_md5_digest_subbigstring,
     core_md5_fd:core_md5_fd,
     Core_kernel_heap_block_is_heap_block:Core_kernel_heap_block_is_heap_block,
     core_kernel_gc_top_heap_words:core_kernel_gc_top_heap_words,
     core_kernel_gc_promoted_words:core_kernel_gc_promoted_words,
     core_kernel_gc_minor_words:core_kernel_gc_minor_words,
     core_kernel_gc_minor_collections:core_kernel_gc_minor_collections,
     core_kernel_gc_major_words:core_kernel_gc_major_words,
     core_kernel_gc_major_plus_minor_words:
     core_kernel_gc_major_plus_minor_words,
     core_kernel_gc_major_collections:core_kernel_gc_major_collections,
     core_kernel_gc_heap_words:core_kernel_gc_heap_words,
     core_kernel_gc_heap_chunks:core_kernel_gc_heap_chunks,
     core_kernel_gc_compactions:core_kernel_gc_compactions,
     core_kernel_time_ns_format:core_kernel_time_ns_format,
     core_array_unsafe_float_blit:core_array_unsafe_float_blit,
     core_array_unsafe_int_blit:core_array_unsafe_int_blit,
     bigstring_find:bigstring_find,
     internalhash_fold_bigstring:internalhash_fold_bigstring,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_memset_stub:bigstring_memset_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     bigstring_is_mmapped_stub:bigstring_is_mmapped_stub,
     bigstring_alloc:bigstring_alloc,
     caml_out_channel_pos_fd:caml_out_channel_pos_fd,
     expect_test_collector_after_test:expect_test_collector_after_test,
     expect_test_collector_before_test:expect_test_collector_before_test,
     expect_test_collector_saved_stderr:expect_test_collector_saved_stderr,
     expect_test_collector_saved_stdout:expect_test_collector_saved_stdout,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     bin_prot_blit_buf_stub:bin_prot_blit_buf_stub,
     bin_prot_blit_bytes_buf_stub:bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_string_buf_stub:bin_prot_blit_string_buf_stub,
     bin_prot_blit_float_array_buf_stub:bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_buf_bytes_stub:bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_buf_float_array_stub:bin_prot_blit_buf_float_array_stub,
     Base_am_testing:Base_am_testing,
     Base_hash_double:Base_hash_double,
     Base_hash_string:Base_hash_string,
     Base_int_math_int64_pow_stub:Base_int_math_int64_pow_stub,
     Base_int_math_int_pow_stub:Base_int_math_int_pow_stub,
     Base_int_math_int64_clz:Base_int_math_int64_clz,
     Base_int_math_nativeint_clz:Base_int_math_nativeint_clz,
     Base_int_math_int_clz:Base_int_math_int_clz,
     Base_int_math_int32_clz:Base_int_math_int32_clz,
     Base_clear_caml_backtrace_pos:Base_clear_caml_backtrace_pos,
     Base_int_math_int_popcount:Base_int_math_int_popcount,
     Base_internalhash_get_hash_value:Base_internalhash_get_hash_value,
     Base_internalhash_fold_string:Base_internalhash_fold_string,
     Base_internalhash_fold_float:Base_internalhash_fold_float,
     Base_internalhash_fold_int:Base_internalhash_fold_int,
     Base_internalhash_fold_int64:Base_internalhash_fold_int64,
     caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzbmFya3lfanNfbm9kZS5iYy5ydW50aW1lLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIkRlZmF1bHRMb2NhbGUiLCJkZWZhdWx0U3RyZnRpbWUiLCJTdHJmdGltZSIsImlzQ29tbW9uSlMiLCJtb2R1bGUiLCJuYW1lc3BhY2UiLCJhZGFwdGVkU3RyZnRpbWUiLCJkZXByZWNhdGVkU3RyZnRpbWUiLCJqb29fZ2xvYmFsX29iamVjdCIsInRoaXMiLCJldmFsIiwiX3JlcXVpcmUiLCJfZGVwcmVjYXRpb25XYXJuaW5ncyIsImRlcHJlY2F0aW9uV2FybmluZyIsIm5hbWUiLCJpbnN0ZWFkIiwiY29uc29sZSIsImRlcHJlY2F0ZWRTdHJmdGltZVRaIiwiZGVwcmVjYXRlZFN0cmZ0aW1lVVRDIiwiZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkIiwiYWRhcHRGb3J3YXJkcyIsImZuIiwiZm10IiwiZCIsImxvY2FsZSIsInVuZGVmaW5lZCIsInN0cmZ0aW1lIiwidGltZXpvbmUiLCJudWxsIiwidXRjU3RyZnRpbWUiLCJEYXRlIiwiY3VzdG9tVGltZXpvbmVPZmZzZXQiLCJ1c2VVdGNUaW1lem9uZSIsIl9sb2NhbGUiLCJfY3VzdG9tVGltZXpvbmVPZmZzZXQiLCJfdXNlVXRjQmFzZWREYXRlIiwiX2NhY2hlZERhdGVUaW1lc3RhbXAiLCJfY2FjaGVkRGF0ZSIsIl9zdHJmdGltZSIsImZvcm1hdCIsImRhdGUiLCJ0aW1lc3RhbXAiLCJjdXJyZW50VGltZXN0YW1wIiwiZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IiLCJfcHJvY2Vzc0Zvcm1hdCIsInJlc3VsdFN0cmluZyIsInBhZGRpbmciLCJpc0luU2NvcGUiLCJsZW5ndGgiLCJleHRlbmRlZFRaIiwiaSIsImN1cnJlbnRDaGFyQ29kZSIsInBhZFRpbGwyIiwiTWF0aCIsImhvdXJzMTIiLCJwYWRUaWxsMyIsIndlZWtOdW1iZXIiLCJ0elN0cmluZyIsInkiLCJkYXkiLCJTdHJpbmciLCJvcmRpbmFsIiwib2ZmIiwic2lnbiIsInNlcCIsImhvdXJzIiwibWlucyIsInVzZVV0Y0Jhc2VkRGF0ZSIsInRpbWV6b25lVHlwZSIsInBhcnNlSW50IiwibWludXRlcyIsIm51bWJlclRvUGFkIiwicGFkZGluZ0NoYXIiLCJob3VyIiwiZmlyc3RXZWVrZGF5Iiwid2Vla2RheSIsImZpcnN0RGF5T2ZZZWFyVXRjIiwiZGF0ZVV0YyIsInlkYXkiLCJ3ZWVrTnVtIiwibnVtYmVyIiwiaWkiLCJ3b3JrZXJfdGhyZWFkcyIsInJlcXVpcmUiLCJfd29ya2VycyIsImNhbWxfanNfZXhwb3J0X3ZhciIsInN0YXJ0V29ya2VycyIsInNuYXJreV9yZWFkeV9yZXNvbHZlIiwicmVzb2x2ZSIsIndvcmtlcl9zb3VyY2UiLCJtZW1vcnkiLCJidWlsZGVyIiwiQXJyYXkiLCJ3b3JrZXIiLCJ0YXJnZXQiLCJ0eXBlIiwiZG9uZSIsImRhdGEiLCJfZSIsIndhc21fcmVhZHkiLCJ3YXNtIiwicGxvbmtfd2FzbSIsImVudiIsIl9fZmlsZW5hbWUiLCJydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSIsInB0IiwiaW5maW5pdHkiLCJ4IiwianNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yIiwidiIsImtsYXNzIiwibGVuIiwicmVzIiwicG9zIiwiY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvciIsImNvbnZlcnQiLCJzaG91bGRfZnJlZSIsInJ1c3RfdmFsIiwiY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW0iLCJwb2x5X2NvbW0iLCJydXN0X3NoaWZ0ZWQiLCJydXN0X3Vuc2hpZnRlZCIsImNhbWxfc2hpZnRlZCIsImNhbWxfdW5zaGlmdGVkIiwiY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCIsImNhbWxfZXhwbTFfZmxvYXQiLCJ6IiwiY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QiLCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZyIsInMiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJjb21wIiwibmNvbXAiLCJjYW1sX3N0cl9yZXBlYXQiLCJuIiwiciIsImwiLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiZiIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYiIsInQiLCJjIiwiYzEiLCJjMiIsImoiLCJNbEJ5dGVzIiwidGFnIiwiY29udGVudHMiLCJjb250ZW50IiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9qc2J5dGVzIiwiY2FtbF9zdHJpbmdfb2ZfanNieXRlcyIsImNhbWxfdXRmOF9vZl91dGYxNiIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJhcmciLCJjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIiwibXNnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9qc2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlIiwiY2FtbF9pbnZhbGlkX2FyZ3VtZW50IiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX2dldCIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY29udmVydF9ieXRlc190b19hcnJheSIsImNhbWxfYmxpdF9ieXRlcyIsInMxIiwiaTEiLCJzMiIsImkyIiwiY2FtbF9ibGl0X3N0cmluZyIsImUiLCJNbEZpbGUiLCJNbEZha2VGaWxlIiwib2xkIiwib2Zmc2V0IiwiYnVmIiwiY2xlbiIsIm5ld19zdHIiLCJvbGRfZGF0YSIsIk1sRmFrZURldmljZSIsInJvb3QiLCJuYW1lX3NsYXNoIiwiUmVnRXhwIiwic2VlbiIsIm0iLCJvayIsImZpbGUiLCJieXRlcyIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX2FycmF5X29mX3N0cmluZyIsImNhbWxfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsIk1sTm9kZUZpbGUiLCJmZCIsImVyciIsImJ1Zl9vZmZzZXQiLCJidWZmZXIiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJvIiwiY2FtbF9yb290IiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJqc29vX21vdW50X3BvaW50IiwicmVzb2x2ZV9mc19kZXZpY2UiLCJwYXRoIiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnkiLCJpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZSIsImZyZWVfb25fZmluYWxpemUiLCJjYW1sX3Bsb25rX2RvbWFpbl90b19ydXN0IiwicnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUiLCJqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IiLCJjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yIiwibWtfbmV3IiwiY2xhc3NfdmFsIiwiY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0iLCJwb2x5X2NvbW1fY2xhc3MiLCJta19hZmZpbmUiLCJjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc190b19ydXN0IiwiY29udmVydEFycmF5IiwiY29tbXMiLCJzaWdtYV9jb21tIiwiY29lZmZpY2llbnRzX2NvbW0iLCJnZW5lcmljX2NvbW0iLCJwc21fY29tbSIsImNvbXBsZXRlX2FkZF9jb21tIiwibXVsX2NvbW0iLCJlbXVsX2NvbW0iLCJlbmRvbXVsX3NjYWxhcl9jb21tIiwiY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX3RvX3J1c3QiLCJjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QiLCJkb21haW5fY2xhc3MiLCJ2ZXJpZmljYXRpb25fZXZhbHNfY2xhc3MiLCJ2ZXJpZmljYXRpb25fc2hpZnRzX2NsYXNzIiwiZG9tYWluIiwibWF4X3BvbHlfc2l6ZSIsIm1heF9xdW90X3NpemUiLCJzcnMiLCJldmFscyIsInNoaWZ0cyIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9pbnQ2NF9vZmZzZXQiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsImgiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwicSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X25lZyIsImludGVnZXJzX3VpbnRfb2Zfc3RyaW5nIiwibWF4X3ZhbCIsIm5lZ2F0aXZlIiwibm9fZGlnaXRzIiwidGVuIiwibWF4X2Jhc2VfMTAiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiVUludDMyIiwiaW50ZWdlcnNfdWludDMyX29mX2ludDY0IiwiaW50ZWdlcnNfdWludDMyX29mX3N0cmluZyIsImNhbWxfbG9nMTBfZmxvYXQiLCJjYW1sX3Bhc3RhX2ZxX2NvcHkiLCJjYW1sX3Bhc3RhX2ZxX3N1YiIsImNhbWxfcGFzdGFfZnFfbXV0X3N1YiIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJjb2x1bW5fb2ZfcnVzdCIsImNvbCIsImdhdGVfdHlwZSIsInZhcmlhYmxlX29mX3J1c3QiLCJ2YXJpYWJsZSIsInJvdyIsInBvbGlzaF90b2tlbl9vZl9ydXN0IiwidG9rZW4iLCJpMCIsInB0ciIsIm9iaiIsIk9iamVjdCIsImluZGV4X3Rlcm1fb2ZfcnVzdCIsInRlcm0iLCJ0b2tlbl9jbGFzcyIsImNvbHVtbiIsImNvZWZmaWNpZW50IiwibGluZWFyaXphdGlvbl9vZl9ydXN0IiwibGluZWFyaXphdGlvbiIsImFmZmluZV9jbGFzcyIsIkYiLCJXYXNtUG9saXNoVG9rZW4iLCJXYXNtSW5kZXhUZXJtIiwiY29uc3RhbnRfdGVybSIsImluZGV4X3Rlcm1zIiwid2FzbUluZGV4VGVybSIsImNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QiLCJsb2dfc2l6ZV9vZl9ncm91cCIsImdyb3VwX2dlbiIsImNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3QiLCJhZmZpbmVfa2xhc3MiLCJjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdCIsIk5vbmUiLCJjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QiLCJsb29rdXBfaW5kZXgiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSIsImNhbWxfcGFzdGFfZnFfcHJpbnQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiYSIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJpbnRlZ2Vyc191bG9uZ2xvbmdfc2l6ZSIsInVuaXQiLCJjYW1sX2JhX2dldF8xIiwiYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIiLCJ2X2JzdHIiLCJ2X3NyY19wb3MiLCJ2X3N0ciIsInZfZHN0X3BvcyIsInZfbGVuIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9jcmVhdGUiLCJnYXRlcyIsInB1YmxpY19pbnB1dHMiLCJ1cnMiLCJ1bml4X2dldHRpbWVvZmRheSIsImNhbWxfdmVzdGFfZW5kb19iYXNlIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsImNhbWxfY2FsbF9nZW4iLCJhcmdzIiwiYXJnc0xlbiIsImV4dHJhX2FyZ3MiLCJhcmd1bWVudHMiLCJuYXJncyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZSIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsIndyaXRlciIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwiaW0iLCJyZSIsInRvdGFsIiwiazEiLCJrMiIsIk1sX0JpZ2FycmF5X2NfMV8xIiwiY2FtbF9iYV9jcmVhdGVfdW5zYWZlIiwic2l6ZV9wZXJfZWxlbWVudCIsImNhbWxfYmFfZGVzZXJpYWxpemUiLCJyZWFkZXIiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2NvbXBhcmUiLCJjYW1sX2hhc2hfbWl4X2ludDY0IiwiY2FtbF9oYXNoX21peF9mbG9hdCIsInYwIiwiY2FtbF9iYV9oYXNoIiwibnVtX2VsdHMiLCJ3IiwiY2FtbF9pbnQzMl91bm1hcnNoYWwiLCJjYW1sX25hdGl2ZWludF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X3VubWFyc2hhbCIsImNhbWxfaW50NjRfbWFyc2hhbCIsInNpemVzIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9oYXNoIiwiY2FtbF9jdXN0b21fb3BzIiwiY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tIiwiY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tIiwibnVtIiwiY3VzdG9tIiwic3dhcCIsImNhbWxfY29tcGFyZV92YWxfdGFnIiwiTnVtYmVyIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NvbXBhcmVfdmFsIiwic3RhY2siLCJ0YWdfYSIsInRhZ19iIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5Iiwic3RyIiwidGVtcCIsImRvY3VtZW50IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfcGFzdGFfZnFfZG9tYWluX2dlbmVyYXRvciIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJzZXJpYWxpemVfbmF0IiwiY2FtbF9tZW1wcm9mX3NldCIsIl9jb250cm9sIiwiY2FtbF9mcV9zcnNfaCIsImNhbWxfcGFsbGFzX25lZ2F0ZSIsImNhbWxfc3lzX2V4aXQiLCJjb2RlIiwiY2FtbF9tbF9jaGFubmVscyIsImNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yIiwiY2hhbmlkIiwiY2hhbiIsImNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0Iiwid2lyZSIsImNhbWxfcGxvbmtfd2lyZXNfb2ZfcnVzdCIsIndpcmVzIiwiY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yIiwiaW5uZXJfbGVuIiwib3V0cHV0X2xlbiIsImlubmVyX3JlcyIsImNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0IiwiZ2F0ZSIsImNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0IiwiY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yIiwiY2FtbF9vcHRpb25fdG9fbWF5YmVfdW5kZWZpbmVkIiwiY2FtbF9yYW5kb21fb3JhY2xlc190b19ydXN0Iiwicm9LbGFzcyIsImpvaW50X2NvbWJpbmVyX29jYW1sIiwiam9pbnRfY29tYmluZXJfY2hhbCIsImpvaW50X2NvbWJpbmVyIiwiVUludDY0IiwiaW50ZWdlcnNfdWludDY0X29mX3N0cmluZyIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9mcF9zcnNfaCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlIiwidmsiLCJ2a19jYW1sIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfcGFzdGFfZnFfZGVlcF9jb3B5IiwiYmlnc3RyaW5nX2lzX21tYXBwZWRfc3R1YiIsImNhbWxfYXJyYXlfc2V0IiwiYXJyYXkiLCJpbmRleCIsIm5ld3ZhbCIsImJpbl9wcm90X2JsaXRfYnVmX2Zsb2F0X2FycmF5X3N0dWIiLCJ2X2J1ZiIsInZfYXJyIiwiY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZSIsImFwcGVuZCIsImNhbWxfcGFsbGFzX3JhbmRvbSIsImNhbWxfcGFzdGFfZnBfdG9fYmlnaW50IiwiY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCIsImNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfdG9fcnVzdCIsIndfY29tbSIsInpfY29tbSIsInRfY29tbSIsImNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl90b19ydXN0IiwiY29udmVydF9hZmZpbmVzIiwiYWZmaW5lcyIsImxyIiwiZGVsdGEiLCJ6MSIsInoyIiwic2ciLCJsX29jYW1sIiwicl9vY2FtbCIsImNhbWxfZnBfdmVjdG9yX3RvX3J1c3QiLCJQRVJNVVRTX01JTlVTXzEiLCJDT0xVTU5TIiwiY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0IiwiZ2VuZXJpY19zZWxlY3RvciIsInBvc2VpZG9uX3NlbGVjdG9yIiwiY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0IiwiY29tbWl0bWVudHMiLCJwcm9vZiIsImV2YWxzMCIsImV2YWxzMSIsImZ0X2V2YWwxIiwicHVibGljXyIsInByZXZfY2hhbGxlbmdlcyIsImNoYWxzX2xlbiIsInByZXZfY2hhbGxlbmdlc19zY2FsYXJzIiwicHJldl9jaGFsbGVuZ2VzX2NvbW1zIiwiY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0IiwiY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX29mX3J1c3QiLCJFcnJvciIsInR1cGxlIiwiY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdCIsIm1lc3NhZ2VzIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9kZWVwX2NvcHkiLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXkiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiYmlnSW50IiwiQkFTRSIsIkxPR19CQVNFIiwiTUFYX0lOVCIsIk1BWF9JTlRfQVJSIiwic21hbGxUb0FycmF5IiwiREVGQVVMVF9BTFBIQUJFVCIsIkJpZ0ludCIsInN1cHBvcnRzTmF0aXZlQmlnSW50IiwiSW50ZWdlciIsInJhZGl4IiwiYWxwaGFiZXQiLCJjYXNlU2Vuc2l0aXZlIiwicGFyc2VWYWx1ZSIsInBhcnNlQmFzZSIsIkJpZ0ludGVnZXIiLCJ2YWx1ZSIsIlNtYWxsSW50ZWdlciIsIk5hdGl2ZUJpZ0ludCIsImlzUHJlY2lzZSIsImFycmF5VG9TbWFsbCIsImFyciIsInRyaW0iLCJjb21wYXJlQWJzIiwiY3JlYXRlQXJyYXkiLCJ0cnVuY2F0ZSIsImFkZCIsImxfYSIsImxfYiIsImNhcnJ5IiwiYmFzZSIsInN1bSIsImFkZEFueSIsImFkZFNtYWxsIiwic3VidHJhY3QiLCJhX2wiLCJiX2wiLCJib3Jyb3ciLCJkaWZmZXJlbmNlIiwic3VidHJhY3RBbnkiLCJzdWJ0cmFjdFNtYWxsIiwic21hbGwiLCJtdWx0aXBseUxvbmciLCJwcm9kdWN0IiwiYV9pIiwiYl9qIiwibXVsdGlwbHlTbWFsbCIsInNoaWZ0TGVmdCIsIm11bHRpcGx5S2FyYXRzdWJhIiwiYWMiLCJiZCIsImFiY2QiLCJ1c2VLYXJhdHN1YmEiLCJsMSIsImwyIiwiYWJzIiwibXVsdGlwbHlTbWFsbEFuZEFycmF5Iiwic3F1YXJlIiwiYV9qIiwiZGl2TW9kMSIsInJlc3VsdCIsImRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCIsImxhbWJkYSIsInJlbWFpbmRlciIsInF1b3RpZW50RGlnaXQiLCJzaGlmdCIsImRpdk1vZFNtYWxsIiwiZGl2TW9kMiIsInBhcnQiLCJndWVzcyIsInhsZW4iLCJoaWdoeCIsImhpZ2h5IiwiY2hlY2siLCJkaXZNb2RBbnkiLCJzZWxmIiwiY29tcGFyaXNvbiIsInFTaWduIiwibW9kIiwibVNpZ24iLCJfMCIsIl8xIiwiXzIiLCJpc0Jhc2ljUHJpbWUiLCJtaWxsZXJSYWJpblRlc3QiLCJuUHJldiIsInN0cmljdCIsImlzUHJpbWUiLCJiaXRzIiwibG9nTiIsIml0ZXJhdGlvbnMiLCJuZXdUIiwibmV3UiIsImxhc3RUIiwibGFzdFIiLCJwb3dlcnNPZlR3byIsInBvd2VyczJMZW5ndGgiLCJoaWdoZXN0UG93ZXIyIiwic2hpZnRfaXNTbWFsbCIsInJlbVF1byIsImJpdHdpc2UiLCJ4U2lnbiIsInlTaWduIiwieFJlbSIsInlSZW0iLCJ4RGlnaXQiLCJ5RGlnaXQiLCJ4RGl2TW9kIiwieURpdk1vZCIsIkxPQk1BU0tfSSIsIkxPQk1BU0tfQkkiLCJyb3VnaExPQiIsImludGVnZXJMb2dhcml0aG0iLCJ0bXAiLCJwIiwibWF4IiwibWluIiwiZ2NkIiwibGNtIiwicmFuZEJldHdlZW4iLCJsb3ciLCJoaWdoIiwicmFuZ2UiLCJkaWdpdHMiLCJ0b0Jhc2UiLCJyZXN0cmljdGVkIiwidG9wIiwiZGlnaXQiLCJ0ZXh0IiwiYWJzQmFzZSIsImFscGhhYmV0VmFsdWVzIiwiaXNOZWdhdGl2ZSIsInN0YXJ0IiwicGFyc2VCYXNlRnJvbUFycmF5IiwidmFsIiwicG93Iiwic3RyaW5naWZ5IiwibmVnIiwib3V0IiwibGVmdCIsImRpdm1vZCIsInRvQmFzZVN0cmluZyIsInplcm9zIiwicGFyc2VTdHJpbmdWYWx1ZSIsInNwbGl0IiwiZGVjaW1hbFBsYWNlIiwiaXNWYWxpZCIsInBhcnNlTnVtYmVyVmFsdWUiLCJtbF96X25vcm1hbGl6ZSIsIm1sX3pfc2hpZnRfcmlnaHQiLCJhbXQiLCJjYW1sX29ial9ibG9jayIsImJpZ3N0cmluZ190b19hcnJheV9idWZmZXIiLCJicyIsImludGVnZXJzX3VpbnQzMl9jb21wYXJlIiwiY2FtbF9wYXN0YV9mcF9jb3B5IiwiY2FtbF9wYXN0YV9mcF9zcXVhcmUiLCJjYW1sX3Bhc3RhX2ZwX211dF9zcXVhcmUiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2pzX3RvX2FycmF5IiwiY2FtbF9ncl9wbG90IiwiY29sb3IiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfc3RyaW5nX3NldDE2IiwiY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl92ZXJpZnkiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJtbF96X3NoaWZ0X2xlZnQiLCJkZWNyX25hdCIsImNhcnJ5X2luIiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9wYXN0YV9mcV9pc19zcXVhcmUiLCJjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWQiLCJjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3QiLCJjYW1sX29yYWNsZXNfb2ZfcnVzdCIsImNhbWxfaGFzaF9taXhfZmluYWwiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY2FtbF9wbG9ua193aXJlX3RvX3J1c3QiLCJjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QiLCJjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkIiwiY29yZV9rZXJuZWxfZ2NfbWlub3Jfd29yZHMiLCJjYW1sX2FyZ3YiLCJtYWluIiwiYXJndiIsImFyZ3MyIiwiY2FtbF9leGVjdXRhYmxlX25hbWUiLCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWUiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfZnBfdmVjdG9yX2dldCIsImludGVnZXJzX3VpbnQzMl90b19pbnQiLCJjYW1sX2hhc2hfbWl4X2pzYnl0ZXMiLCJjYW1sX2hhc2hfbWl4X3N0cmluZyIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfaGFzaCIsImNvdW50IiwibGltaXQiLCJzZWVkIiwicXVldWUiLCJyZCIsIndyIiwiaGgiLCJCYXNlX2hhc2hfc3RyaW5nIiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImpzX3ByaW50X3N0ZG91dCIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpZHgiLCJvdXRwdXQiLCJmbGFncyIsImluZm8iLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJjaGFubmVsIiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX21kNV9ieXRlcyIsInh4IiwiZmYiLCJnZyIsIm1kNSIsImNhbWxfbWQ1X3N0cmluZyIsImNhbWxfbWQ1X2NoYW4iLCJjaGFuX2xlbiIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9mbHVzaCIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNvcmVfbWQ1X2ZkIiwiaWMiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfdG9fanNfc3RyaW5nIiwianNvb196X29mX2pzX3N0cmluZ19iYXNlIiwiYmMiLCJtbF96X29mX3N1YnN0cmluZ19iYXNlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDhfc2l6ZSIsImNhbWxfYnl0ZXNfdG9fdWludDhhcnJheSIsIm9jYW1sX2J5dGVzIiwiY2FtbF9wYXN0YV9mcV9vZl9ieXRlcyIsIndpbl9jbGVhbnVwIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwidW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZSIsIm1sX3pfZ2NkZXh0X2ludGVybiIsImxhc3R4IiwibGFzdHkiLCJpbnRlZ2Vyc191aW50OF9kZXNlcmlhbGl6ZSIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX21sX3NlZWtfaW5fNjQiLCJjYW1sX25vdGVxdWFsIiwiaW50ZWdlcnNfdWludDMyX21heCIsIm1sX3pfYWJzIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2lzX2pzIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdCIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2ludDY0X29yIiwiaW50ZWdlcnNfdWludDY0X2xvZ29yIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImJpZ3N0cmluZ19kZXN0cm95X3N0dWIiLCJkZXN0cm95ZWRfZGF0YSIsImRlc3Ryb3llZF9iaWdzdHJpbmciLCJiaWdzdHJpbmdfcmVhbGxvYyIsImJpZ3N0cmluZyIsIm5ld19kYXRhIiwibmV3X2JpZ3N0cmluZyIsImNhbWxfdHJhbXBvbGluZSIsImludGVnZXJzX3VpbnQzMl9vZl9pbnQzMiIsImNhbWxfZnBfc3JzX3dyaXRlIiwibWxfel9yZW0iLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImRlZmVycmVkX2lzX2RldGVybWluZWQiLCJkZWZlcnJlZCIsImNhbWxfdmVzdGFfb2ZfYWZmaW5lIiwiaW50ZWdlcnNfdWludDY0X2RpdiIsImNhbWxfanNfY2FsbCIsImNhbWxfc3lzX2NvbnN0X21heF93b3NpemUiLCJjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCIsImNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl90b19ydXN0IiwiY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfdmVyaWZ5IiwiaW50ZWdlcnNfdWludDMyX2xvZ3hvciIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJkZWZlcnJlZF9jcmVhdGUiLCJwcm9taXNlX2NyZWF0b3IiLCJQcm9taXNlIiwiQmFzZV9hbV90ZXN0aW5nIiwiY2FtbF9ncl9maWxsX3BvbHkiLCJhciIsImNhbWxfZ2NfcXVpY2tfc3RhdCIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzIiwibnRoX2RpZ2l0X25hdCIsImNhbWxfYXJyYXlfYmxpdCIsImExIiwiYTIiLCJjYW1sX3BhbGxhc19hZmZpbmVfZGVlcF9jb3B5IiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZyIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwiaW50ZXJuX29ial90YWJsZSIsIm1lbW8iLCJleGlzdGluZ19vZmZzZXQiLCJleHRlcm5fcmVjIiwib3BzIiwic3pfMzJfNjQiLCJoZWFkZXJfcG9zIiwib2xkX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwidW5peF9pc2F0dHkiLCJmaWxlRGVzY3JpcHRvciIsInR0eSIsIk1sTmF0IiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJjYW1sX3Zlc3RhX3RvX2FmZmluZSIsImJpZ3N0cmluZ19tZW1jbXBfc3R1YiIsInZfczEiLCJ2X3MxX3BvcyIsInZfczIiLCJ2X3MyX3BvcyIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJpbnRlZ2Vyc191aW50MzJfYWRkIiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfcGFsbGFzX2RvdWJsZSIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF92ZXN0YV9hZGQiLCJjYW1sX2JpZ2ludF8yNTZfdGVzdF9iaXQiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9wYXN0YV9mcV9jb21wYXJlIiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImludGVnZXJzX3VpbnQzMl90b19pbnQ2NCIsImludGVnZXJzX3VpbnQzMl9tdWwiLCJ4XzY0IiwieV82NCIsImNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl9vZl9ydXN0IiwiY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlIiwid2l0bmVzc19jb2xzIiwicHJldl9zZ3MiLCJjYW1sX2ludDY0X2lzX3plcm8iLCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIiwiZXhwb25lbnQiLCJvbmUiLCJtdWwiLCJjYW1sX3N5c19jb25zdF93b3JkX3NpemUiLCJpbnRlZ2Vyc191aW50NjRfdG9faW50NjQiLCJtbF96X3BvcGNvdW50IiwiemVybyIsIm1sX3pfaGFtZGlzdCIsIm1sX3pfbXVsIiwibWxfel9wb3ciLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJiaWdzdHJpbmdfYWxsb2MiLCJfIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiZGVmZXJyZWRfcGVlayIsIm1sX3pfbG9nYW5kIiwiY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXMiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY19zdHIiLCJjYW1sX2dyX21vdmV0byIsImNhbWxfZ3JfcmVzaXplX3dpbmRvdyIsImNhbWxfZ3Jfc3RhdGVfaW5pdCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsInRhIiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfanNfdHlwZW9mIiwiZGVmZXJyZWRfdG9fcHJvbWlzZSIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnIiLCJleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0IiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2FmdGVyX3Rlc3QiLCJ2c3Rkb3V0IiwidnN0ZGVyciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfb2JqX21ha2VfZm9yd2FyZCIsImNyZWF0ZV9uYXQiLCJtbF96X2ZpdHNfaW50IiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX2JpZ2ludF8yNTZfb2ZfZGVjaW1hbF9zdHJpbmciLCJCYXNlX2ludF9tYXRoX2ludDMyX2NseiIsIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NseiIsImNhbWxfcGFzdGFfZnBfYWRkIiwiY2FtbF9qc190b19zdHJpbmciLCJjb3JlX2tlcm5lbF90aW1lX25zX2Zvcm1hdCIsInRpbWUiLCJmb3JtYXRqcyIsImpzdHJpbmciLCJjYW1sX29ial9kdXAiLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiaW50ZWdlcnNfdWludDE2X2Rlc2VyaWFsaXplIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmciLCJpbmNyX25hdCIsIm1sX3pfc2lnbiIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwiY2FtbF9mcF9zcnNfYl9wb2x5X2NvbW1pdG1lbnQiLCJjaGFscyIsIm1sX3pfbmV4dHByaW1lIiwidHdvIiwiY2FtbF9qc19leHByIiwiY2FtbF9wYXN0YV9mcV9lcXVhbCIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiX3VuaXQiLCJmcV9vcmFjbGVzX2NyZWF0ZSIsImxncl9jb21tIiwidmVyaWZpZXJfaW5kZXgiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemUiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImhhc2hfYWNjdSIsImhhc2hfYXV4IiwianNieXRlcyIsImNhbWxfdmVzdGFfbmVnYXRlIiwibWxfel9kaXYiLCJtbF96X2RpdmV4YWN0IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwiY2FtbF92ZXN0YV9ybmciLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQiLCJjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWxfb3V0cHV0X2NoYXIiLCJjYW1sX29ial9pc19ibG9jayIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2ZxX3Nyc19yZWFkIiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImNhbWxfcGFzdGFfZnBfbXV0X2FkZCIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX3phcml0aF9tYXJzaGFsIiwiYmxvY2siLCJjYW1sX2ZwX3ZlY3Rvcl9lbXBsYWNlX2JhY2siLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0IiwiY2FtbF92ZXN0YV9lbmRvX3NjYWxhciIsImNhbWxfZXF1YWwiLCJjYW1sX21sX3JlZmlsbF9pbnB1dCIsInN0cl9sZW4iLCJjb21wYXJlX25hdCIsImxlbjIiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfaW50X29mX3N0cmluZyIsInRocmVzaG9sZCIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudCIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX2pzX2VxdWFscyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJfbWFnaWMiLCJfYmxvY2tfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0Iiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwiaGVhZGVyIiwiZXhwZWN0ZWRfc2l6ZSIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImludGVnZXJzX3VpbnQxNl9vZl9zdHJpbmciLCJtbF96X2ZpdHNfbmF0aXZlaW50IiwiY2FtbF9ncl9hcmNfYXV4IiwiY3R4IiwiY3giLCJjeSIsInJ5IiwicngiLCJyb3QiLCJ4UG9zIiwieVBvcyIsInhQb3NfcHJldiIsInlQb3NfcHJldiIsInNwYWNlIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfaW50NjRfeG9yIiwiaW50ZWdlcnNfdWludDY0X2xvZ3hvciIsImludGVnZXJzX3VpbnQzMl9vZl9pbnQiLCJjYW1sX3BhbGxhc19vZl9hZmZpbmUiLCJjYW1sX3Bhc3RhX2ZwX2NvbXBhcmUiLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiZ2V0MzIiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX291dF9jaGFubmVsX3Bvc19mZCIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwiY2FtbF9uZXdfc3RyaW5nIiwiaW50ZWdlcnNfdWludDY0X3RvX3N0cmluZyIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJpbnRlZ2Vyc191aW50MzJfc2VyaWFsaXplIiwiY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9wYXJhbXNfY3JlYXRlIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3Bhc3RhX2ZxX3NxcnQiLCJ1bml4X3RpbWUiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwibWxfel9oYXNoIiwiYWNjIiwiaW50ZWdlcnNfdWludDY0X2xvZ2FuZCIsInJlX3N0cmluZ19tYXRjaCIsIkJpZ1N0cmluZ1JlYWRlciIsImNhbWxfYmFfZ2V0X2dlbmVyaWMiLCJjYW1sX2ZxX3ZlY3Rvcl9lbXBsYWNlX2JhY2siLCJCYXNlX2ludF9tYXRoX2ludF9jbHoiLCJjYW1sX3Bhc3RhX2ZwX29mX2JpZ2ludCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEiLCJiYTEiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyIsIm1sX3pfcm9vdCIsImVuZCIsImFucyIsIm1pZCIsInBvIiwibWxfel9zcXJ0X3JlbSIsImRpZmYiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfbWVtcHJvZl9zdGFydCIsInJhdGUiLCJzdGFja19zaXplIiwidHJhY2tlciIsImNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJhZGRfbmF0IiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJ4MyIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2djX3N0YXQiLCJjYW1sX3Bhc3RhX2ZxX2FkZCIsImNhbWxfc3lzX21vZGlmeV9hcmd2IiwiY2FtbF9tZXRob2RfY2FjaGUiLCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kIiwiY2FjaGVpZCIsIm1ldGhzIiwibGkiLCJjYW1sX3Zlc3RhX2FmZmluZV9kZWVwX2NvcHkiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YiIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsIm1sX3pfb2ZfYml0cyIsImJhc2UxIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zaW5oX2Zsb2F0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9yZWFkIiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfemFyaXRoX3VubWFyc2hhbCIsIm5lZ2F0ZSIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwiY2FtbF9ieXRlc19sZXNzdGhhbiIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9wYXN0YV9mcV9vZl9pbnQiLCJjYW1sX29ial9zZXRfdGFnIiwiaW50ZWdlcnNfdWludDhfb2Zfc3RyaW5nIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfaW50NjRfb2ZfZmxvYXQiLCJpbnRlZ2Vyc191aW50MzJfc3ViIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJ5dGVzMiIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUiLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJpbnRlZ2Vyc191aW50MzJfZGl2IiwiY2FtbF9ncl9kcmF3X2FyYyIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsImZwX29yYWNsZXNfY3JlYXRlIiwiY2FtbF9mcV92ZWN0b3JfZ2V0IiwiY2FtbF9iYV9zZXRfMSIsImJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YiIsImNhbWxfZ3JfZHJhd19zdHIiLCJkeCIsImNhbWxfZ3JfZHJhd19zdHJpbmciLCJjYW1sX2ZwX3ZlY3Rvcl9jcmVhdGUiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIiwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUiLCJfY2hhbm5lbCIsImNhbWxfcGFsbGFzX3RvX2FmZmluZSIsImNhbWxfZnFfc3JzX2NyZWF0ZSIsImNhbWxfbWxfcG9zX291dCIsImNvcmVfYXJyYXlfdW5zYWZlX2Zsb2F0X2JsaXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9qc19vYmplY3QiLCJpbnRlZ2Vyc191aW50NjRfbWFyc2hhbCIsImNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheSIsInVpbnQ4YXJyYXkiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdCIsImdhdGVfdmVjdG9yIiwiY29yZV9rZXJuZWxfZ2NfY29tcGFjdGlvbnMiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2Q0X3NpemUiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfd2Vha19ibGl0IiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3QiLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJub3ciLCJjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4iLCJmcF9vcmFjbGVzX2R1bW15IiwiQmFzZV9jbGVhcl9jYW1sX2JhY2t0cmFjZV9wb3MiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9iaWdpbnRfMjU2X2NvbXBhcmUiLCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9mcmV4cF9mbG9hdCIsIkNvcmVfa2VybmVsX2hlYXBfYmxvY2tfaXNfaGVhcF9ibG9jayIsImJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViIiwibWxfel9wcmVkIiwibWxfel9leHRyYWN0IiwibWxfel9sb2dub3QiLCJjYW1sX3Bhc3RhX2ZxX3JuZyIsImNhbWxfb3JhY2xlc190b19ydXN0IiwiZnBfb3JhY2xlc19kZWVwX2NvcHkiLCJjYW1sX3Bhc3RhX2ZwX2lzX3NxdWFyZSIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJuZXdfZGltcyIsImNvcmVfa2VybmVsX2djX3RvcF9oZWFwX3dvcmRzIiwiY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9wYXJhbXNfY3JlYXRlIiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfZnFfc3JzX2xhZ3JhbmdlX2NvbW1pdG1lbnQiLCJkb21haW5fc2l6ZSIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImdldCIsInNwZWNzIiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9wYWxsYXNfZW5kb19zY2FsYXIiLCJjYW1sX2VwaGVfc2V0X2RhdGEiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfYmlnaW50XzI1Nl9wcmludCIsImNhbWxfYmlnaW50XzI1Nl9vZl9udW1lcmFsIiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfcGFzdGFfZnFfc3F1YXJlIiwiY2FtbF9wYXN0YV9mcV9tdXRfc3F1YXJlIiwibWxfel9udW1iaXRzIiwidXBwZXJCb3VuZCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9sb2cxcF9mbG9hdCIsImNhbWxfcGFzdGFfZnFfcG9zZWlkb25fYmxvY2tfY2lwaGVyIiwiX2Zha2VfcGFyYW1zIiwiZnFfdmVjdG9yIiwid2FzbV9mbGF0X3ZlY3RvciIsIm5ld19mcV92ZWN0b3IiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImludGVnZXJzX3VpbnQ2NF9tdWwiLCJjYW1sX3VwZGF0ZV9kdW1teSIsImNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2QiLCJzaGFwZSIsInJlYWwiLCJtbF96X2luaXQiLCJjYW1sX2dyX2RvY19vZl9zdGF0ZSIsInN0YXRlIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9yZWFkIiwiY2FtbF9wYXN0YV9mcF9uZWdhdGUiLCJiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YiIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9wYXN0YV9mcF9zdWIiLCJjYW1sX3Bhc3RhX2ZwX211dF9zdWIiLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJpbnRlZ2Vyc191aW50NjRfdW5tYXJzaGFsIiwibWxfel9zaXplIiwibWxfel9maXRzX2ludDY0IiwibWxfel90b19pbnQ2NCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfbW9kZl9mbG9hdCIsImNhbWxfZ2NfZ2V0IiwiY2FtbF9mbG9hdF9jb21wYXJlIiwiY2FtbF9mcF9zcnNfY29tbWl0X2V2YWx1YXRpb25zIiwiZnBzIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJjbWQiLCJFUlJDT0RFIiwibG9vcCIsInRlc3RzaGlmdCIsInNoaWZ0X3JlY292ZXIiLCJyZWR1Y2UiLCJSRUFEX1RPS0VOIiwiUkFJU0VfUEFSU0VfRVJST1IiLCJHUk9XX1NUQUNLU18xIiwiR1JPV19TVEFDS1NfMiIsIkNPTVBVVEVfU0VNQU5USUNfQUNUSU9OIiwiQ0FMTF9FUlJPUl9GVU5DVElPTiIsImVudl9zX3N0YWNrIiwiZW52X3Zfc3RhY2siLCJlbnZfc3ltYl9zdGFydF9zdGFjayIsImVudl9zeW1iX2VuZF9zdGFjayIsImVudl9zdGFja3NpemUiLCJlbnZfc3RhY2tiYXNlIiwiZW52X2N1cnJfY2hhciIsImVudl9sdmFsIiwiZW52X3N5bWJfc3RhcnQiLCJlbnZfc3ltYl9lbmQiLCJlbnZfYXNwIiwiZW52X3J1bGVfbGVuIiwiZW52X3J1bGVfbnVtYmVyIiwiZW52X3NwIiwiZW52X3N0YXRlIiwiZW52X2VycmZsYWciLCJ0YmxfdHJhbnNsX2NvbnN0IiwidGJsX3RyYW5zbF9ibG9jayIsInRibF9saHMiLCJ0YmxfbGVuIiwidGJsX2RlZnJlZCIsInRibF9kZ290byIsInRibF9zaW5kZXgiLCJ0YmxfcmluZGV4IiwidGJsX2dpbmRleCIsInRibF90YWJsZXNpemUiLCJ0YmxfdGFibGUiLCJ0YmxfY2hlY2siLCJuMSIsIm4yIiwic3RhdGUxIiwic3AiLCJlcnJmbGFnIiwiYXNwIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9jcmVhdGUiLCJjYW1sX3Bhc3RhX2ZxX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHkiLCJjYW1sX3Zlc3RhX3NjYWxlIiwibWxfel9pbnN0YWxsX2ZyYW1ldGFibGUiLCJiaWdzdHJpbmdfYmxpdF9zdHViIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX3Bhc3RhX2ZwX3NxcnQiLCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiY2FtbF9wYXN0YV9mcF9ybmciLCJjYW1sX3Bhc3RhX2ZwX3RvX3N0cmluZyIsImNhbWxfZ3JfcG9pbnRfY29sb3IiLCJkZWZlcnJlZF9vZl9wcm9taXNlIiwicHJvbWlzZSIsImNhbWxfc3lzX3JlbmFtZSIsIm9fcm9vdCIsIm5fcm9vdCIsImNhbWxfcGFzdGFfZnBfZXF1YWwiLCJpbnRlZ2Vyc191aW50MzJfZGVzZXJpYWxpemUiLCJjYW1sX2JpZ2ludF8yNTZfZGl2IiwiaW50ZWdlcnNfdWludDMyX3RvX3N0cmluZyIsImNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2FtbF9nY19taW5vciIsImNhbWxfdmVzdGFfc3ViIiwiY2FtbF9iYV9udW1fZGltcyIsImJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmciLCJiYTFfb2ZmIiwiYmEyX29mZiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmciLCJjYW1sX3N5c19jaGRpciIsImRpciIsImNhbWxfZnFfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrIiwicnVzdF9jb21tcyIsInJ1c3RfY2hhbHMiLCJjYW1sX3Bhc3RhX2ZwX2RlZXBfY29weSIsIm1sX3pfYWRkIiwibWxfel9jZGl2IiwiejFfcG9zIiwiejJfcG9zIiwiYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzIiwic3JjIiwic3JjX29mZiIsImRzdCIsImRzdF9vZmYiLCJjYW1sX2ZxX3Nyc19jb21taXRfZXZhbHVhdGlvbnMiLCJmcXMiLCJjYW1sX3Bhc3RhX2ZwX29mX2J5dGVzIiwiZGl2X2hlbHBlciIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJzZXRfdG9femVyb19uYXQiLCJzdWJfbmF0IiwiZGl2X25hdCIsInF1byIsImNhbWxfYmFfYmxpdCIsImlzX2RpZ2l0X2ludCIsImludGVnZXJzX3VpbnQzMl9oYXNoIiwiYmlnc3RyaW5nX2ZpbmQiLCJjaHIiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfcGFzdGFfZnFfbXVsIiwibWxfel9vZl9pbnQ2NCIsImNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kIiwibG9jIiwidW5kZWZfbW9kdWxlIiwiX3giLCJzdHJ1Y3QiLCJpbnRlZ2Vyc191aW50NjRfb2ZfaW50IiwibWxfel9uZWciLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9iZWZvcmVfdGVzdCIsInZvdXRwdXQiLCJjYW1sX3NldF9vb19pZCIsIm1sX3pfb2ZfaW50IiwibWxfel9vZl9pbnQzMiIsImkzMiIsImNhbWxfY29tcGFyZSIsImNhbWxfcGFzdGFfZnFfdG9fYnl0ZXMiLCJjYW1sX3BhbGxhc19zdWIiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImNhbWxfcGFzdGFfZnFfbXV0X2FkZCIsImx4b3JfZGlnaXRfbmF0IiwiaW50ZWdlcnNfdWludDY0X3JlbSIsIm1sX3pfbG9nb3IiLCJtbF96X2ZpdHNfaW50MzIiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJjYW1sX2dyX3NpemVfeCIsImNhbWxfcGFzdGFfZnFfbXV0X211bCIsImNhbWxfcGFzdGFfZnBfc2l6ZSIsImNhbWxfYmlnaW50XzI1Nl9udW1fbGltYnMiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiY2FtbF9wYXN0YV9mcF9vZl9pbnQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX2VwaGVfY2hlY2tfa2V5IiwiY2FtbF9ncl90ZXh0X3NpemUiLCJ0eHQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJpbnRlZ2Vyc191bG9uZ19zaXplIiwiY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHkiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiaW50ZWdlcnNfdWludDMyX3NoaWZ0X2xlZnQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfYXJyYXlfZ2V0IiwiYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YiIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YiIsImlzX2RpZ2l0X3plcm8iLCJjYW1sX2pzX3NldCIsImNhbWxfcGFzdGFfZnBfcG9zZWlkb25fYmxvY2tfY2lwaGVyIiwiZnBfdmVjdG9yIiwibmV3X2ZwX3ZlY3RvciIsImNhbWxfdmVzdGFfZG91YmxlIiwiY2FtbF9wYXN0YV9mcF9vZl9zdHJpbmciLCJtbF96X3Rlc3RiaXQiLCJjb3JlX2tlcm5lbF9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzIiwiY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHMiLCJsb2cyX3NpemUiLCJiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViIiwiY2FtbF9pbnQ2NF9zdWIiLCJiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIiwiYWIiLCJiaW5fcHJvdF9ibGl0X2J1Zl9zdHViIiwidl9zcmMiLCJ2X2RzdCIsInZfc3JjMiIsInZfZHN0MiIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9mcF9zcnNfbGFncmFuZ2VfY29tbWl0bWVudCIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsIm1sX3pfc3FydCIsImNhbWxfZnBfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrIiwiY2FtbF9qc190b19ieXRlX3N0cmluZyIsImRlZmVycmVkX3ZhbHVlX2V4biIsIm1sX3pfcHJvYmFiX3ByaW1lIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfYmlnaW50XzI1Nl9kZWVwX2NvcHkiLCJjYW1sX2J5dGVzX2dldDY0IiwiY2FtbF9wYXN0YV9mcV9vZl9iaWdpbnQiLCJjYW1sX2ZxX3ZlY3Rvcl9sZW5ndGgiLCJjYW1sX3N5c19yZW1vdmUiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF93cml0ZSIsImNhbWxfZnBfdmVjdG9yX2xlbmd0aCIsImNhbWxfcGFzdGFfZnFfaW52IiwibWxfel90b19pbnQiLCJiaWdzdHJpbmdhZl9ibGl0X3RvX2J5dGVzIiwiY2FtbF9tbF9pbnB1dF9pbnQiLCJjYW1sX3Bhc3RhX2ZwX2ludiIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNvcmVfa2VybmVsX2djX21ham9yX3dvcmRzIiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJpbnRlZ2Vyc191aW50MzJfbG9nYW5kIiwibWxfel9zdWNjIiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZHVtbXkiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImludGVnZXJzX3VpbnQ2NF9tYXgiLCJpbnRlZ2Vyc191aW50NjRfb2ZfaW50NjQiLCJtbF96X2djZCIsImNhbWxfcGFzdGFfZnBfdG9fYnl0ZXMiLCJpbnRlZ2Vyc19zaXplX3Rfc2l6ZSIsImNhbWxfanNfZnJvbV9zdHJpbmciLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwiY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZSIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfYnl0ZXNfc2V0MzIiLCJtbF96X2Rpdl9yZW0iLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UiLCJidCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9iYV9kaW1fMyIsImNhbWxfcGFsbGFzX3JuZyIsImNhbWxfZXBoZV9jaGVja19kYXRhIiwiY2FtbF9ieXRlc19nZXQxNiIsImNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfY3JlYXRlIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lIiwiY2FtbF9wYXN0YV9mcF9tdWwiLCJjYW1sX3Bhc3RhX2ZwX211dF9tdWwiLCJjYW1sX3Bhc3RhX2ZwX3ByaW50IiwiYmlnc3RyaW5nX21lbXNldF9zdHViIiwidl9wb3MiLCJ2X2NoYXIiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplIiwiY2FtbF9wYXN0YV9mcF9zaXplX2luX2JpdHMiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSIsImNhbWxfZnFfcGxvbmtfZ2F0ZV90b19ydXN0IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9hZGQiLCJjYW1sX3Zlc3RhX29uZSIsIkJhc2VfaW50X21hdGhfaW50NjRfY2x6IiwiY2FtbF9hcnJheV9hcHBlbmQiLCJjYW1sX3BhbGxhc19lbmRvX2Jhc2UiLCJjYW1sX3Bhc3RhX2ZwX2RpdiIsIm1sX3pfc3ViIiwibWxfel9mZGl2IiwiY2FtbF9mcV9zcnNfd3JpdGUiLCJtbF96X3RvX2JpdHMiLCJyZV9yZXBsYWNlbWVudF90ZXh0IiwicmVwbCIsIm9yaWciLCJjdXIiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImNhbWxfcGFzdGFfZnBfZG9tYWluX2dlbmVyYXRvciIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwiZGVmZXJyZWRfdXBvbl9leG4iLCJmdW5jIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX21sX3NlZWtfaW4iLCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeSIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfbWxfaW5wdXRfY2hhciIsImNhbWxfanNfdmFyIiwiaW50ZWdlcnNfdWludDY0X3RvX2ludCIsImNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJjb3JlX2tlcm5lbF9nY19wcm9tb3RlZF93b3JkcyIsImNhbWxfaXNfcHJpbnRhYmxlIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSIsImNhbWxfYmFfZ2V0XzIiLCJ3aW5faGFuZGxlX2ZkIiwiY2FtbF9iYV91aW50OF9zZXQxNiIsImNhbWxfYmlnaW50XzI1Nl90b19ieXRlcyIsImNvcmVfa2VybmVsX2djX2hlYXBfY2h1bmtzIiwiY2FtbF9iYV9zbGljZSIsIm51bV9pbmRzIiwic3ViX2RpbXMiLCJtbF96X29mX25hdGl2ZWludCIsIm1sX3pfaW52ZXJ0IiwibWxfel9wb3dtIiwiejMiLCJpbnYiLCJtbF96X3Bvd21fc2VjIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdCIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3NpZ2lvX2hhbmRsZXIiLCJjYW1sX3Bhc3RhX2ZxX3RvX2JpZ2ludCIsImNhbWxfc3lzX2dldF9jb25maWciLCJjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUiLCJjYW1sX2ZwX3Nyc19yZWFkIiwiZGVmZXJyZWRfYmluZCIsIm5ld0RlZmVycmVkIiwiYW5vdGhlckRlZmVycmVkIiwiY2FtbF9iaWdpbnRfMjU2X29mX2J5dGVzIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9tYXhfZGVncmVlIiwiY29yZV9rZXJuZWxfZ2NfbWlub3JfY29sbGVjdGlvbnMiLCJjYW1sX21vZCIsImNhbWxfYmFfaW5pdCIsImNhbWxfcGFzdGFfZnFfc2l6ZV9pbl9iaXRzIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImludGVnZXJzX3VpbnQ2NF9jb21wYXJlIiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJ0b0ZpeGVkIiwiZHAiLCJwcmVjIiwiY2FtbF9tb3VudF9hdXRvbG9hZCIsIm1sX3pfZXF1YWwiLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwibWxfel9wZXJmZWN0X3NxdWFyZSIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9ncl9jcmVhdGVfaW1hZ2UiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwiY2FtbF9sZXNzdGhhbiIsIm1sX3pfdG9fbmF0aXZlaW50IiwiYmlnc3RyaW5nYWZfbWVtY21wX3N0cmluZyIsImJhX29mZiIsInN0cl9vZmYiLCJjYW1sX3JlZ2lzdGVyX2dsb2JhbCIsIm5hbWVfb3B0IiwiY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZyIsInJlczIiLCJjYW1sX2ZwX3Nyc19jcmVhdGUiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9wYWxsYXNfb2ZfYWZmaW5lX2Nvb3JkaW5hdGVzIiwiZGVmZXJyZWRfbWFwIiwiY2FtbF9vanNfbmV3X2FyciIsImludGVnZXJzX3VpbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF92ZXN0YV9yYW5kb20iLCJjb21wbGVtZW50X25hdCIsImNhbWxfcGFzdGFfZnFfZGl2IiwibWxfel9sb2d4b3IiLCJjYW1sX3Bhc3RhX2ZxX3NpemUiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsIm1sX3pfdHJhaWxpbmdfemVyb3MiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX3BhbGxhc19zY2FsZSIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX2NyZWF0ZV9maWxlX2V4dGVybiIsImNhbWxfaW50MzJfYnN3YXAiLCJ3aW5fc3RhcnR1cCIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsImludGVnZXJzX3VpbnQzMl9zaGlmdF9yaWdodCIsImNhbWxfdGFuaF9mbG9hdCIsImludGVnZXJzX3VpbnRfc2l6ZSIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kZWVwX2NvcHkiLCJjYW1sX3Bhc3RhX2ZxX25lZ2F0ZSIsImludGVnZXJzX3VzaG9ydF9zaXplIiwiY2FtbF9tbF9wb3NfaW5fNjQiLCJjYW1sX2dyX2RyYXdfaW1hZ2UiLCJpbWFnZSIsImNhbWxfc3RyaW5nX3NldCIsImludGVnZXJzX3VpbnQzMl9yZW0iLCJjYW1sX2J5dGVzX25vdGVxdWFsIiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyIsImludGVnZXJzX3VpbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZHVtbXkiLCJCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZSIsImludGVnZXJzX3VpbnQ2NF9zdWIiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3dyaXRlIiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJtb2RlIiwiY2FtbF9maW5hbF9yZWdpc3RlciIsImNhbWxfZ3JfZHJhd19yZWN0IiwiY2FtbF9wYXN0YV9mcF9yYW5kb20iLCJjYW1sX291dHB1dF92YWx1ZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCIsImNhbWxfYmFfZ2V0XzMiLCJjYW1sX2ZxX3ZlY3Rvcl9jcmVhdGUiLCJjYW1sX3Bhc3RhX2ZxX3JhbmRvbSIsIm1sX3pfdG9faW50MzIiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15IiwiZGVmZXJyZWRfdXBvbiIsImRlZmVycmVkX3J1biIsIm1sX3pfY29tcGFyZSIsImNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5IiwiaW5kZXhlcyIsInByb29mcyIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9ieXRlc19nZXQzMiIsImNvcmVfa2VybmVsX2djX21ham9yX2NvbGxlY3Rpb25zIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJtbF96X29mX2Zsb2F0IiwiZjEiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImZxX29yYWNsZXNfZHVtbXkiLCJkZWZlcnJlZF9yZXR1cm4iLCJCYXNlX2hhc2hfZG91YmxlIiwiY2FtbF9qc19uZXciLCJjYW1sX3Bhc3RhX2ZwX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHkiLCJjYW1sX3Bhc3RhX2ZxX29mX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImludGVnZXJzX3VpbnQ2NF9oYXNoIiwiY29yZV9rZXJuZWxfZ2NfaGVhcF93b3JkcyIsImJpZ3N0cmluZ2FmX2JsaXRfdG9fYmlnc3RyaW5nIiwiY2FtbF9wYWxsYXNfb25lIiwibXNfdG9fbmFubyIsInRpbWVfbm93X25hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2hfb3JfemVybyIsIm1zIiwibXNfaTYzIiwibG9yX2RpZ2l0X25hdCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9iaWdpbnRfMjU2X2J5dGVzX3Blcl9saW1iIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9iYV9sYXlvdXQiLCJpbnRlZ2Vyc19pbnQzMl9vZl91aW50MzIiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwibWxfel9wZXJmZWN0X3Bvd2VyIiwibG9nMnoiLCJ6cCIsInNldF9kaWdpdF9uYXQiLCJjYW1sX21sX291dHB1dF9pbnQiLCJjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2dldCIsImludGVnZXJzX3VpbnQzMl9sb2dvciIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdCIsInN0eWxlIiwiZXhwX3NpZ24iLCJzaWduX3N0ciIsImNzdCIsInhfc3RyIiwiY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzIiwiY2FtbF9wYXN0YV9mcV90b19zdHJpbmciLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJtbF96X2Zvcm1hdCIsImNhcyIsIndpZHRoIiwiYWx0IiwicGFkIiwicHJlZml4IiwicHJlIiwiZnFfb3JhY2xlc19kZWVwX2NvcHkiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwibWxfel9zaGlmdF9yaWdodF90cnVuYyIsImNhbWxfc3RyaW5nX3NldDMyIiwiaW50ZWdlcnNfdW5zaWduZWRfaW5pdCIsImludGVnZXJzX3VpbnQ2NF9hZGQiLCJjYW1sX3BhbGxhc19hZGQiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQiLCJjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeSJdLCJzb3VyY2VzIjpbIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL2NvcmVfa2VybmVsL3N0cmZ0aW1lLmpzIiwiL3dvcmtzcGFjZV9yb290L3NyYy9saWIvY3J5cHRvL2tpbWNoaV9iaW5kaW5ncy9qcy9ub2RlX2pzL25vZGVfYmFja2VuZC5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvbGliL2NyeXB0by9raW1jaGlfYmluZGluZ3MvanMvYmluZGluZ3MuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2xpYi9pbnRlZ2Vyc19zdHVic19qcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvYmFzZV9iaWdzdHJpbmcvcnVudGltZS5qcyIsIi9idWlsdGluLytwYXJzaW5nLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rY29tcGFyZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi9iaW5fcHJvdC9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL3phcml0aF9zdHVic19qcy9iaWdpbnRlZ2VyLmpzIiwiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvemFyaXRoX3N0dWJzX2pzL3J1bnRpbWUuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi9jb3JlX2tlcm5lbC9ydW50aW1lLmpzIiwiL2hvbWUvZ3JlZ29yLy5vcGFtLzQuMTEuMi9saWIvYmFzZS9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL2Jhc2UvYmFzZV9pbnRlcm5hbGhhc2hfdHlwZXMvcnVudGltZS5qcyIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvbGliL3Byb21pc2UvanMvcHJvbWlzZS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi9wcHhfZXhwZWN0L2NvbGxlY3Rvci9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy1jc3RydWN0LmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytpbnRlcm5hbE1vZC5qcyIsIi9ob21lL2dyZWdvci8ub3BhbS80LjExLjIvbGliL2JpZ3N0cmluZ2FmL3J1bnRpbWUuanMiLCIvaG9tZS9ncmVnb3IvLm9wYW0vNC4xMS4yL2xpYi90aW1lX25vdy9ydW50aW1lLmpzIl0sIm1hcHBpbmdzIjoiOztLQVdFO1FBRUU7U0FBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gc3RyZnRpbWVcbi8vIGdpdGh1Yi5jb20vc2Ftc29uanMvc3RyZnRpbWVcbi8vIEBfc2pzXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTAgLSAyMDE1IFNhbWkgU2FtaHVyaSA8c2FtaUBzYW1odXJpLm5ldD5cbi8vXG4vLyBNSVQgTGljZW5zZVxuLy8gaHR0cDovL3Nqcy5taXQtbGljZW5zZS5vcmdcbi8vXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgRGVmYXVsdExvY2FsZSA9IHtcbiAgICAgICAgICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIHNob3J0RGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgICAgIG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICAgICAgQU06ICdBTScsXG4gICAgICAgICAgICBQTTogJ1BNJyxcbiAgICAgICAgICAgIGFtOiAnYW0nLFxuICAgICAgICAgICAgcG06ICdwbScsXG4gICAgICAgICAgICBmb3JtYXRzOiB7XG4gICAgICAgICAgICAgICAgRDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgICAgICBGOiAnJVktJW0tJWQnLFxuICAgICAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICAgICAgVDogJyVIOiVNOiVTJyxcbiAgICAgICAgICAgICAgICBYOiAnJVQnLFxuICAgICAgICAgICAgICAgIGM6ICclYSAlYiAlZCAlWCAlWScsXG4gICAgICAgICAgICAgICAgcjogJyVJOiVNOiVTICVwJyxcbiAgICAgICAgICAgICAgICB2OiAnJWUtJWItJVknLFxuICAgICAgICAgICAgICAgIHg6ICclRCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFN0cmZ0aW1lID0gbmV3IFN0cmZ0aW1lKERlZmF1bHRMb2NhbGUsIDAsIGZhbHNlKSxcbiAgICAgICAgaXNDb21tb25KUyA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICBuYW1lc3BhY2U7XG5cbiAgICAvLyBDb21tb25KUyAvIE5vZGUgbW9kdWxlXG4gICAgaWYgKGlzQ29tbW9uSlMpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gbW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgICAgIG5hbWVzcGFjZS5zdHJmdGltZSA9IGRlcHJlY2F0ZWRTdHJmdGltZTtcbiAgICAgICAgaWYoam9vX2dsb2JhbF9vYmplY3QpIGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cbiAgICAvLyBCcm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIG9iamVjdC4gV29ya3MgaW4gRVMzLCBFUzUsIGFuZCBFUzUgc3RyaWN0IG1vZGUuXG4gICAgICAgIG5hbWVzcGFjZSA9IGpvb19nbG9iYWxfb2JqZWN0IHx8IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfHwgKDEsZXZhbCkoJ3RoaXMnKTsgfSgpKTtcbiAgICAgICAgbmFtZXNwYWNlLnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgQVBJLCB0byBiZSByZW1vdmVkIGluIHYxLjBcbiAgICB2YXIgX3JlcXVpcmUgPSBpc0NvbW1vbkpTID8gXCJyZXF1aXJlKCdzdHJmdGltZScpXCIgOiBcInN0cmZ0aW1lXCI7XG4gICAgdmFyIF9kZXByZWNhdGlvbldhcm5pbmdzID0ge307XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG5hbWUsIGluc3RlYWQpIHtcbiAgICAgICAgaWYgKCFfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gXCIgKyBuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMS4wLiBJbnN0ZWFkLCB1c2UgYFwiICsgaW5zdGVhZCArIFwiYC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc3BhY2Uuc3RyZnRpbWVUWiA9IGRlcHJlY2F0ZWRTdHJmdGltZVRaO1xuICAgIG5hbWVzcGFjZS5zdHJmdGltZVVUQyA9IGRlcHJlY2F0ZWRTdHJmdGltZVVUQztcbiAgICBuYW1lc3BhY2UubG9jYWxpemVkU3RyZnRpbWUgPSBkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQ7XG5cbiAgICAvLyBBZGFwdCB0aGUgb2xkIEFQSSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXcgQVBJLlxuICAgIGZ1bmN0aW9uIGFkYXB0Rm9yd2FyZHMoZm4pIHtcbiAgICAgICAgZm4ubG9jYWxpemUgPSBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgICAgICBmbi50aW1lem9uZSA9IGRlZmF1bHRTdHJmdGltZS50aW1lem9uZS5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgICAgIGZuLnV0YyA9IGRlZmF1bHRTdHJmdGltZS51dGMuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgIH1cblxuICAgIGFkYXB0Rm9yd2FyZHMoYWRhcHRlZFN0cmZ0aW1lKTtcbiAgICBmdW5jdGlvbiBhZGFwdGVkU3RyZnRpbWUoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgLy8gZCBhbmQgbG9jYWxlIGFyZSBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBsb2NhbGUpXG4gICAgICAgIGlmIChkICYmIGQuZGF5cykge1xuICAgICAgICAgICAgbG9jYWxlID0gZDtcbiAgICAgICAgICAgIGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIihmb3JtYXQsIFtkYXRlXSwgW2xvY2FsZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBhZGFwdEZvcndhcmRzKGRlcHJlY2F0ZWRTdHJmdGltZSk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0sIFtsb2NhbGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0pYFwiLCBfcmVxdWlyZSArIFwiKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVFooZm10LCBkLCBsb2NhbGUsIHRpbWV6b25lKSB7XG4gICAgICAgIC8vIGxvY2FsZSBpcyBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBkYXRlLCB0aW1lem9uZSlcbiAgICAgICAgaWYgKCh0eXBlb2YgbG9jYWxlID09ICdudW1iZXInIHx8IHR5cGVvZiBsb2NhbGUgPT0gJ3N0cmluZycpICYmIHRpbWV6b25lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWV6b25lID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0eilgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKS50aW1lem9uZSh0eik7IHMoZm9ybWF0LCBbZGF0ZV0pYCBvciBgdmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcy50aW1lem9uZSh0eikoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgdHopYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLnRpbWV6b25lKHR6KTsgcyhmb3JtYXQsIFtkYXRlXSlgIG9yIGBcIiArIF9yZXF1aXJlICsgXCIudGltZXpvbmUodHopKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJmdGltZSA9IChsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZSkudGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICB2YXIgdXRjU3RyZnRpbWUgPSBkZWZhdWx0U3RyZnRpbWUudXRjKCk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVVRDKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVVVEMoZm9ybWF0LCBkYXRlLCBsb2NhbGUpYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSkudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVVUQyhmb3JtYXQsIFtkYXRlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IHV0Y1N0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiB1dGNTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkKGxvY2FsZSkge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplZFN0cmZ0aW1lKGxvY2FsZSlgXCIsIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKVwiKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpO1xuICAgIH1cbiAgICAvLyBFbmQgb2YgZGVwcmVjYXRlZCBBUElcblxuICAgIC8vIFBvbHlmaWxsIERhdGUubm93IGZvciBvbGQgYnJvd3NlcnMuXG4gICAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdHJmdGltZShsb2NhbGUsIGN1c3RvbVRpbWV6b25lT2Zmc2V0LCB1c2VVdGNUaW1lem9uZSkge1xuICAgICAgICB2YXIgX2xvY2FsZSA9IGxvY2FsZSB8fCBEZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID0gY3VzdG9tVGltZXpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIF91c2VVdGNCYXNlZERhdGUgPSB1c2VVdGNUaW1lem9uZSB8fCBmYWxzZSxcblxuICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdW5peCB0aW1lc3RhbXAgdmFsdWUgaGVyZSB0byBub3QgY3JlYXRlIG5ldyBEYXRlKCkgZWFjaCBpdGVyYXRpb24gKGVhY2ggbWlsbGlzZWNvbmQpXG4gICAgICAgICAgICAvLyBEYXRlLm5vdygpIGlzIDIgdGltZXMgZmFzdGVyIHRoYW4gbmV3IERhdGUoKVxuICAgICAgICAgICAgLy8gd2hpbGUgbWlsbGlzZWNvbmQgcHJlY2lzZSBpcyBlbm91Z2ggaGVyZVxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB2ZXJ5IGhlbHBmdWwgd2hlbiBzdHJmdGltZSB0cmlnZ2VyZWQgYSBsb3Qgb2YgdGltZXMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgX2NhY2hlZERhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0cmZ0aW1lKGZvcm1hdCwgZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZXN0YW1wID4gX2NhY2hlZERhdGVUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSBjdXJyZW50VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZSA9IG5ldyBEYXRlKF9jYWNoZWREYXRlVGltZXN0YW1wKTtcblxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfY2FjaGVkRGF0ZVRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93IHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIGRhdGUgaW5zdGFudGlhdGlvbiBmb3IgdXRjIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0aWVkIHRvIGdldFRpbWV6b25lT2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlID0gbmV3IERhdGUoX2NhY2hlZERhdGVUaW1lc3RhbXAgKyBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihfY2FjaGVkRGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUgPSBfY2FjaGVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoZGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgX2xvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmb3JtYXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVFogPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyQ29kZSA9IGZvcm1hdC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5TY29wZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICdfJ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnOidcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA1OCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZFRaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gZGV0ZWN0ZWQgdXNlIG9mIHVuc3VwcG9ydGVkICU6OiBvciAlOjo6IG1vZGlmaWVycyB0byBzdHJmdGltZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUWiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlcyBmb3IgbmV3IERhdGUoMCkgaW4gR01UXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdUaHVyc2RheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW51YXJ5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxLzAxLzcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ELCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwLTAxLTAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5GLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRIb3VycygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDczOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhNYXRoLmZsb29yKHRpbWVzdGFtcCAlIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1pbnV0ZXMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBsb2NhbGUuYW0gOiBsb2NhbGUucG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuUiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0U2Vjb25kcygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwOjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ULCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIod2Vla051bWJlcihkYXRlLCAnc3VuZGF5JyksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKHdlZWtOdW1iZXIoZGF0ZSwgJ21vbmRheScpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE2OjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5YLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdHTVQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUgJiYgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBcIkdNVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4bWUgb3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR6U3RyaW5nID0gZGF0ZS50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gdHpTdHJpbmcgJiYgdHpTdHJpbmdbMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnVGh1J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnREYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnRNb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuYywgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldERhdGUoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0RGF0ZSgpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydE1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IE1hdGguY2VpbCgoZGF0ZS5nZXRUaW1lKCkgLSB5LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldEhvdXJzKCksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1vbnRoKCkgKyAxLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSArIG9yZGluYWwoZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnQU0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IGxvY2FsZS5BTSA6IGxvY2FsZS5QTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyOjAwOjAwIEFNJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuciwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXkgPT09IDAgPyA3IDogZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxIC0gNywgTW9uZGF5IGlzIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDEtSmFuLTE5NzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy52LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gMCAtIDYsIFN1bmRheSBpcyBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyLzMxLzY5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMueCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAoJycgKyBkYXRlLmdldEZ1bGxZZWFyKCkpLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnKzAwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlICYmIF9jdXN0b21UaW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZXh0ZW5kZWRUWiA/IFwiKzAwOjAwXCIgOiBcIiswMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1c3RvbVRpbWV6b25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBfY3VzdG9tVGltZXpvbmVPZmZzZXQgLyAoNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBvZmYgPCAwID8gJy0nIDogJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gZXh0ZW5kZWRUWiA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZiAvIDYwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5zID0gTWF0aC5hYnMob2ZmICUgNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gc2lnbiArIHBhZFRpbGwyKGhvdXJzKSArIHNlcCArIHBhZFRpbGwyKG1pbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAzNykge1xuICAgICAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gX3N0cmZ0aW1lO1xuXG4gICAgICAgIHN0cmZ0aW1lLmxvY2FsaXplID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKGxvY2FsZSB8fCBfbG9jYWxlLCBfY3VzdG9tVGltZXpvbmVPZmZzZXQsIF91c2VVdGNCYXNlZERhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmZ0aW1lLnRpbWV6b25lID0gZnVuY3Rpb24odGltZXpvbmUpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21UaW1lem9uZU9mZnNldCA9IF9jdXN0b21UaW1lem9uZU9mZnNldDtcbiAgICAgICAgICAgIHZhciB1c2VVdGNCYXNlZERhdGUgPSBfdXNlVXRjQmFzZWREYXRlO1xuXG4gICAgICAgICAgICB2YXIgdGltZXpvbmVUeXBlID0gdHlwZW9mIHRpbWV6b25lO1xuICAgICAgICAgICAgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicgfHwgdGltZXpvbmVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVzZVV0Y0Jhc2VkRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBJU08gODYwMSBmb3JtYXQgdGltZXpvbmUgc3RyaW5nLCBbLStdSEhNTVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGltZXpvbmVbMF0gPT09ICctJyA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gcGFyc2VJbnQodGltZXpvbmUuc2xpY2UoMSwgMyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lem9uZS5zbGljZSgzLCA1KSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gc2lnbiAqICgoNjAgKiBob3VycykgKyBtaW51dGVzKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWludXRlczogNDIwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUoX2xvY2FsZSwgY3VzdG9tVGltZXpvbmVPZmZzZXQsIHVzZVV0Y0Jhc2VkRGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZnRpbWUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKF9sb2NhbGUsIF9jdXN0b21UaW1lem9uZU9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRpbGwyKG51bWJlclRvUGFkLCBwYWRkaW5nQ2hhcikge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXIgPT09ICcnIHx8IG51bWJlclRvUGFkID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nQ2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWRkaW5nQ2hhciA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0NoYXIgKyBudW1iZXJUb1BhZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRUaWxsMyhudW1iZXJUb1BhZCkge1xuICAgICAgICBpZiAobnVtYmVyVG9QYWQgPiA5OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJUb1BhZCA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCcgKyBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzAwJyArIG51bWJlclRvUGFkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvdXJzMTIoaG91cikge1xuICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgLSAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdFdlZWtkYXk6ICdzdW5kYXknIG9yICdtb25kYXknLCBkZWZhdWx0IGlzICdzdW5kYXknXG4gICAgLy9cbiAgICAvLyBQaWxmZXJlZCAmIHBvcnRlZCBmcm9tIFJ1YnkncyBzdHJmdGltZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmdW5jdGlvbiB3ZWVrTnVtYmVyKGRhdGUsIGZpcnN0V2Vla2RheSkge1xuICAgICAgICBmaXJzdFdlZWtkYXkgPSBmaXJzdFdlZWtkYXkgfHwgJ3N1bmRheSc7XG5cbiAgICAgICAgLy8gVGhpcyB3b3JrcyBieSBzaGlmdGluZyB0aGUgd2Vla2RheSBiYWNrIGJ5IG9uZSBkYXkgaWYgd2VcbiAgICAgICAgLy8gYXJlIHRyZWF0aW5nIE1vbmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICB2YXIgd2Vla2RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChmaXJzdFdlZWtkYXkgPT09ICdtb25kYXknKSB7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA9PT0gMCkgLy8gU3VuZGF5XG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IDY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2Vla2RheS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZZZWFyVXRjID0gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICAgIGRhdGVVdGMgPSBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLFxuICAgICAgICAgICAgeWRheSA9IE1hdGguZmxvb3IoKGRhdGVVdGMgLSBmaXJzdERheU9mWWVhclV0YykgLyA4NjQwMDAwMCksXG4gICAgICAgICAgICB3ZWVrTnVtID0gKHlkYXkgKyA3IC0gd2Vla2RheSkgLyA3O1xuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHdlZWtOdW0pO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgb3JkaW5hbCBzdWZmaXggZm9yIGEgbnVtYmVyOiBzdCwgbmQsIHJkLCBvciB0aFxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHZhciBpID0gbnVtYmVyICUgMTA7XG4gICAgICAgIHZhciBpaSA9IG51bWJlciAlIDEwMDtcblxuICAgICAgICBpZiAoKGlpID49IDExICYmIGlpIDw9IDEzKSB8fCBpID09PSAwIHx8IGkgPj0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiAnc3QnO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gJ25kJztcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuICdyZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihkYXRlKSB7XG4gICAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIHx8IDApICogNjAwMDA7XG4gICAgfVxuXG59KCkpO1xuIiwiLyogd29ya2VySGVscGVycy5uby1tb2R1bGVzLmpzICovXG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gUHJvdmlkZXM6IHdvcmtlcl90aHJlYWRzXG52YXIgd29ya2VyX3RocmVhZHMgPSByZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIik7XG5cbi8vIE5vdGU6IHRoaXMgaXMgbmV2ZXIgdXNlZCwgYnV0IG5lY2Vzc2FyeSB0byBwcmV2ZW50IGEgYnVnIGluIEZpcmVmb3hcbi8vIChodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzAyMTkxKSB3aGVyZSBpdCBjb2xsZWN0c1xuLy8gV2ViIFdvcmtlcnMgdGhhdCBoYXZlIGEgc2hhcmVkIFdlYkFzc2VtYmx5IG1lbW9yeSB3aXRoIHRoZSBtYWluIHRocmVhZCxcbi8vIGJ1dCBhcmUgbm90IGV4cGxpY2l0bHkgcm9vdGVkIHZpYSBhIGBXb3JrZXJgIGluc3RhbmNlLlxuLy9cbi8vIEJ5IHN0b3JpbmcgdGhlbSBpbiBhIHZhcmlhYmxlLCB3ZSBjYW4ga2VlcCBgV29ya2VyYCBvYmplY3RzIGFyb3VuZCBhbmRcbi8vIHByZXZlbnQgdGhlbSBmcm9tIGdldHRpbmcgR0MtZC5cblxuLy8gUHJvdmlkZXM6IF93b3JrZXJzXG52YXIgX3dvcmtlcnM7XG5cbi8vIFByb3ZpZGVzOiB3YXNtX3JlYWR5XG4vLyBSZXF1aXJlczogd29ya2VyX3RocmVhZHNcbnZhciB3YXNtX3JlYWR5ID0gZnVuY3Rpb24od2FzbSkge1xuICAgIHdvcmtlcl90aHJlYWRzLnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoeyB0eXBlOiAnd2FzbV9iaW5kZ2VuX3dvcmtlcl9yZWFkeScgfSk7XG4gICAgd2FzbS53YmdfcmF5b25fc3RhcnRfd29ya2VyKHdvcmtlcl90aHJlYWRzLndvcmtlckRhdGEucmVjZWl2ZXIpO1xufTtcblxuLy8gUHJvdmlkZXM6IHN0YXJ0V29ya2Vyc1xuLy8gUmVxdWlyZXM6IHdvcmtlcl90aHJlYWRzLCBfd29ya2VycywgY2FtbF9qc19leHBvcnRfdmFyXG52YXIgc3RhcnRXb3JrZXJzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzbmFya3lfcmVhZHlfcmVzb2x2ZTtcbiAgICBjYW1sX2pzX2V4cG9ydF92YXIoKS5zbmFya3lfcmVhZHkgPVxuICAgICAgICBuZXcgam9vX2dsb2JhbF9vYmplY3QuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBzbmFya3lfcmVhZHlfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbih3b3JrZXJfc291cmNlLCBtZW1vcnksIGJ1aWxkZXIpIHtcbiAgICAgICAgam9vX2dsb2JhbF9vYmplY3Qud2FzbV93b3JrZXJzID0gW107XG4gICAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lndhc21fcmF5b25fcG9vbGJ1aWxkZXIgPSBidWlsZGVyO1xuICAgICAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3QuUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBidWlsZGVyLm51bVRocmVhZHMoKSB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWxmLXNwYXduIGludG8gYSBuZXcgV29ya2VyLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBzY3JpcHQgaXMgZmV0Y2hlZCBhcyBhIGJsb2Igc28gaXQgd29ya3MgZXZlbiBpZiB0aGlzIHNjcmlwdCBpc1xuICAgICAgICAgICAgICAgIC8vIGhvc3RlZCByZW1vdGVseSAoZS5nLiBvbiBhIENETikuIFRoaXMgYXZvaWRzIGEgY3Jvc3Mtb3JpZ2luXG4gICAgICAgICAgICAgICAgLy8gc2VjdXJpdHkgZXJyb3IuXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtlciA9IG5ldyB3b3JrZXJfdGhyZWFkcy5Xb3JrZXIod29ya2VyX3NvdXJjZSwge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJEYXRhOiB7bWVtb3J5OiBtZW1vcnksIHJlY2VpdmVyOiBidWlsZGVyLnJlY2VpdmVyKCl9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgam9vX2dsb2JhbF9vYmplY3Qud2FzbV93b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gd29ya2VyO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gJ3dhc21fYmluZGdlbl93b3JrZXJfcmVhZHknO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgam9vX2dsb2JhbF9vYmplY3QuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG9uTXNnKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YS50eXBlICE9PSB0eXBlIHx8IGRvbmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3b3JrZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBzbmFya3lfcmVhZHlfcmVzb2x2ZSgpO1xuICAgICAgICAgICAgX3dvcmtlcnMgPSBkYXRhO1xuICAgICAgICAgICAgdHJ5IHsgYnVpbGRlci5idWlsZCgpOyB9XG4gICAgICAgICAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSAnbXV0ZScgdGhpcyBlcnJvciBoZXJlLCBzaW5jZSBpdCBjYW4gb25seSBldmVyIHRocm93IHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBzb21ldGhpbmcgd3Jvbmcgd2l0aCB0aGUgcmF5b24gc3Vic3lzdGVtIGluIFdBU00sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdlIGRlbGliZXJhdGVseSBpbnRyb2R1Y2Ugc3VjaCBhIHByb2JsZW0gYnkgZGVzdHJveWluZyBidWlsZGVyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSB3YW50IHRvIHNodXRkb3duIHRoZSBwcm9jZXNzIChhbmQgdGh1cyBuZWVkIHRvIGtpbGwgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgdGhyZWFkcykuIFRoZSBlcnJvciBoZXJlIHdvbid0IGJlIHVzZWZ1bCB0byBkZXZlbG9wZXJzXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGxpYnJhcnkuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59KSgpO1xuXG4vKiBub2RlX2JhY2tlbmQuanMgKi9cblxuLy8gUHJvdmlkZXM6IHBsb25rX3dhc21cbi8vIFJlcXVpcmVzOiB3b3JrZXJfdGhyZWFkcywgc3RhcnRXb3JrZXJzLCB3YXNtX3JlYWR5XG52YXIgcGxvbmtfd2FzbSA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBFeHBvc2UgdGhpcyBnbG9iYWxseSBzbyB0aGF0IGl0IGNhbiBiZSByZWZlcmVuY2VkIGZyb20gV0FTTS5cbiAgICBqb29fZ2xvYmFsX29iamVjdC5zdGFydFdvcmtlcnMgPSBzdGFydFdvcmtlcnM7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoXCJlbnZcIik7XG4gICAgaWYgKHdvcmtlcl90aHJlYWRzLmlzTWFpblRocmVhZCkge1xuICAgICAgICBlbnYubWVtb3J5ID1cbiAgICAgICAgICAgIG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWJBc3NlbWJseS5NZW1vcnkoe1xuICAgICAgICAgICAgICAgIGluaXRpYWw6IDIwLFxuICAgICAgICAgICAgICAgIG1heGltdW06IDY1NTM2LFxuICAgICAgICAgICAgICAgIHNoYXJlZDogdHJ1ZX0pO1xuICAgICAgICBqb29fZ2xvYmFsX29iamVjdC5zdGFydFdvcmtlcnMgPSBzdGFydFdvcmtlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW52Lm1lbW9yeSA9IHdvcmtlcl90aHJlYWRzLndvcmtlckRhdGEubWVtb3J5O1xuICAgIH1cbiAgICB2YXIgcGxvbmtfd2FzbSA9IHJlcXVpcmUoXCIuL3Bsb25rX3dhc20uanNcIik7XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgbGl2ZSBoZXJlLlxuICAgIC8vIFRPRE86IGpzX29mX29jYW1sIGlzIHVuaGFwcHkgYWJvdXQgX19maWxlbmFtZSBoZXJlLCBidXQgaXQncyBpbiB0aGVcbiAgICAvLyBnbG9iYWwgc2NvcGUsIHlldCBub3QgYXR0YWNoZWQgdG8gdGhlIGdsb2JhbCBvYmplY3QsIHNvIHdlIGNhbid0IGFjY2Vzc1xuICAgIC8vIGl0IGRpZmZlcmVudGx5LlxuICAgIGlmICh3b3JrZXJfdGhyZWFkcy5pc01haW5UaHJlYWQpIHtcbiAgICAgICAgcGxvbmtfd2FzbS5pbml0VGhyZWFkUG9vbCgzLCBfX2ZpbGVuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3YXNtX3JlYWR5KHBsb25rX3dhc20pO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbTtcbn0pKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGYpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA+IDApe1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW3VuZGVmaW5lZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkgJiYgZi5sZW5ndGggPT0gYXJpdHkpIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLGFyZ3MpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBbMV0pXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHBvcnRfdmFyXG5mdW5jdGlvbiBjYW1sX2pzX2V4cG9ydF92YXIgKCl7XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNcbiAgZWxzZVxuICAgIHJldHVybiBqb29fZ2xvYmFsX29iamVjdDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSh1bml0KXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYodHlwZW9mIGcuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG4iLCIvKiBnbG9iYWwgam9vX2dsb2JhbF9vYmplY3QsIHBsb25rX3dhc20sIGNhbWxfanNfdG9fYm9vbCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbiAgICBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ieXRlc191bnNhZmVfc2V0LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4qL1xuXG4vLyBQcm92aWRlczogY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG4vLyBSZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxudmFyIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheSA9IGZ1bmN0aW9uKHVpbnQ4YXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gdWludDhhcnJheS5sZW5ndGg7XG4gICAgdmFyIG9jYW1sX2J5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY29udmVydCBoZXJlOiBPQ2FtbCBDaGFyLnQgaXMganVzdCBhbiBpbnQgdW5kZXIgdGhlIGhvb2QuXG4gICAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChvY2FtbF9ieXRlcywgaSwgdWludDhhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBvY2FtbF9ieXRlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXlcbi8vIFJlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG52YXIgY2FtbF9ieXRlc190b191aW50OGFycmF5ID0gZnVuY3Rpb24ob2NhbWxfYnl0ZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2NhbWxfYnl0ZXMpO1xuICAgIHZhciBieXRlcyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnZlcnQgaGVyZTogT0NhbWwgQ2hhci50IGlzIGp1c3QgYW4gaW50IHVuZGVyIHRoZSBob29kLlxuICAgICAgICBieXRlc1tpXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChvY2FtbF9ieXRlcywgaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfb2ZfbnVtZXJhbFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9iaWdpbnRfMjU2X29mX251bWVyYWwgPSBmdW5jdGlvbiAocywgbGVuLCBiYXNlKSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X29mX251bWVyYWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyksIGxlbiwgYmFzZSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X29mX2RlY2ltYWxfc3RyaW5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX2JpZ2ludF8yNTZfb2ZfZGVjaW1hbF9zdHJpbmcgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9vZl9kZWNpbWFsX3N0cmluZyhjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X251bV9saW1ic1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX2JpZ2ludF8yNTZfbnVtX2xpbWJzID0gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfbnVtX2xpbWJzXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfYnl0ZXNfcGVyX2xpbWJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9iaWdpbnRfMjU2X2J5dGVzX3Blcl9saW1iID0gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfYnl0ZXNfcGVyX2xpbWJcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl9kaXZcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9iaWdpbnRfMjU2X2RpdiA9IHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X2RpdlxuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X2NvbXBhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9iaWdpbnRfMjU2X2NvbXBhcmUgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9jb21wYXJlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfcHJpbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9iaWdpbnRfMjU2X3ByaW50ID0gcGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfcHJpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl90b19zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYmlnaW50XzI1Nl90b19zdHJpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X3RvX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9iaWdpbnRfMjU2X3Rlc3RfYml0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc190b19ib29sXG52YXIgY2FtbF9iaWdpbnRfMjU2X3Rlc3RfYml0ID0gZnVuY3Rpb24oeCwgaSkge1xuICAgIHJldHVybiBjYW1sX2pzX3RvX2Jvb2wocGxvbmtfd2FzbS5jYW1sX2JpZ2ludF8yNTZfdGVzdF9iaXQoeCwgaSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfYmlnaW50XzI1Nl90b19ieXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheVxudmFyIGNhbWxfYmlnaW50XzI1Nl90b19ieXRlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9ieXRlc19vZl91aW50OGFycmF5KHBsb25rX3dhc20uY2FtbF9iaWdpbnRfMjU2X3RvX2J5dGVzKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfb2ZfYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXlcbnZhciBjYW1sX2JpZ2ludF8yNTZfb2ZfYnl0ZXMgPSBmdW5jdGlvbihvY2FtbF9ieXRlcykge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9vZl9ieXRlcyhjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXkob2NhbWxfYnl0ZXMpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2JpZ2ludF8yNTZfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfYmlnaW50XzI1Nl9kZWVwX2NvcHkgPSBwbG9ua193YXNtLmNhbWxfYmlnaW50XzI1Nl9kZWVwX2NvcHlcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9jb3B5XG52YXIgY2FtbF9wYXN0YV9mcF9jb3B5ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgeFtpXSA9IHlbaV07XG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwOyAvLyBOb25lXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCB4XTsgLy8gU29tZSh4KVxuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX29wdGlvbl90b19tYXliZV91bmRlZmluZWRcbnZhciBjYW1sX29wdGlvbl90b19tYXliZV91bmRlZmluZWQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09IDApIHsgLy8gTm9uZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB4WzFdO1xuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0c1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3NpemVfaW5fYml0cyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zaXplX2luX2JpdHNcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3NpemUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfc2l6ZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9hZGQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfYWRkXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3N1YlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3N1YiA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zdWJcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfbmVnYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfbmVnYXRlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX25lZ2F0ZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9tdWxcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9tdWwgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfbXVsXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2RpdlxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2RpdiA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9kaXZcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfaW52XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkXG52YXIgY2FtbF9wYXN0YV9mcF9pbnYgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfaW52KHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3NxdWFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3NxdWFyZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9zcXVhcmVcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfaXNfc3F1YXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc190b19ib29sXG52YXIgY2FtbF9wYXN0YV9mcF9pc19zcXVhcmUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfanNfdG9fYm9vbChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfaXNfc3F1YXJlKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3NxcnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWRcbnZhciBjYW1sX3Bhc3RhX2ZwX3NxcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfc3FydCh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9vZl9pbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9vZl9pbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfb2ZfaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3RvX3N0cmluZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcF90b19zdHJpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF90b19zdHJpbmcoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb2Zfc3RyaW5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZwX29mX3N0cmluZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9vZl9zdHJpbmcoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcHJpbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF9wcmludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wcmludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9tdXRfYWRkXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcF9jb3B5LCBjYW1sX3Bhc3RhX2ZwX2FkZFxudmFyIGNhbWxfcGFzdGFfZnBfbXV0X2FkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBjYW1sX3Bhc3RhX2ZwX2NvcHkoeCwgY2FtbF9wYXN0YV9mcF9hZGQoeCwgeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfbXV0X3N1YlxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnBfY29weSwgY2FtbF9wYXN0YV9mcF9zdWJcbnZhciBjYW1sX3Bhc3RhX2ZwX211dF9zdWIgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgY2FtbF9wYXN0YV9mcF9jb3B5KHgsIGNhbWxfcGFzdGFfZnBfc3ViKHgsIHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX211dF9tdWxcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZwX2NvcHksIGNhbWxfcGFzdGFfZnBfbXVsXG52YXIgY2FtbF9wYXN0YV9mcF9tdXRfbXVsID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGNhbWxfcGFzdGFfZnBfY29weSh4LCBjYW1sX3Bhc3RhX2ZwX211bCh4LCB5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9tdXRfc3F1YXJlXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcF9jb3B5LCBjYW1sX3Bhc3RhX2ZwX3NxdWFyZVxudmFyIGNhbWxfcGFzdGFfZnBfbXV0X3NxdWFyZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBjYW1sX3Bhc3RhX2ZwX2NvcHkoeCwgY2FtbF9wYXN0YV9mcF9zcXVhcmUoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfY29tcGFyZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2NvbXBhcmUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfY29tcGFyZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9lcXVhbFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2VxdWFsID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX2VxdWFsXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3JhbmRvbVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3JhbmRvbSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9yYW5kb21cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcm5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcm5nID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3JuZ1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF90b19iaWdpbnRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcF90b19iaWdpbnQgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfdG9fYmlnaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX29mX2JpZ2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX29mX2JpZ2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9vZl9iaWdpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfdHdvX2FkaWNfcm9vdF9vZl91bml0eVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3R3b19hZGljX3Jvb3Rfb2ZfdW5pdHkgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfdHdvX2FkaWNfcm9vdF9vZl91bml0eVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9kb21haW5fZ2VuZXJhdG9yXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfZG9tYWluX2dlbmVyYXRvciA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9kb21haW5fZ2VuZXJhdG9yXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG52YXIgY2FtbF9wYXN0YV9mcF90b19ieXRlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzKHgpO1xuICAgIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXkocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3RvX2J5dGVzKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX29mX2J5dGVzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc190b191aW50OGFycmF5XG52YXIgY2FtbF9wYXN0YV9mcF9vZl9ieXRlcyA9IGZ1bmN0aW9uKG9jYW1sX2J5dGVzKSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9vZl9ieXRlcyhjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXkob2NhbWxfYnl0ZXMpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX2RlZXBfY29weSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9kZWVwX2NvcHlcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9jb3B5XG52YXIgY2FtbF9wYXN0YV9mcV9jb3B5ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgeFtpXSA9IHlbaV07XG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfc2l6ZV9pbl9iaXRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfc2l6ZV9pbl9iaXRzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NpemVfaW5fYml0c1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9zaXplXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfc2l6ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9zaXplXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2FkZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX2FkZCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9hZGRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfc3ViXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfc3ViID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3N1YlxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9uZWdhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9uZWdhdGUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfbmVnYXRlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX211bFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX211bCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9tdWxcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfZGl2XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfZGl2ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2RpdlxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9pbnZcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29wdGlvbl9vZl9tYXliZV91bmRlZmluZWRcbnZhciBjYW1sX3Bhc3RhX2ZxX2ludiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9pbnYoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfc3F1YXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfc3F1YXJlID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3NxdWFyZVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9pc19zcXVhcmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzX3RvX2Jvb2xcbnZhciBjYW1sX3Bhc3RhX2ZxX2lzX3NxdWFyZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9qc190b19ib29sKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9pc19zcXVhcmUoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfc3FydFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcGFzdGFfZnFfc3FydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcHRpb25fb2ZfbWF5YmVfdW5kZWZpbmVkKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9zcXJ0KHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX29mX2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX29mX2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9vZl9pbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfdG9fc3RyaW5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZxX3RvX3N0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3RvX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vZl9zdHJpbmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnFfb2Zfc3RyaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX3N0cmluZyhjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wcmludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3ByaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3ByaW50XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX211dF9hZGRcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZxX2NvcHksIGNhbWxfcGFzdGFfZnFfYWRkXG52YXIgY2FtbF9wYXN0YV9mcV9tdXRfYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGNhbWxfcGFzdGFfZnFfY29weSh4LCBjYW1sX3Bhc3RhX2ZxX2FkZCh4LCB5KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9tdXRfc3ViXG4vLyBSZXF1aXJlczogY2FtbF9wYXN0YV9mcV9jb3B5LCBjYW1sX3Bhc3RhX2ZxX3N1YlxudmFyIGNhbWxfcGFzdGFfZnFfbXV0X3N1YiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBjYW1sX3Bhc3RhX2ZxX2NvcHkoeCwgY2FtbF9wYXN0YV9mcV9zdWIoeCwgeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfbXV0X211bFxuLy8gUmVxdWlyZXM6IGNhbWxfcGFzdGFfZnFfY29weSwgY2FtbF9wYXN0YV9mcV9tdWxcbnZhciBjYW1sX3Bhc3RhX2ZxX211dF9tdWwgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgY2FtbF9wYXN0YV9mcV9jb3B5KHgsIGNhbWxfcGFzdGFfZnFfbXVsKHgsIHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX211dF9zcXVhcmVcbi8vIFJlcXVpcmVzOiBjYW1sX3Bhc3RhX2ZxX2NvcHksIGNhbWxfcGFzdGFfZnFfc3F1YXJlXG52YXIgY2FtbF9wYXN0YV9mcV9tdXRfc3F1YXJlID0gZnVuY3Rpb24oeCkge1xuICAgIGNhbWxfcGFzdGFfZnFfY29weSh4LCBjYW1sX3Bhc3RhX2ZxX3NxdWFyZSh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9jb21wYXJlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfY29tcGFyZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9jb21wYXJlXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2VxdWFsXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfZXF1YWwgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfZXF1YWxcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcmFuZG9tXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfcmFuZG9tID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3JhbmRvbVxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9ybmdcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9ybmcgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcm5nXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3RvX2JpZ2ludFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3RvX2JpZ2ludCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV90b19iaWdpbnRcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfb2ZfYmlnaW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfb2ZfYmlnaW50ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX2JpZ2ludFxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV90d29fYWRpY19yb290X29mX3VuaXR5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfdHdvX2FkaWNfcm9vdF9vZl91bml0eSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV90d29fYWRpY19yb290X29mX3VuaXR5XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2RvbWFpbl9nZW5lcmF0b3Jcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9kb21haW5fZ2VuZXJhdG9yID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2RvbWFpbl9nZW5lcmF0b3JcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfdG9fYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZxX3RvX2J5dGVzID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfdG9fYnl0ZXMoeCk7XG4gICAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheShwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfdG9fYnl0ZXMoeCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfb2ZfYnl0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2J5dGVzX3RvX3VpbnQ4YXJyYXlcbnZhciBjYW1sX3Bhc3RhX2ZxX29mX2J5dGVzID0gZnVuY3Rpb24ob2NhbWxfYnl0ZXMpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX29mX2J5dGVzKGNhbWxfYnl0ZXNfdG9fdWludDhhcnJheShvY2FtbF9ieXRlcykpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnFfZGVlcF9jb3B5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX2RlZXBfY29weVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBpID0gMTsgLy8gVGhlIGZpcnN0IGVudHJ5IGlzIHRoZSBPQ2FtbCB0YWcgZm9yIGFycmF5c1xuICAgIHZhciBsZW4gPSB2Lmxlbmd0aCAtIGk7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciBpbm5lcl9sZW4gPSB2W2ldLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkobGVuICogaW5uZXJfbGVuKTtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5uZXJfbGVuOyBqKyssIHBvcysrKSB7XG4gICAgICAgICAgICByZXNbcG9zXSA9IHZbaV1bal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IgPSBmdW5jdGlvbiAodiwgaW5uZXJfbGVuKSB7XG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciBvdXRwdXRfbGVuID0gbGVuIC8gaW5uZXJfbGVuO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkob3V0cHV0X2xlbiArIDEpXG4gICAgcmVzWzBdID0gMCAvLyBPQ2FtbCB0YWcgYmVmb3JlIGFycmF5IGNvbnRlbnRzLCBzbyB0aGF0IHdlIGNhbiB1c2UgdGhpcyB3aXRoIGFycmF5cyBvciB2ZWN0b3JzXG4gICAgZm9yICh2YXIgaSA9IDEsIHBvcyA9IDA7IGkgPD0gb3V0cHV0X2xlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbm5lcl9yZXMgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShpbm5lcl9sZW4pO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlubmVyX2xlbjsgaisrLCBwb3MrKykge1xuICAgICAgICAgICAgaW5uZXJfcmVzW2pdID0gdltwb3NdO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tpXSA9IGlubmVyX3JlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciByZXMgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIEJld2FyZTogY2FsbGVyIG1heSBuZWVkIHRvIGRvIGZpbmFsaXplciB0aGluZ3MgdG8gYXZvaWQgdGhlc2VcbiAgICAgICAgLy8gcG9pbnRlcnMgZGlzYXBwZWFyaW5nIG91dCBmcm9tIHVuZGVyIHVzLlxuICAgICAgICByZXNbaV0gPSB2W2ldLnB0cjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3JcbnZhciBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IgPSBmdW5jdGlvbiAodiwga2xhc3MpIHtcbiAgICAvLyByZXR1cm4gdi5tYXAoa2xhc3MuX193cmFwKVxuICAgIHZhciBsZW4gPSB2Lmxlbmd0aDtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBCZXdhcmU6IHRoZSBjYWxsZXIgbWF5IG5lZWQgdG8gYWRkIGZpbmFsaXplcnMgdG8gdGhlc2UuXG4gICAgICAgIHJlc1tpXSA9IGtsYXNzLl9fd3JhcCh2W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX2NyZWF0ZVxudmFyIGNhbWxfZnBfdmVjdG9yX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbMF07IC8vIE9DYW1sIHRhZyBmb3IgYXJyYXlzLCBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlIHNhbWUgdXRpbGl0eSBmbnMgb24gYm90aFxufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX2xlbmd0aFxudmFyIGNhbWxfZnBfdmVjdG9yX2xlbmd0aCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoIC0gMTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3ZlY3Rvcl9lbXBsYWNlX2JhY2tcbnZhciBjYW1sX2ZwX3ZlY3Rvcl9lbXBsYWNlX2JhY2sgPSBmdW5jdGlvbiAodiwgeCkge1xuICAgIHYucHVzaCh4KTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX2dldFxudmFyIGNhbWxfZnBfdmVjdG9yX2dldCA9IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgcmV0dXJuIG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHZbaSsxXSk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3Rvcih2KTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnBfdmVjdG9yX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAvLyBUT0RPOiBIYXJkY29kaW5nIHRoaXMgaXMgYSBsaXR0bGUgYnJpdHRsZVxuICAgIHJldHVybiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IodiwgMzIpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9jcmVhdGVcbnZhciBjYW1sX2ZxX3ZlY3Rvcl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gWzBdOyAvLyBPQ2FtbCB0YWcgZm9yIGFycmF5cywgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZSBzYW1lIHV0aWxpdHkgZm5zIG9uIGJvdGhcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9sZW5ndGhcbnZhciBjYW1sX2ZxX3ZlY3Rvcl9sZW5ndGggPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2Lmxlbmd0aCAtIDE7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV92ZWN0b3JfZW1wbGFjZV9iYWNrXG52YXIgY2FtbF9mcV92ZWN0b3JfZW1wbGFjZV9iYWNrID0gZnVuY3Rpb24gKHYsIHgpIHtcbiAgICB2LnB1c2goeCk7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9nZXRcbnZhciBjYW1sX2ZxX3ZlY3Rvcl9nZXQgPSBmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSh2W2krMV0pO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF9mcV92ZWN0b3JfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3Iodik7XG59XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVE9ETzogSGFyZGNvZGluZyB0aGlzIGlzIGEgbGl0dGxlIGJyaXR0bGVcbiAgICByZXR1cm4gY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yKHYsIDMyKTtcbn1cblxuXG5cblxuXG4vLyBQcm92aWRlczogZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBmcmVlX2ZpbmFsaXphdGlvbl9yZWdpc3RyeSA9XG4gICAgbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uIChpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZSkge1xuICAgICAgICBpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZS5mcmVlKCk7XG4gICAgfSk7XG5cbi8vIFByb3ZpZGVzOiBmcmVlX29uX2ZpbmFsaXplXG4vLyBSZXF1aXJlczogZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBmcmVlX29uX2ZpbmFsaXplID0gZnVuY3Rpb24gKHgpIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVuZm9ydHVuYXRlIGhhY2s6IHdlJ3JlIGNyZWF0aW5nIGEgc2Vjb25kIGluc3RhbmNlIG9mIHRoZVxuICAgIC8vIGNsYXNzIHRvIGJlIGFibGUgdG8gY2FsbCBmcmVlIG9uIGl0LiBXZSBjYW4ndCBwYXNzIHRoZSB2YWx1ZSBpdHNlbGYsXG4gICAgLy8gc2luY2UgdGhlIHJlZ2lzdHJ5IGhvbGRzIGEgc3Ryb25nIHJlZmVyZW5jZSB0byB0aGUgcmVwcmVzZW50YXRpdmUgdmFsdWUuXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB0aGUgY2xhc3MgaXMgb25seSByZWFsbHkgYSB3cmFwcGVyIGFyb3VuZCBhIHBvaW50ZXIsIHdpdGggYVxuICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgY2xhc3MnIHByb3RvdHlwZSBhcyBpdHMgX19wcm90b3R5cGVfXy5cbiAgICAvL1xuICAgIC8vIEl0IG1pZ2h0IHNlZW0gY2xlYW5lciB0byBjYWxsIHRoZSBkZXN0cnVjdG9yIGhlcmUgb24gdGhlIHBvaW50ZXJcbiAgICAvLyBkaXJlY3RseSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIGRlc3RydWN0b3IgbmFtZSBpcyBzb21lIG1hbmdsZWQgaW50ZXJuYWxcbiAgICAvLyBzdHJpbmcgZ2VuZXJhdGVkIGJ5IHdhc21fYmluZGdlbi4gRm9yIG5vdywgdGhpcyBpcyB0aGUgYmVzdCxcbiAgICAvLyBsZWFzdC1icml0dGxlIHdheSB0byBmcmVlIG9uY2UgdGhlIG9yaWdpbmFsIGNsYXNzIGluc3RhbmNlIGdldHMgY29sbGVjdGVkLlxuICAgIHZhciBpbnN0YW5jZV9yZXByZXNlbnRhdGl2ZSA9IHguY29uc3RydWN0b3IuX193cmFwKHgucHRyKVxuICAgIGZyZWVfZmluYWxpemF0aW9uX3JlZ2lzdHJ5LnJlZ2lzdGVyKHgsIGluc3RhbmNlX3JlcHJlc2VudGF0aXZlLCB4KTtcbiAgICByZXR1cm4geDtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUgPSBmdW5jdGlvbihwdCkge1xuICAgIHZhciBpbmZpbml0eSA9IHB0LmluZmluaXR5O1xuICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICBwdC5mcmVlKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gcHQueDtcbiAgICAgICAgdmFyIHkgPSBwdC55O1xuICAgICAgICBwdC5mcmVlKCk7XG4gICAgICAgIHJldHVybiBbMCwgWzAsIHgsIHldXTtcbiAgICB9XG59O1xuXG4vLyBQcm92aWRlczogcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmVcbnZhciBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSA9IGZ1bmN0aW9uKHB0LCBrbGFzcykge1xuICAgIHZhciByZXMgPSBuZXcga2xhc3MoKTtcbiAgICBpZiAocHQgPT09IDApIHtcbiAgICAgICAgcmVzLmluZmluaXR5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMYXlvdXQgaXMgWzAsIFswLCB4LCB5XV1cbiAgICAgICAgLy8gRmlyc3QgMCBpcyB0aGUgdGFnIChpdCdzIHRoZSAwdGggY29uc3RydWN0b3IgdGhhdCB0YWtlcyBhcmd1bWVudHMpXG4gICAgICAgIC8vIFNlY29uZCAwIGlzIHRoZSBibG9jayBtYXJrZXIgZm9yIHRoZSBhbm9ueW1vdXMgdHVwbGUgYXJndW1lbnRzXG4gICAgICAgIHJlcy54ID0gcHRbMV1bMV07XG4gICAgICAgIHJlcy55ID0gcHRbMV1bMl07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19vbmVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfb25lKCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfYWRkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX2FkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZGQoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfc3ViXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX3N1YiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19zdWIoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfbmVnYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX25lZ2F0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19uZWdhdGUoeCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfZG91YmxlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX2RvdWJsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19kb3VibGUoeCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfc2NhbGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfc2NhbGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfc2NhbGUoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYWxsYXNfcmFuZG9tXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGFsbGFzX3JhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX3JhbmRvbSgpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3JuZ1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19ybmcgPSBmdW5jdGlvbihpKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfcm5nKGkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3RvX2FmZmluZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgY2FtbF9wYWxsYXNfdG9fYWZmaW5lID0gZnVuY3Rpb24ocHQpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc190b19hZmZpbmUocHQpO1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX29mX2FmZmluZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYWxsYXNfb2ZfYWZmaW5lID0gZnVuY3Rpb24ocHQpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19vZl9hZmZpbmUocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX29mX2FmZmluZV9jb29yZGluYXRlc1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3BhbGxhc19vZl9hZmZpbmVfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYWxsYXNfb2ZfYWZmaW5lX2Nvb3JkaW5hdGVzKHgsIHkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX2VuZG9fYmFzZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3BhbGxhc19lbmRvX2Jhc2UgPSBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2VuZG9fYmFzZTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX2VuZG9fc2NhbGFyXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFsbGFzX2VuZG9fc2NhbGFyID0gcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19lbmRvX3NjYWxhcjtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX2FmZmluZV9kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX3BhbGxhc19hZmZpbmVfZGVlcF9jb3B5ID0gZnVuY3Rpb24ocHQpIHtcbiAgICByZXR1cm4gcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUocGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZmZpbmVfZGVlcF9jb3B5KHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHB0LCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Zlc3RhX29uZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX29uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfb25lKCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZGQoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9zdWJcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9zdWIgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9zdWIoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9uZWdhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9uZWdhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9uZWdhdGUoeCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9kb3VibGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9kb3VibGUgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9kb3VibGUoeCk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9zY2FsZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX3NjYWxlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfc2NhbGUoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9yYW5kb21cbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX3JhbmRvbSgpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfcm5nXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfdmVzdGFfcm5nID0gZnVuY3Rpb24oaSkge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfcm5nKGkpO1xuICAgIGZyZWVfb25fZmluYWxpemUocmVzKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfdG9fYWZmaW5lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX3Zlc3RhX3RvX2FmZmluZSA9IGZ1bmN0aW9uKHB0KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV90b19hZmZpbmUocHQpO1xuICAgIHJldHVybiBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZShyZXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfb2ZfYWZmaW5lXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Zlc3RhX29mX2FmZmluZSA9IGZ1bmN0aW9uKHB0KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9vZl9hZmZpbmUocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF92ZXN0YV9vZl9hZmZpbmVfY29vcmRpbmF0ZXMoeCwgeSk7XG4gICAgZnJlZV9vbl9maW5hbGl6ZShyZXMpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9lbmRvX2Jhc2Vcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF92ZXN0YV9lbmRvX2Jhc2UgPSBwbG9ua193YXNtLmNhbWxfdmVzdGFfZW5kb19iYXNlO1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9lbmRvX3NjYWxhclxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Zlc3RhX2VuZG9fc2NhbGFyID0gcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2VuZG9fc2NhbGFyO1xuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9hZmZpbmVfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lXG52YXIgY2FtbF92ZXN0YV9hZmZpbmVfZGVlcF9jb3B5ID0gZnVuY3Rpb24ocHQpIHtcbiAgICByZXR1cm4gcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUocGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9kZWVwX2NvcHkocnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUocHQsIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKSkpO1xufTtcblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfcnVzdF92ZWN0b3Jcbi8vIFJlcXVpcmVzOiBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3JcbnZhciBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yID0gZnVuY3Rpb24odiwga2xhc3MsIGNvbnZlcnQsIHNob3VsZF9mcmVlKSB7XG4gICAgdiA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih2LCBrbGFzcyk7XG4gICAgdmFyIGxlbiA9IHYubGVuZ3RoO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgIHJlc1swXSA9IDA7IC8vIE9DYW1sIHRhZyBiZWZvcmUgYXJyYXkgY29udGVudHNcbiAgICBmb3IgKHZhciBpPTA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcnVzdF92YWwgPSB2W2ldO1xuICAgICAgICByZXNbaSsxXSA9IGNvbnZlcnQocnVzdF92YWwpO1xuICAgICAgICBpZiAoc2hvdWxkX2ZyZWUpIHsgcnVzdF92YWwuZnJlZSgpOyB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvclxuLy8gUmVxdWlyZXM6IGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvciwgZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yID0gZnVuY3Rpb24odiwgY29udmVydCwgbWtfbmV3KSB7XG4gICAgdiA9IHYuc2xpY2UoMSk7IC8vIENvcHksIGRyb3BwaW5nIE9DYW1sIHRhZ1xuICAgIGZvciAodmFyIGk9MCwgbD12Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2xhc3NfdmFsID0gY29udmVydCh2W2ldLCBta19uZXcpO1xuICAgICAgICB2W2ldID0gY2xhc3NfdmFsO1xuICAgICAgICAvLyBEb24ndCBmcmVlIHdoZW4gR0MgcnVuczsgcnVzdCB3aWxsIGZyZWUgb24gaXRzIGVuZC5cbiAgICAgICAgZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnkudW5yZWdpc3RlcihjbGFzc192YWwpO1xuICAgIH1cbiAgICByZXR1cm4ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHYpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbVxuLy8gUmVxdWlyZXM6IHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lLCBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yXG52YXIgY2FtbF9wb2x5X2NvbW1fb2ZfcnVzdF9wb2x5X2NvbW0gPSBmdW5jdGlvbihwb2x5X2NvbW0sIGtsYXNzLCBzaG91bGRfZnJlZSkge1xuICAgIHZhciBydXN0X3NoaWZ0ZWQgPSBwb2x5X2NvbW0uc2hpZnRlZDtcbiAgICB2YXIgcnVzdF91bnNoaWZ0ZWQgPSBwb2x5X2NvbW0udW5zaGlmdGVkO1xuICAgIHZhciBjYW1sX3NoaWZ0ZWQ7XG4gICAgaWYgKHJ1c3Rfc2hpZnRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbWxfc2hpZnRlZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FtbF9zaGlmdGVkID0gWzAsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lKHJ1c3Rfc2hpZnRlZCldO1xuICAgIH1cbiAgICB2YXIgY2FtbF91bnNoaWZ0ZWQgPSBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yKHJ1c3RfdW5zaGlmdGVkLCBrbGFzcywgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUsIHNob3VsZF9mcmVlKTtcbiAgICByZXR1cm4gWzAsIGNhbWxfdW5zaGlmdGVkLCBjYW1sX3NoaWZ0ZWRdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tXG4vLyBSZXF1aXJlczogcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3JcbnZhciBjYW1sX3BvbHlfY29tbV90b19ydXN0X3BvbHlfY29tbSA9IGZ1bmN0aW9uKHBvbHlfY29tbSwgcG9seV9jb21tX2NsYXNzLCBta19hZmZpbmUpIHtcbiAgICB2YXIgY2FtbF91bnNoaWZ0ZWQgPSBwb2x5X2NvbW1bMV07XG4gICAgdmFyIGNhbWxfc2hpZnRlZCA9IHBvbHlfY29tbVsyXTtcbiAgICB2YXIgcnVzdF9zaGlmdGVkID0gdW5kZWZpbmVkO1xuICAgIGlmIChjYW1sX3NoaWZ0ZWQgIT09IDApIHtcbiAgICAgICAgcnVzdF9zaGlmdGVkID0gcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUoY2FtbF9zaGlmdGVkWzFdLCBta19hZmZpbmUpO1xuICAgIH1cbiAgICB2YXIgcnVzdF91bnNoaWZ0ZWQgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGNhbWxfdW5zaGlmdGVkLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgbWtfYWZmaW5lKTtcbiAgICByZXR1cm4gbmV3IHBvbHlfY29tbV9jbGFzcyhydXN0X3Vuc2hpZnRlZCwgcnVzdF9zaGlmdGVkKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbVxudmFyIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tKHgsIHBsb25rX3dhc20uV2FzbUdWZXN0YSwgZmFsc2UpO1xufVxuXG4vLyBQcm92aWRlczogY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tXG52YXIgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0oeCwgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xufVxuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tXG52YXIgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcG9seV9jb21tX29mX3J1c3RfcG9seV9jb21tKHgsIHBsb25rX3dhc20uV2FzbUdQYWxsYXMsIGZhbHNlKTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW1cbnZhciBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wb2x5X2NvbW1fdG9fcnVzdF9wb2x5X2NvbW0oeCwgcGxvbmtfd2FzbS5XYXNtRnFQb2x5Q29tbSwgcGxvbmtfd2FzbS5jYW1sX3BhbGxhc19hZmZpbmVfb25lKTtcbn1cblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfZnBfc3JzX2NyZWF0ZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfZnBfc3JzX2NyZWF0ZShpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfZnBfc3JzX3dyaXRlID0gZnVuY3Rpb24oYXBwZW5kLCB0LCBwYXRoKSB7XG4gICAgaWYgKGFwcGVuZCA9PT0gMCkge1xuICAgICAgICBhcHBlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc193cml0ZShhcHBlbmQsIHQsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19yZWFkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX2ZwX3Nyc19yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgcGF0aCkge1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldFsxXTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcF9zcnNfcmVhZChvZmZzZXQsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICAgIHJldHVybiBbMCwgcmVzXTsgLy8gU29tZShyZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIE5vbmVcbiAgICB9XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfbGFncmFuZ2VfY29tbWl0bWVudFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3RcbnZhciBjYW1sX2ZwX3Nyc19sYWdyYW5nZV9jb21taXRtZW50ID0gZnVuY3Rpb24gKHQsIGRvbWFpbl9zaXplLCBpKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcF9zcnNfbGFncmFuZ2VfY29tbWl0bWVudCh0LCBkb21haW5fc2l6ZSwgaSk7XG4gICAgcmV0dXJuIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19jb21taXRfZXZhbHVhdGlvbnNcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0LCBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0XG52YXIgY2FtbF9mcF9zcnNfY29tbWl0X2V2YWx1YXRpb25zID0gZnVuY3Rpb24gKHQsIGRvbWFpbl9zaXplLCBmcHMpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc19jb21taXRfZXZhbHVhdGlvbnModCwgZG9tYWluX3NpemUsIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoZnBzKSk7XG4gICAgcmV0dXJuIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19iX3BvbHlfY29tbWl0bWVudFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QsIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvclxudmFyIGNhbWxfZnBfc3JzX2JfcG9seV9jb21taXRtZW50ID0gZnVuY3Rpb24gKHNycywgY2hhbHMpIHtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc19iX3BvbHlfY29tbWl0bWVudChzcnMsIGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvcihjaGFscykpO1xuICAgIHJldHVybiBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcF9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2tcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdFxudmFyIGNhbWxfZnBfc3JzX2JhdGNoX2FjY3VtdWxhdG9yX2NoZWNrID0gZnVuY3Rpb24gKHNycywgY29tbXMsIGNoYWxzKSB7XG4gICAgdmFyIHJ1c3RfY29tbXMgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGNvbW1zLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIHZhciBydXN0X2NoYWxzID0gY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChjaGFscyk7XG4gICAgdmFyIG9rID0gcGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayhzcnMsIHJ1c3RfY29tbXMsIHJ1c3RfY2hhbHMpO1xuICAgIHJldHVybiBvaztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Nyc19oXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX2ZwX3Nyc19oID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUocGxvbmtfd2FzbS5jYW1sX2ZwX3Nyc19oKHQpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX2ZxX3Nyc19jcmVhdGUgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIGZyZWVfb25fZmluYWxpemUocGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19jcmVhdGUoaSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX3dyaXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX2ZxX3Nyc193cml0ZSA9IGZ1bmN0aW9uKGFwcGVuZCwgdCwgcGF0aCkge1xuICAgIGlmIChhcHBlbmQgPT09IDApIHtcbiAgICAgICAgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9mcV9zcnNfd3JpdGUoYXBwZW5kLCB0LCAgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfZnFfc3JzX3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfZnFfc3JzX3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwYXRoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WzFdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19yZWFkKG9mZnNldCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIFswLCByZXNdOyAvLyBTb21lKHJlcylcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDsgLy8gTm9uZVxuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19sYWdyYW5nZV9jb21taXRtZW50XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3RcbnZhciBjYW1sX2ZxX3Nyc19sYWdyYW5nZV9jb21taXRtZW50ID0gZnVuY3Rpb24gKHQsIGRvbWFpbl9zaXplLCBpKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcV9zcnNfbGFncmFuZ2VfY29tbWl0bWVudCh0LCBkb21haW5fc2l6ZSwgaSk7XG4gICAgcmV0dXJuIGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KHJlcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9mcV9zcnNfY29tbWl0X2V2YWx1YXRpb25zXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QsIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3RcbnZhciBjYW1sX2ZxX3Nyc19jb21taXRfZXZhbHVhdGlvbnMgPSBmdW5jdGlvbiAodCwgZG9tYWluX3NpemUsIGZxcykge1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfZnFfc3JzX2NvbW1pdF9ldmFsdWF0aW9ucyh0LCBkb21haW5fc2l6ZSwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChmcXMpKTtcbiAgICByZXR1cm4gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0LCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3JcbnZhciBjYW1sX2ZxX3Nyc19iX3BvbHlfY29tbWl0bWVudCA9IGZ1bmN0aW9uIChzcnMsIGNoYWxzKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9mcV9zcnNfYl9wb2x5X2NvbW1pdG1lbnQoc3JzLCBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoY2hhbHMpKTtcbiAgICByZXR1cm4gY2FtbF9wYWxsYXNfcG9seV9jb21tX29mX3J1c3QocmVzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVja1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0XG52YXIgY2FtbF9mcV9zcnNfYmF0Y2hfYWNjdW11bGF0b3JfY2hlY2sgPSBmdW5jdGlvbiAoc3JzLCBjb21tcywgY2hhbHMpIHtcbiAgICB2YXIgcnVzdF9jb21tcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IoY29tbXMsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xuICAgIHZhciBydXN0X2NoYWxzID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChjaGFscyk7XG4gICAgdmFyIG9rID0gcGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19iYXRjaF9hY2N1bXVsYXRvcl9jaGVjayhzcnMsIHJ1c3RfY29tbXMsIHJ1c3RfY2hhbHMpO1xuICAgIHJldHVybiBvaztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Nyc19oXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX2ZxX3Nyc19oID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUocGxvbmtfd2FzbS5jYW1sX2ZxX3Nyc19oKHQpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0XG52YXIgY2FtbF9wbG9ua193aXJlX29mX3J1c3QgPSBmdW5jdGlvbih3aXJlKSB7XG4gICAgdmFyIHJlcyA9IFswLCB3aXJlLnJvdywgd2lyZS5jb2xdO1xuICAgIHdpcmUuZnJlZSgpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua193aXJlX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wbG9ua193aXJlX3RvX3J1c3QgPSBmdW5jdGlvbih3aXJlKSB7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uV2lyZS5jcmVhdGUod2lyZVsxXSwgd2lyZVsyXSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua193aXJlc19vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF9wbG9ua193aXJlX29mX3J1c3RcbnZhciBjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3QgPSBmdW5jdGlvbih3aXJlcykge1xuICAgIHZhciByZXMgPSBbMCxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzBdKSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzFdKSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzJdKSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzNdKSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzRdKSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzVdKSxcbiAgICAgIGNhbWxfcGxvbmtfd2lyZV9vZl9ydXN0KHdpcmVzWzZdKV07XG4gICAgd2lyZXMuZnJlZSgpO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua193aXJlc190b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua193aXJlX3RvX3J1c3RcbnZhciBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QgPSBmdW5jdGlvbih3aXJlcykge1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtR2F0ZVdpcmVzKFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbMV0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbMl0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbM10pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbNF0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbNV0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbNl0pLFxuICAgICAgY2FtbF9wbG9ua193aXJlX3RvX3J1c3Qod2lyZXNbN10pXG4gICAgKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcGxvbmtfd2lyZXNfb2ZfcnVzdCwgY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9wbG9ua19nYXRlX29mX3J1c3QgPSBmdW5jdGlvbihnYXRlKSB7XG4gICAgLy8gVE9ETzogSGFyZGNvZGluZyAzMiBoZXJlIGlzIGEgbGl0dGxlIGJyaXR0bGVcbiAgICB2YXIgcmVzID0gWzAsIGdhdGUudHlwLCBjYW1sX3Bsb25rX3dpcmVzX29mX3J1c3QoZ2F0ZS53aXJlcyksIGNhbWxfdThhcnJheV92ZWN0b3Jfb2ZfcnVzdF9mbGF0X3ZlY3RvcihnYXRlLmMsIDMyKV07XG4gICAgZ2F0ZS5mcmVlKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfd2lyZXNfdG9fcnVzdCwgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcF9wbG9ua19nYXRlX3RvX3J1c3QgPSBmdW5jdGlvbihnYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcEdhdGUoXG4gICAgICBnYXRlWzFdLFxuICAgICAgY2FtbF9wbG9ua193aXJlc190b19ydXN0KGdhdGVbMl0pLFxuICAgICAgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yKGdhdGVbM10pKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX2ZxX3Bsb25rX2dhdGVfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfd2lyZXNfdG9fcnVzdCwgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yXG52YXIgY2FtbF9mcV9wbG9ua19nYXRlX3RvX3J1c3QgPSBmdW5jdGlvbihnYXRlKSB7XG4gICAgLy8gVE9ETzogSGFyZGNvZGluZyAzMiBoZXJlIGlzIGEgbGl0dGxlIGJyaXR0bGVcbiAgICByZXR1cm4gbmV3IHBsb25rX3dhc20uV2FzbUZxR2F0ZShcbiAgICAgIGdhdGVbMV0sXG4gICAgICBjYW1sX3Bsb25rX3dpcmVzX3RvX3J1c3QoZ2F0ZVsyXSksXG4gICAgICBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IoZ2F0ZVszXSkpXG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcmVlX29uX2ZpbmFsaXplKHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUoKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9hZGRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZwX3Bsb25rX2dhdGVfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkID0gZnVuY3Rpb24odiwgeCkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkKHYsIGNhbWxfZnBfcGxvbmtfZ2F0ZV90b19ydXN0KHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2dldFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9nZXQgPSBmdW5jdGlvbih2LCBpKSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfZ2F0ZV9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9nZXQodiwgaSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl93cmFwID0gZnVuY3Rpb24odiwgeCwgeSkge1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCh2LCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdCh4KSwgY2FtbF9wbG9ua193aXJlX3RvX3J1c3QoeSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9ieXRlc19vZl91aW50OGFycmF5XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3QgPSBmdW5jdGlvbihnYXRlX3ZlY3Rvcikge1xuICAgIHZhciB1aW50OGFycmF5ID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdChnYXRlX3ZlY3Rvcik7XG4gICAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheSh1aW50OGFycmF5KTtcbn1cblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBmcmVlX29uX2ZpbmFsaXplXG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfY3JlYXRlKCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfYWRkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV9wbG9ua19nYXRlX3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2FkZCA9IGZ1bmN0aW9uKHYsIHgpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2FkZCh2LCBjYW1sX2ZxX3Bsb25rX2dhdGVfdG9fcnVzdCh4KSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9nZXRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0ID0gZnVuY3Rpb24odiwgaSkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX2dhdGVfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZ2V0KHYsIGkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX3dyYXBcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3dpcmVfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3Jfd3JhcCA9IGZ1bmN0aW9uKHYsIHgsIHkpIHtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX3dyYXAodiwgY2FtbF9wbG9ua193aXJlX3RvX3J1c3QoeCksIGNhbWxfcGxvbmtfd2lyZV90b19ydXN0KHkpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2dhdGVfdmVjdG9yX2RpZ2VzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYnl0ZXNfb2ZfdWludDhhcnJheVxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfZ2F0ZV92ZWN0b3JfZGlnZXN0ID0gZnVuY3Rpb24oZ2F0ZV92ZWN0b3IpIHtcbiAgICB2YXIgdWludDhhcnJheSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19nYXRlX3ZlY3Rvcl9kaWdlc3QoZ2F0ZV92ZWN0b3IpO1xuICAgIHJldHVybiBjYW1sX2J5dGVzX29mX3VpbnQ4YXJyYXkodWludDhhcnJheSk7XG59XG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2NyZWF0ZSA9IGZ1bmN0aW9uKGdhdGVzLCBwdWJsaWNfaW5wdXRzLCB1cnMpIHtcbiAgICB2YXIgdCA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9jcmVhdGUoZ2F0ZXMsIHB1YmxpY19pbnB1dHMsIHVycyk7XG4gICAgcmV0dXJuIGZyZWVfb25fZmluYWxpemUodCk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9tYXhfZGVncmVlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9tYXhfZGVncmVlO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfcHVibGljX2lucHV0cyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9wdWJsaWNfaW5wdXRzO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kMV9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kNF9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9kb21haW5fZDhfc2l6ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X2RvbWFpbl9kOF9zaXplO1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19pbmRleF9yZWFkXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX2luZGV4X3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCB1cnMsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfcmVhZChvZmZzZXQsIHVycywgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfd3JpdGUgPSBmdW5jdGlvbihhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfaW5kZXhfd3JpdGUoYXBwZW5kLCB0LCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGZyZWVfb25fZmluYWxpemVcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X2NyZWF0ZSA9IGZ1bmN0aW9uKGdhdGVzLCBwdWJsaWNfaW5wdXRzLCB1cnMpIHtcbiAgICByZXR1cm4gZnJlZV9vbl9maW5hbGl6ZShwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfY3JlYXRlKGdhdGVzLCBwdWJsaWNfaW5wdXRzLCB1cnMpKTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X21heF9kZWdyZWUgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfbWF4X2RlZ3JlZTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcHVibGljX2lucHV0c1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc21cbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3B1YmxpY19pbnB1dHMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcHVibGljX2lucHV0cztcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2QxX3NpemVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDFfc2l6ZTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2Q0X3NpemVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDRfc2l6ZTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfZG9tYWluX2Q4X3NpemVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDhfc2l6ZSA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9kb21haW5fZDhfc2l6ZTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfaW5kZXhfcmVhZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19pbmRleF9yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgdXJzLCBwYXRoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3JlYWQob2Zmc2V0LCB1cnMsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3dyaXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3dyaXRlID0gZnVuY3Rpb24oYXBwZW5kLCB0LCBwYXRoKSB7XG4gICAgaWYgKGFwcGVuZCA9PT0gMCkge1xuICAgICAgICBhcHBlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kID0gYXBwZW5kWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX2luZGV4X3dyaXRlKGFwcGVuZCwgdCwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua19kb21haW5fb2ZfcnVzdFxudmFyIGNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGxvZ19zaXplX29mX2dyb3VwID0geC5sb2dfc2l6ZV9vZl9ncm91cDtcbiAgICB2YXIgZ3JvdXBfZ2VuID0geC5ncm91cF9nZW47XG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCBsb2dfc2l6ZV9vZl9ncm91cCwgZ3JvdXBfZ2VuXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX2RvbWFpbl90b19ydXN0XG4vLyBSZXF1aXJlczogZnJlZV9vbl9maW5hbGl6ZVxudmFyIGNhbWxfcGxvbmtfZG9tYWluX3RvX3J1c3QgPSBmdW5jdGlvbih4LCBrbGFzcykge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgZ2V0cyBmaW5hbGl6ZWRcbiAgICByZXR1cm4gbmV3IGtsYXNzKHhbMV0sIHhbMl0pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbSwganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yLCBwbG9ua193YXNtXG52YXIgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgsIGFmZmluZV9rbGFzcykge1xuICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24ocG9seV9jb21tKSB7XG4gICAgICAgIHJldHVybiBjYW1sX3BvbHlfY29tbV9vZl9ydXN0X3BvbHlfY29tbShwb2x5X2NvbW0sIGFmZmluZV9rbGFzcywgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvLyB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24oY29tbXMpIHtcbiAgICAvLyAgICAgdmFyIG4gPSBjb21tcy5sZW5ndGg7XG4gICAgLy8gICAgIHZhciByZXMgPSBuZXcgQXJyYXkobi0xKTtcbiAgICAvLyAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAvLyAgICAgICAgIHJlc1tpLTFdID0gY29udmVydChjb21tc1tpXSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvcihyZXMpO1xuICAgIC8vICAgfTtcblxuICAgIC8vIHNob3VsZCBiZSBpbnZlcnNlIG9mIHRoZSBhYm92ZSBeXG4gICAgLy8gVE9ETzogbWFrZSB3b3JrIGZvciBib3RoIFdhc20uLlBvbHlDb21tIHR5cGVzXG4gICAgdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uKGNvbW1zKSB7XG4gICAgICAgIGNvbW1zID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKGNvbW1zLCBwbG9ua193YXNtLldhc21GcVBvbHlDb21tKTtcbiAgICAgICAgLy8gY29tbXMgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IoY29tbXMsIHBsb25rX3dhc20uV2FzbUZwUG9seUNvbW0pO1xuICAgICAgICByZXR1cm4gWzBdLmNvbmNhdChjb21tcy5tYXAoY29udmVydCkpO1xuICAgIH07XG5cbiAgICB2YXIgc2lnbWFfY29tbSA9IGNvbnZlcnRBcnJheSh4LnNpZ21hX2NvbW0pO1xuICAgIHZhciBjb2VmZmljaWVudHNfY29tbSA9IGNvbnZlcnRBcnJheSh4LmNvZWZmaWNpZW50c19jb21tKTtcbiAgICB2YXIgZ2VuZXJpY19jb21tID0gY29udmVydCh4LmdlbmVyaWNfY29tbSk7XG4gICAgdmFyIHBzbV9jb21tID0gY29udmVydCh4LnBzbV9jb21tKTtcbiAgICB2YXIgY29tcGxldGVfYWRkX2NvbW0gPSBjb252ZXJ0KHguY29tcGxldGVfYWRkX2NvbW0pO1xuICAgIHZhciBtdWxfY29tbSA9IGNvbnZlcnQoeC5tdWxfY29tbSk7XG4gICAgdmFyIGVtdWxfY29tbSA9IGNvbnZlcnQoeC5lbXVsX2NvbW0pO1xuICAgIHZhciBlbmRvbXVsX3NjYWxhcl9jb21tID0gY29udmVydCh4LmVuZG9tdWxfc2NhbGFyX2NvbW0pO1xuXG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFsgMFxuICAgICAgLCBzaWdtYV9jb21tXG4gICAgICAsIGNvZWZmaWNpZW50c19jb21tXG4gICAgICAsIGdlbmVyaWNfY29tbVxuICAgICAgLCBwc21fY29tbVxuICAgICAgLCBjb21wbGV0ZV9hZGRfY29tbVxuICAgICAgLCBtdWxfY29tbVxuICAgICAgLCBlbXVsX2NvbW1cbiAgICAgICwgZW5kb211bF9zY2FsYXJfY29tbVxuICAgICAgLCAwIF07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wbG9ua192ZXJpZmljYXRpb25fZXZhbHNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tLCBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3JcbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc190b19ydXN0ID0gZnVuY3Rpb24oeCwga2xhc3MsIHBvbHlfY29tbV9jbGFzcywgbWtfYWZmaW5lKSB7XG4gICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbihwb2x5X2NvbW0pIHtcbiAgICAgICAgcmV0dXJuIGNhbWxfcG9seV9jb21tX3RvX3J1c3RfcG9seV9jb21tKHBvbHlfY29tbSwgcG9seV9jb21tX2NsYXNzLCBta19hZmZpbmUpO1xuICAgIH07XG5cbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24oY29tbXMpIHtcbiAgICAgIHZhciBuID0gY29tbXMubGVuZ3RoO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShuLTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICByZXNbaS0xXSA9IGNvbnZlcnQoY29tbXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvcihyZXMpO1xuICAgIH07XG5cbiAgICB2YXIgc2lnbWFfY29tbSA9IGNvbnZlcnRBcnJheSh4WzFdKTtcbiAgICB2YXIgY29lZmZpY2llbnRzX2NvbW0gPSBjb252ZXJ0QXJyYXkoeFsyXSk7XG4gICAgdmFyIGdlbmVyaWNfY29tbSA9IGNvbnZlcnQoeFszXSk7XG4gICAgdmFyIHBzbV9jb21tID0gY29udmVydCh4WzRdKTtcbiAgICB2YXIgY29tcGxldGVfYWRkX2NvbW0gPSBjb252ZXJ0KHhbNV0pO1xuICAgIHZhciBtdWxfY29tbSA9IGNvbnZlcnQoeFs2XSk7XG4gICAgdmFyIGVtdWxfY29tbSA9IGNvbnZlcnQoeFs3XSk7XG4gICAgdmFyIGVuZG9tdWxfc2NhbGFyX2NvbW0gPSBjb252ZXJ0KHhbOF0pO1xuICAgIC8vIFRPRE86IENoYWNoYVxuXG4gICAgcmV0dXJuIG5ldyBrbGFzcyhcbiAgICAgIHNpZ21hX2NvbW0sXG4gICAgICBjb2VmZmljaWVudHNfY29tbSxcbiAgICAgIGdlbmVyaWNfY29tbSxcbiAgICAgIHBzbV9jb21tLFxuICAgICAgY29tcGxldGVfYWRkX2NvbW0sXG4gICAgICBtdWxfY29tbSxcbiAgICAgIGVtdWxfY29tbSxcbiAgICAgIGVuZG9tdWxfc2NhbGFyX2NvbW0pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0XG52YXIgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHJlcyA9IFswLCB4LnMwLCB4LnMxLCB4LnMyLCB4LnMzLCB4LnM0LCB4LnM1LCB4LnM2XTsgXG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfdG9fcnVzdFxudmFyIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c190b19ydXN0ID0gZnVuY3Rpb24oeCwga2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IGtsYXNzKHhbMV0sIHhbMl0sIHhbM10sIHhbNF0sIHhbNV0sIHhbNl0sIHhbN10pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNvbHVtbl9vZl9ydXN0XG5mdW5jdGlvbiBjb2x1bW5fb2ZfcnVzdChjb2wpIHtcbiAgICAvLyB0eXBlIG5vbnJlYyBjb2x1bW4gPSBXaXRuZXNzIG9mIGludCB8IFogfCBMb29rdXBTb3J0ZWQgb2YgaW50IHwgTG9va3VwQWdncmVnIHwgTG9va3VwVGFibGUgfCBMb29rdXBLaW5kSW5kZXggb2YgaW50IHwgSW5kZXggb2YgZ2F0ZV90eXBlIHwgQ29lZmZpY2llbnQgb2YgaW50XG4gICAgdmFyIHRhZyA9IGNvbC50YWc7XG4gICAgdmFyIGdhdGVfdHlwZSA9IGNvbC5nYXRlX3R5cGU7XG4gICAgdmFyIGkgPSBjb2wuaTtcbiAgICBjb2wuZnJlZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIDA6IFt0YWcsIGldLFxuICAgICAgICAyOiBbdGFnLCBpXSxcbiAgICAgICAgNTogW3RhZywgaV0sXG4gICAgICAgIDY6IFt0YWcsIGdhdGVfdHlwZV0sXG4gICAgICAgIDc6IFt0YWcsIGldXG4gICAgfVt0YWddIHx8IHRhZztcbn1cblxuLy8gUHJvdmlkZXM6IHZhcmlhYmxlX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjb2x1bW5fb2ZfcnVzdFxuZnVuY3Rpb24gdmFyaWFibGVfb2ZfcnVzdCh2YXJpYWJsZSkge1xuICAgIC8vIGNvbCAqIHJvd1xuICAgIHZhciBjb2wgPSB2YXJpYWJsZS5jb2w7XG4gICAgdmFyIHJvdyA9IHZhcmlhYmxlLnJvdzsgLy8gMCwgMVxuICAgIHZhcmlhYmxlLmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIGNvbHVtbl9vZl9ydXN0KGNvbCksIHJvd107XG59XG5cbi8vIFByb3ZpZGVzOiBwb2xpc2hfdG9rZW5fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHZhcmlhYmxlX29mX3J1c3RcbmZ1bmN0aW9uIHBvbGlzaF90b2tlbl9vZl9ydXN0KHRva2VuKSB7XG4gICAgdmFyIHRhZyA9IHRva2VuLnRhZztcbiAgICB2YXIgaTAgPSB0b2tlbi5pMDtcbiAgICB2YXIgaTEgPSB0b2tlbi5pMTtcbiAgICB2YXIgZiA9IHRva2VuLmY7XG4gICAgdmFyIHYgPSB2YXJpYWJsZV9vZl9ydXN0KHRva2VuLnYpO1xuICAgIHRva2VuLmZyZWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICA1OiBbNSwgaTAsIGkxXSxcbiAgICAgICAgNjogWzYsIGZdLFxuICAgICAgICA3OiBbNywgdl0sXG4gICAgICAgIDk6IFs5LCBpMF0sXG4gICAgICAgIDE0OiBbMTQsIGkwXSxcbiAgICAgICAgMTY6IFsxNiwgaTBdXG4gICAgfVt0YWddIHx8IHRhZztcbn1cblxuLy8gUHJvdmlkZXM6IGluZGV4X3Rlcm1fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNvbHVtbl9vZl9ydXN0LCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIHBvbGlzaF90b2tlbl9vZl9ydXN0XG5mdW5jdGlvbiBpbmRleF90ZXJtX29mX3J1c3QodGVybSwgdG9rZW5fY2xhc3MpIHtcbiAgICAvLyBwdWIgY29sdW1uOiBXYXNtQ29sdW1uLFxuICAgIC8vIHB1YiBjb2VmZmljaWVudDogV2FzbVZlY3RvcjxXYXNtUG9saXNoVG9rZW4+LFxuICAgIHZhciBjb2x1bW4gPSBjb2x1bW5fb2ZfcnVzdCh0ZXJtLmNvbHVtbik7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKHRlcm0uY29lZmZpY2llbnQsIHRva2VuX2NsYXNzKTtcbiAgICBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50Lm1hcChwb2xpc2hfdG9rZW5fb2ZfcnVzdClcbiAgICBjb2VmZmljaWVudCA9IFswXS5jb25jYXQoY29lZmZpY2llbnQpO1xuICAgIHRlcm0uZnJlZSgpO1xuICAgIHJldHVybiBbMCwgY29sdW1uLCBjb2VmZmljaWVudF07XG59XG5cbi8vIFByb3ZpZGVzOiB3cmFwXG5mdW5jdGlvbiB3cmFwKHB0ciwga2xhc3MpIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShrbGFzcy5wcm90b3R5cGUpO1xuICAgIG9iai5wdHIgPSBwdHI7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuLy8gUHJvdmlkZXM6IGxpbmVhcml6YXRpb25fb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgcG9saXNoX3Rva2VuX29mX3J1c3QsIHdyYXAsIGluZGV4X3Rlcm1fb2ZfcnVzdFxuZnVuY3Rpb24gbGluZWFyaXphdGlvbl9vZl9ydXN0KGxpbmVhcml6YXRpb24sIGFmZmluZV9jbGFzcykge1xuICAgIHZhciBGID0gYWZmaW5lX2NsYXNzID09PSBwbG9ua193YXNtLldhc21HVmVzdGEgPyAnRnEnIDogJ0ZwJztcbiAgICB2YXIgV2FzbVBvbGlzaFRva2VuID0gcGxvbmtfd2FzbVsnV2FzbScgKyBGICsgJ1BvbGlzaFRva2VuJ107XG4gICAgdmFyIFdhc21JbmRleFRlcm0gPSBwbG9ua193YXNtWydXYXNtJyArIEYgKyAnSW5kZXhUZXJtJ107XG4gICAgXG4gICAgdmFyIGNvbnN0YW50X3Rlcm0gPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IobGluZWFyaXphdGlvbi5jb25zdGFudF90ZXJtLCBXYXNtUG9saXNoVG9rZW4pO1xuICAgIGNvbnN0YW50X3Rlcm0gPSBjb25zdGFudF90ZXJtLm1hcChwb2xpc2hfdG9rZW5fb2ZfcnVzdClcbiAgICBjb25zdGFudF90ZXJtID0gWzBdLmNvbmNhdChjb25zdGFudF90ZXJtKTtcbiAgICBcbiAgICB2YXIgaW5kZXhfdGVybXMgPSBBcnJheS5mcm9tKGxpbmVhcml6YXRpb24uaW5kZXhfdGVybXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHB0cikge1xuICAgICAgICAgICAgdmFyIHdhc21JbmRleFRlcm0gPSB3cmFwKHB0ciwgV2FzbUluZGV4VGVybSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhfdGVybV9vZl9ydXN0KHdhc21JbmRleFRlcm0sIFdhc21Qb2xpc2hUb2tlbik7XG4gICAgICAgIH0pO1xuICAgIGluZGV4X3Rlcm1zID0gWzBdLmNvbmNhdChpbmRleF90ZXJtcyk7XG4gICAgXG4gICAgbGluZWFyaXphdGlvbi5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCBjb25zdGFudF90ZXJtLCBpbmRleF90ZXJtc107XG59XG5cbi8vIFByb3ZpZGVzOiBOb25lXG52YXIgTm9uZSA9IDA7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBsaW5lYXJpemF0aW9uX29mX3J1c3QsIGNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QsIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX29mX3J1c3QsIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0LCBmcmVlX29uX2ZpbmFsaXplLCBOb25lXG52YXIgY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0ID0gZnVuY3Rpb24oeCwgYWZmaW5lX2NsYXNzKSB7XG4gICAgdmFyIGRvbWFpbiA9IGNhbWxfcGxvbmtfZG9tYWluX29mX3J1c3QoeC5kb21haW4pO1xuICAgIHZhciBtYXhfcG9seV9zaXplID0geC5tYXhfcG9seV9zaXplO1xuICAgIHZhciBtYXhfcXVvdF9zaXplID0geC5tYXhfcXVvdF9zaXplO1xuICAgIHZhciBzcnMgPSBmcmVlX29uX2ZpbmFsaXplKHguc3JzKTtcbiAgICB2YXIgZXZhbHMgPSBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc19vZl9ydXN0KHguZXZhbHMsIGFmZmluZV9jbGFzcyk7XG4gICAgdmFyIHNoaWZ0cyA9IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0KHguc2hpZnRzKTtcbiAgICAvLyBUT0RPOiBIYW5kbGUgbGluZWFyaXphdGlvbiBjb3JyZWN0bHkhXG4gICAgLy8gdmFyIGxpbmVhcml6YXRpb24gPSBsaW5lYXJpemF0aW9uX29mX3J1c3QoeC5saW5lYXJpemF0aW9uLCBhZmZpbmVfY2xhc3MpO1xuICAgIHZhciBsb29rdXBfaW5kZXggPSBOb25lO1xuICAgIHguZnJlZSgpO1xuICAgIHJldHVybiBbMCwgZG9tYWluLCBtYXhfcG9seV9zaXplLCBtYXhfcXVvdF9zaXplLCBzcnMsIGV2YWxzLCBzaGlmdHMsIE5vbmVdO1xufTtcbi8vIFByb3ZpZGVzOiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3Bsb25rX2RvbWFpbl90b19ydXN0LCBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9ldmFsc190b19ydXN0LCBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfdG9fcnVzdCwgZnJlZV9maW5hbGl6YXRpb25fcmVnaXN0cnlcbnZhciBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QgPSBmdW5jdGlvbih4LCBrbGFzcywgZG9tYWluX2NsYXNzLCB2ZXJpZmljYXRpb25fZXZhbHNfY2xhc3MsIHBvbHlfY29tbV9jbGFzcywgbWtfYWZmaW5lLCB2ZXJpZmljYXRpb25fc2hpZnRzX2NsYXNzKSB7XG4gICAgdmFyIGRvbWFpbiA9IGNhbWxfcGxvbmtfZG9tYWluX3RvX3J1c3QoeFsxXSwgZG9tYWluX2NsYXNzKTtcbiAgICB2YXIgbWF4X3BvbHlfc2l6ZSA9IHhbMl07XG4gICAgdmFyIG1heF9xdW90X3NpemUgPSB4WzNdO1xuICAgIHZhciBzcnMgPSB4WzRdO1xuICAgIHZhciBldmFscyA9IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX2V2YWxzX3RvX3J1c3QoeFs1XSwgdmVyaWZpY2F0aW9uX2V2YWxzX2NsYXNzLCBwb2x5X2NvbW1fY2xhc3MsIG1rX2FmZmluZSk7XG4gICAgdmFyIHNoaWZ0cyA9IGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c190b19ydXN0KHhbNl0sIHZlcmlmaWNhdGlvbl9zaGlmdHNfY2xhc3MpO1xuICAgIHJldHVybiBuZXcga2xhc3MoZG9tYWluLCBtYXhfcG9seV9zaXplLCBtYXhfcXVvdF9zaXplLCBzcnMsIGV2YWxzLCBzaGlmdHMpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QoeCwgcGxvbmtfd2FzbS5XYXNtR1Zlc3RhKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh4LCBwbG9ua193YXNtLldhc21GcFBsb25rVmVyaWZpZXJJbmRleCwgcGxvbmtfd2FzbS5XYXNtRnBEb21haW4sIHBsb25rX3dhc20uV2FzbUZwUGxvbmtWZXJpZmljYXRpb25FdmFscywgcGxvbmtfd2FzbS5XYXNtRnBQb2x5Q29tbSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUsIHBsb25rX3dhc20uV2FzbUZwU2hpZnRzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2NyZWF0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciB2ayA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGUoeCk7XG4gICAgdmFyIHZrX2NhbWwgPSBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QodmspO1xuICAgIHJldHVybiB2a19jYW1sO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfcmVhZFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCB1cnMsIHBhdGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXRbMV07XG4gICAgfVxuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWQob2Zmc2V0LCB1cnMsIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKSk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3dyaXRlID0gZnVuY3Rpb24gKGFwcGVuZCwgdCwgcGF0aCkge1xuICAgIGlmIChhcHBlbmQgPT09IDApIHtcbiAgICAgICAgYXBwZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZShhcHBlbmQsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh0KSwgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyA9IGZ1bmN0aW9uKGxvZzJfc2l6ZSkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWNhdGlvbl9zaGlmdHNfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfc2hpZnRzKGxvZzJfc2l6ZSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlcyA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teSgpO1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocmVzKTtcbiAgICAvLyByZXR1cm4gY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teSgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdCwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHkgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZGVlcF9jb3B5KGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCh4KSkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QoeCwgcGxvbmtfd2FzbS5XYXNtR1BhbGxhcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjYW1sX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoeCwgcGxvbmtfd2FzbS5XYXNtRnFQbG9ua1ZlcmlmaWVySW5kZXgsIHBsb25rX3dhc20uV2FzbUZxRG9tYWluLCBwbG9ua193YXNtLldhc21GcVBsb25rVmVyaWZpY2F0aW9uRXZhbHMsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0sIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSwgcGxvbmtfd2FzbS5XYXNtRnFTaGlmdHMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9jcmVhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfY3JlYXRlKHgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3JlYWRcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgdXJzLCBwYXRoKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICBvZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9yZWFkKG9mZnNldCwgdXJzLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKSkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF93cml0ZSA9IGZ1bmN0aW9uIChhcHBlbmQsIHQsIHBhdGgpIHtcbiAgICBpZiAoYXBwZW5kID09PSAwKSB7XG4gICAgICAgIGFwcGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQgPSBhcHBlbmRbMV07XG4gICAgfVxuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfd3JpdGUoYXBwZW5kLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QodCksIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0c1xuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGxvbmtfdmVyaWZpY2F0aW9uX3NoaWZ0c19vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9zaGlmdHMgPSBmdW5jdGlvbihsb2cyX3NpemUpIHtcbiAgICByZXR1cm4gY2FtbF9wbG9ua192ZXJpZmljYXRpb25fc2hpZnRzX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3NoaWZ0cyhsb2cyX3NpemUpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9kdW1teSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X2RlZXBfY29weSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF9kZWVwX2NvcHkoY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KHgpKSk7XG59O1xuXG5cbi8vIFByb3ZpZGVzOiBDT0xVTU5TXG52YXIgQ09MVU1OUyA9IDE1O1xuLy8gUHJvdmlkZXM6IFBFUk1VVFNfTUlOVVNfMVxudmFyIFBFUk1VVFNfTUlOVVNfMSA9IDY7XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0LCBQRVJNVVRTX01JTlVTXzEsIENPTFVNTlNcbnZhciBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHcgPSBuZXcgcGxvbmtfd2FzbS5XYXNtVmVjVmVjRnAoQ09MVU1OUyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDT0xVTU5TOyArK2kpIHtcbiAgICAgIHcucHVzaChjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHhbMV1baSArIDFdKSk7XG4gICAgfVxuXG4gICAgdmFyIHogPSBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHhbMl0pO1xuXG4gICAgdmFyIHMgPSBuZXcgcGxvbmtfd2FzbS5XYXNtVmVjVmVjRnAoUEVSTVVUU19NSU5VU18xKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgUEVSTVVUU19NSU5VU18xOyArK2kpIHtcbiAgICAgIHMucHVzaChjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHhbM11baSArIDFdKSk7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyaWNfc2VsZWN0b3IgPSBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHhbNF0pO1xuICAgIHZhciBwb3NlaWRvbl9zZWxlY3RvciA9IGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QoeFs1XSk7XG5cbiAgICByZXR1cm4gbmV3IHBsb25rX3dhc20uV2FzbUZwUHJvb2ZFdmFsdWF0aW9ucyh3LCB6LCBzLCBnZW5lcmljX3NlbGVjdG9yLCBwb3NlaWRvbl9zZWxlY3Rvcik7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCwgQ09MVU1OUywgUEVSTVVUU19NSU5VU18xXG52YXIgY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbih2LCBuKSB7XG4gICAgICAgIHZhciByZXMgPSBbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0KHYuZ2V0KGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgdmFyIHcgPSBjb252ZXJ0QXJyYXkoeC53LCBDT0xVTU5TKTtcbiAgICB2YXIgeiA9IGNhbWxfZnBfdmVjdG9yX29mX3J1c3QoeC56KTtcbiAgICB2YXIgcyA9IGNvbnZlcnRBcnJheSh4LnMsIFBFUk1VVFNfTUlOVVNfMSk7XG4gICAgdmFyIGdlbmVyaWNfc2VsZWN0b3IgPSBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0KHguZ2VuZXJpY19zZWxlY3Rvcik7XG4gICAgdmFyIHBvc2VpZG9uX3NlbGVjdG9yID0gY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCh4LnBvc2VpZG9uX3NlbGVjdG9yKTtcblxuICAgIHguZnJlZSgpO1xuICAgIHJldHVybiBbMCwgdywgeiwgcywgZ2VuZXJpY19zZWxlY3RvciwgcG9zZWlkb25fc2VsZWN0b3JdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl90b19ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmVcbnZhciBjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2ZfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29udmVydF9hZmZpbmVzID0gZnVuY3Rpb24oYWZmaW5lcykge1xuICAgICAgICByZXR1cm4gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihhZmZpbmVzLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIH1cbiAgICB2YXIgbHIgPSB4WzFdO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHhbMl0sIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKTtcbiAgICB2YXIgejEgPSB4WzNdO1xuICAgIHZhciB6MiA9IHhbNF07XG4gICAgdmFyIHNnID0gcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUoeFs1XSwgcGxvbmtfd2FzbS5jYW1sX3Zlc3RhX2FmZmluZV9vbmUpO1xuICAgIHZhciBsZW4gPSBsci5sZW5ndGg7XG4gICAgLy8gV2UgcGFzcyBsIGFuZCByIGFzIHNlcGFyYXRlIHZlY3RvcnMgb3ZlciB0aGUgRkZJXG4gICAgdmFyIGxfb2NhbWwgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgcl9vY2FtbCA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbF9vY2FtbFtpXSA9IGxyW2ldWzFdO1xuICAgICAgICByX29jYW1sW2ldID0gbHJbaV1bMl07XG4gICAgfVxuICAgIHZhciBsID0gY29udmVydF9hZmZpbmVzKGxfb2NhbWwpO1xuICAgIHZhciByID0gY29udmVydF9hZmZpbmVzKHJfb2NhbWwpO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnBPcGVuaW5nUHJvb2YobCwgciwgZGVsdGEsIHoxLCB6Miwgc2cpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmVcbnZhciBjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29udmVydF9hZmZpbmVzID0gZnVuY3Rpb24oYWZmaW5lcykge1xuICAgICAgICByZXR1cm4gY2FtbF9hcnJheV9vZl9ydXN0X3ZlY3RvcihhZmZpbmVzLCBwbG9ua193YXNtLldhc21HVmVzdGEsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lLCBmYWxzZSk7XG4gICAgfVxuICAgIHZhciBsID0gY29udmVydF9hZmZpbmVzKHgubHJfMCk7XG4gICAgdmFyIHIgPSBjb252ZXJ0X2FmZmluZXMoeC5scl8xKTtcbiAgICB2YXIgZGVsdGEgPSBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSh4LmRlbHRhKTtcbiAgICB2YXIgejEgPSB4LnoxO1xuICAgIHZhciB6MiA9IHguejI7XG4gICAgdmFyIHNnID0gcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUoeC5zZyk7XG4gICAgeC5mcmVlKCk7XG4gICAgdmFyIGxlbiA9IGwubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IHIubGVuZ3RoKSB7IHRocm93IG5ldyBFcnJvcihcImwgYW5kIHIgbGVuZ3RocyBkb24ndCBtYXRjaFwiKTsgfVxuICAgIHZhciBsciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGxyWzBdID0gMDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0dXBsZSA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgdHVwbGVbMF0gPSAwO1xuICAgICAgICB0dXBsZVsxXSA9IGxbaV07XG4gICAgICAgIHR1cGxlWzJdID0gcltpXTtcbiAgICAgICAgbHJbaV0gPSB0dXBsZTtcbiAgICB9XG4gICAgcmV0dXJuIFswLCBsciwgZGVsdGEsIHoxLCB6Miwgc2ddO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgbiA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QodltpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbmVlZCB0byBkbyBmaW5hbGl6ZXIgdGhpbmdzP1xuICAgICAgICByZXR1cm4ganNfY2xhc3NfdmVjdG9yX3RvX3J1c3RfdmVjdG9yKHJlcyk7XG4gICAgfTtcblxuICAgIHZhciB3X2NvbW0gPSBjb252ZXJ0QXJyYXkoeFsxXSk7XG4gICAgdmFyIHpfY29tbSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QoeFsyXSk7XG4gICAgdmFyIHRfY29tbSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QoeFszXSk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcFByb3ZlckNvbW1pdG1lbnRzKHdfY29tbSwgel9jb21tLCB0X2NvbW0pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3RvciwgcGxvbmtfd2FzbVxudmFyIGNhbWxfcGFzdGFfZnBfY29tbWl0bWVudHNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29udmVydEFycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgYSA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih2LCBwbG9ua193YXNtLldhc21GcFBvbHlDb21tKTtcbiAgICAgICAgdmFyIHJlcyA9IFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIENoZWNrIHRoaXMuIENvdWxkIGJlIG9mZiBieSAxXG4gICAgICAgICAgICByZXMucHVzaChjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KGFbaV0pKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciB3X2NvbW0gPSBjb252ZXJ0QXJyYXkoeC53X2NvbW0pO1xuICAgIHZhciB6X2NvbW0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV9vZl9ydXN0KHguel9jb21tKTtcbiAgICB2YXIgdF9jb21tID0gY2FtbF92ZXN0YV9wb2x5X2NvbW1fb2ZfcnVzdCh4LnRfY29tbSk7XG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCB3X2NvbW0sIHpfY29tbSwgdF9jb21tXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX3RvX3J1c3QsIGNhbWxfZnBfdmVjdG9yX3RvX3J1c3QsIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgY29tbWl0bWVudHMgPSBjYW1sX3Bhc3RhX2ZwX2NvbW1pdG1lbnRzX3RvX3J1c3QoeFsxXSk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcF9vcGVuaW5nX3Byb29mX3RvX3J1c3QoeFsyXSk7XG4gICAgdmFyIGV2YWxzMCA9IGNhbWxfcGFzdGFfZnBfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCh4WzNdWzFdKTtcbiAgICB2YXIgZXZhbHMxID0gY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0KHhbM11bMl0pO1xuICAgIHZhciBmdF9ldmFsMSA9IHhbNF07XG4gICAgdmFyIHB1YmxpY18gPSBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KHhbNV0pO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXMgPSB4WzZdO1xuICAgIHZhciBjaGFsc19sZW4gPSBwcmV2X2NoYWxsZW5nZXMubGVuZ3RoO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcChjaGFsc19sZW4gLSAxKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0gbmV3IEFycmF5KGNoYWxzX2xlbi0xKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoYWxzX2xlbjsgaSsrKSB7XG4gICAgICAgIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzLnB1c2goY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXNbaV1bMV0pKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzX2NvbW1zW2ktMV0gPSBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0KHByZXZfY2hhbGxlbmdlc1tpXVsyXSk7XG4gICAgfVxuICAgIHByZXZfY2hhbGxlbmdlc19jb21tcyA9IGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvcihwcmV2X2NoYWxsZW5nZXNfY29tbXMpO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnBQcm92ZXJQcm9vZihjb21taXRtZW50cywgcHJvb2YsIGV2YWxzMCwgZXZhbHMxLCBmdF9ldmFsMSwgcHVibGljXywgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMsIHByZXZfY2hhbGxlbmdlc19jb21tcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wcm9vZl9vZl9ydXN0XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0LCBjYW1sX3Bhc3RhX2ZwX29wZW5pbmdfcHJvb2Zfb2ZfcnVzdCwgY2FtbF9wYXN0YV9mcF9wcm9vZl9ldmFsdWF0aW9uc19vZl9ydXN0LCBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0LCBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IsIGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIG1lc3NhZ2VzID0gY2FtbF9wYXN0YV9mcF9jb21taXRtZW50c19vZl9ydXN0KHguY29tbWl0bWVudHMpO1xuICAgIHZhciBwcm9vZiA9IGNhbWxfcGFzdGFfZnBfb3BlbmluZ19wcm9vZl9vZl9ydXN0KHgucHJvb2YpO1xuICAgIHZhciBldmFsczAgPSBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QoeC5ldmFsczApO1xuICAgIHZhciBldmFsczEgPSBjYW1sX3Bhc3RhX2ZwX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QoeC5ldmFsczEpO1xuICAgIHZhciBmdF9ldmFsMSA9IHguZnRfZXZhbDE7XG4gICAgdmFyIHB1YmxpY18gPSBjYW1sX2ZwX3ZlY3Rvcl9vZl9ydXN0KHgucHVibGljXyk7XG4gICAgdmFyIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzID0geC5wcmV2X2NoYWxsZW5nZXNfc2NhbGFycztcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0ganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yKHgucHJldl9jaGFsbGVuZ2VzX2NvbW1zLCBwbG9ua193YXNtLldhc21GcFBvbHlDb21tKTtcbiAgICB2YXIgY2hhbHNfbGVuID0gcHJldl9jaGFsbGVuZ2VzX2NvbW1zLmxlbmd0aDtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzID0gbmV3IEFycmF5KGNoYWxzX2xlbik7XG4gICAgcHJldl9jaGFsbGVuZ2VzWzBdID0gMDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoYWxzX2xlbjsgaSsrKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgIHJlc1swXSA9IDA7XG4gICAgICAgIHJlc1sxXSA9IGNhbWxfZnBfdmVjdG9yX29mX3J1c3QocHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMuZ2V0KGktMSkpO1xuICAgICAgICAvLyBUT0RPIENoZWNrIHRoaXMuIENvdWxkIGJlIG9mZiBieSAxXG4gICAgICAgIHJlc1syXSA9IGNhbWxfdmVzdGFfcG9seV9jb21tX29mX3J1c3QocHJldl9jaGFsbGVuZ2VzX2NvbW1zW2ldKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzW2ldID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIG1lc3NhZ2VzLCBwcm9vZiwgWzAsIGV2YWxzMCwgZXZhbHMxXSwgZnRfZXZhbDEsIHB1YmxpY18sIHByZXZfY2hhbGxlbmdlc107XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0LCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZSwgY2FtbF9wYXN0YV9mcF9wcm9vZl9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9jcmVhdGUgPSBmdW5jdGlvbihpbmRleCwgd2l0bmVzc19jb2xzLCBwcmV2X2NoYWxsZW5nZXMsIHByZXZfc2dzKSB7XG4gICAgdmFyIHcgPSBuZXcgcGxvbmtfd2FzbS5XYXNtVmVjVmVjRnAod2l0bmVzc19jb2xzLmxlbmd0aC0xKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHdpdG5lc3NfY29scy5sZW5ndGg7IGkrKykge1xuICAgICAgdy5wdXNoKGNhbWxfZnBfdmVjdG9yX3RvX3J1c3Qod2l0bmVzc19jb2xzW2ldKSk7XG4gICAgfVxuICAgIHdpdG5lc3NfY29scyA9IHc7XG4gICAgcHJldl9jaGFsbGVuZ2VzID0gY2FtbF9mcF92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXMpO1xuICAgIHByZXZfc2dzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihwcmV2X3NncywgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIHBsb25rX3dhc20uY2FtbF92ZXN0YV9hZmZpbmVfb25lKTtcbiAgICB2YXIgcmVzID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2NyZWF0ZShpbmRleCwgd2l0bmVzc19jb2xzLCBwcmV2X2NoYWxsZW5nZXMsIHByZXZfc2dzKTtcbiAgICB2YXIgcHJvb2YgPSBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QocmVzKTtcbiAgICByZXR1cm4gcHJvb2Y7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl92ZXJpZnlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBjYW1sX3Zlc3RhX3BvbHlfY29tbV90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfdmVyaWZ5ID0gZnVuY3Rpb24oaW5kZXgsIHByb29mKSB7XG4gICAgaW5kZXggPSBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoaW5kZXgpO1xuICAgIHByb29mID0gY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0KHByb29mKTtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX3ZlcmlmeShpbmRleCwgcHJvb2YpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF92ZXN0YV9wb2x5X2NvbW1fdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2JhdGNoX3ZlcmlmeSA9IGZ1bmN0aW9uKGluZGV4ZXMsIHByb29mcykge1xuICAgIGluZGV4ZXMgPSBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGluZGV4ZXMsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCk7XG4gICAgcHJvb2ZzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3Rvcihwcm9vZnMsIGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdCk7XG4gICAgcmV0dXJuIHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnkoaW5kZXhlcywgcHJvb2ZzKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2R1bW15XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcF9wcm9vZl9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcF9wbG9ua19wcm9vZl9kdW1teSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0LCBjYW1sX3Bhc3RhX2ZwX3Byb29mX29mX3J1c3RcbnZhciBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3Byb29mX2RlZXBfY29weSA9IGZ1bmN0aW9uKHByb29mKSB7XG4gICAgcmV0dXJuIGNhbWxfcGFzdGFfZnBfcHJvb2Zfb2ZfcnVzdChwbG9ua193YXNtLmNhbWxfcGFzdGFfZnBfcGxvbmtfcHJvb2ZfZGVlcF9jb3B5KGNhbWxfcGFzdGFfZnBfcHJvb2ZfdG9fcnVzdChwcm9vZikpKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QsIFBFUk1VVFNfTUlOVVNfMSwgQ09MVU1OU1xudmFyIGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgdyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcShDT0xVTU5TKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENPTFVNTlM7ICsraSkge1xuICAgICAgdy5wdXNoKGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoeFsxXVtpICsgMV0pKTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoeFsyXSk7XG5cbiAgICB2YXIgcyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcShQRVJNVVRTX01JTlVTXzEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBQRVJNVVRTX01JTlVTXzE7ICsraSkge1xuICAgICAgcy5wdXNoKGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoeFszXVtpICsgMV0pKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJpY19zZWxlY3RvciA9IGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QoeFs0XSk7XG4gICAgdmFyIHBvc2VpZG9uX3NlbGVjdG9yID0gY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCh4WzVdKTtcblxuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnFQcm9vZkV2YWx1YXRpb25zKHcsIHosIHMsIGdlbmVyaWNfc2VsZWN0b3IsIHBvc2VpZG9uX3NlbGVjdG9yKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0LCBDT0xVTU5TLCBQRVJNVVRTX01JTlVTXzFcbnZhciBjYW1sX3Bhc3RhX2ZxX3Byb29mX2V2YWx1YXRpb25zX29mX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGNhbWxfZnFfdmVjdG9yX29mX3J1c3Qodi5nZXQoaSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICB2YXIgdyA9IGNvbnZlcnRBcnJheSh4LncsIENPTFVNTlMpO1xuICAgIHZhciB6ID0gY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCh4LnopO1xuICAgIHZhciBzID0gY29udmVydEFycmF5KHgucywgUEVSTVVUU19NSU5VU18xKTtcbiAgICB2YXIgZ2VuZXJpY19zZWxlY3RvciA9IGNhbWxfZnFfdmVjdG9yX29mX3J1c3QoeC5nZW5lcmljX3NlbGVjdG9yKTtcbiAgICB2YXIgcG9zZWlkb25fc2VsZWN0b3IgPSBjYW1sX2ZxX3ZlY3Rvcl9vZl9ydXN0KHgucG9zZWlkb25fc2VsZWN0b3IpO1xuXG4gICAgeC5mcmVlKCk7XG4gICAgcmV0dXJuIFswLCB3LCB6LCBzLCBnZW5lcmljX3NlbGVjdG9yLCBwb3NlaWRvbl9zZWxlY3Rvcl07XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV9vZl9jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl90b19ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0X2FmZmluZXMgPSBmdW5jdGlvbihhZmZpbmVzKSB7XG4gICAgICAgIHJldHVybiBjYW1sX2FycmF5X3RvX3J1c3RfdmVjdG9yKGFmZmluZXMsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xuICAgIH1cbiAgICB2YXIgbHIgPSB4WzFdO1xuICAgIHZhciBkZWx0YSA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHhbMl0sIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIHoxID0geFszXTtcbiAgICB2YXIgejIgPSB4WzRdO1xuICAgIHZhciBzZyA9IHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lKHhbNV0sIHBsb25rX3dhc20uY2FtbF9wYWxsYXNfYWZmaW5lX29uZSk7XG4gICAgdmFyIGxlbiA9IGxyLmxlbmd0aDtcbiAgICAvLyBXZSBwYXNzIGwgYW5kIHIgYXMgc2VwYXJhdGUgdmVjdG9ycyBvdmVyIHRoZSBGRklcbiAgICB2YXIgbF9vY2FtbCA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciByX29jYW1sID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsX29jYW1sW2ldID0gbHJbaV1bMV07XG4gICAgICAgIHJfb2NhbWxbaV0gPSBscltpXVsyXTtcbiAgICB9XG4gICAgdmFyIGwgPSBjb252ZXJ0X2FmZmluZXMobF9vY2FtbCk7XG4gICAgdmFyIHIgPSBjb252ZXJ0X2FmZmluZXMocl9vY2FtbCk7XG4gICAgcmV0dXJuIG5ldyBwbG9ua193YXNtLldhc21GcU9wZW5pbmdQcm9vZihsLCByLCBkZWx0YSwgejEsIHoyLCBzZyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yLCBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZVxudmFyIGNhbWxfcGFzdGFfZnFfb3BlbmluZ19wcm9vZl9vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0X2FmZmluZXMgPSBmdW5jdGlvbihhZmZpbmVzKSB7XG4gICAgICAgIHJldHVybiBjYW1sX2FycmF5X29mX3J1c3RfdmVjdG9yKGFmZmluZXMsIHBsb25rX3dhc20uV2FzbUdQYWxsYXMsIHJ1c3RfYWZmaW5lX3RvX2NhbWxfYWZmaW5lLCBmYWxzZSk7XG4gICAgfVxuICAgIHZhciBsID0gY29udmVydF9hZmZpbmVzKHgubHJfMCk7XG4gICAgdmFyIHIgPSBjb252ZXJ0X2FmZmluZXMoeC5scl8xKTtcbiAgICB2YXIgZGVsdGEgPSBydXN0X2FmZmluZV90b19jYW1sX2FmZmluZSh4LmRlbHRhKTtcbiAgICB2YXIgejEgPSB4LnoxO1xuICAgIHZhciB6MiA9IHguejI7XG4gICAgdmFyIHNnID0gcnVzdF9hZmZpbmVfdG9fY2FtbF9hZmZpbmUoeC5zZyk7XG4gICAgeC5mcmVlKCk7XG4gICAgdmFyIGxlbiA9IGwubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IHIubGVuZ3RoKSB7IHRocm93IG5ldyBFcnJvcihcImwgYW5kIHIgbGVuZ3RocyBkb24ndCBtYXRjaFwiKTsgfVxuICAgIHZhciBsciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGxyWzBdID0gMDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0dXBsZSA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgdHVwbGVbMF0gPSAwO1xuICAgICAgICB0dXBsZVsxXSA9IGxbaV07XG4gICAgICAgIHR1cGxlWzJdID0gcltpXTtcbiAgICAgICAgbHJbaV0gPSB0dXBsZTtcbiAgICB9XG4gICAgcmV0dXJuIFswLCBsciwgZGVsdGEsIHoxLCB6Miwgc2ddO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0LCBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3JcbnZhciBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX3RvX3J1c3QgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGNvbnZlcnRBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBuID0gdi5sZW5ndGggLSAxO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHJlc1tpXSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0KHZbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IocmVzKTtcbiAgICB9O1xuXG4gICAgdmFyIHdfY29tbSA9IGNvbnZlcnRBcnJheSh4WzFdKTtcbiAgICB2YXIgel9jb21tID0gY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QoeFsyXSk7XG4gICAgdmFyIHRfY29tbSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0KHhbM10pO1xuICAgIHJldHVybiBuZXcgcGxvbmtfd2FzbS5XYXNtRnFQcm92ZXJDb21taXRtZW50cyh3X2NvbW0sIHpfY29tbSwgdF9jb21tKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdCwganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yLCBwbG9ua193YXNtXG52YXIgY2FtbF9wYXN0YV9mcV9jb21taXRtZW50c19vZl9ydXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBjb252ZXJ0QXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgYSA9IGpzX2NsYXNzX3ZlY3Rvcl9vZl9ydXN0X3ZlY3Rvcih2LCBwbG9ua193YXNtLldhc21GcVBvbHlDb21tKTtcbiAgICAgIHZhciByZXMgPSBbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgLy8gVE9ETyBDaGVjayB0aGlzLiBDb3VsZCBiZSBvZmYgYnkgMVxuICAgICAgICByZXMucHVzaChjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdChhW2ldKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciB3X2NvbW0gPSBjb252ZXJ0QXJyYXkoeC53X2NvbW0pO1xuICAgIHZhciB6X2NvbW0gPSBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdCh4LnpfY29tbSk7XG4gICAgdmFyIHRfY29tbSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KHgudF9jb21tKTtcbiAgICB4LmZyZWUoKTtcbiAgICByZXR1cm4gWzAsIHdfY29tbSwgel9jb21tLCB0X2NvbW1dO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGpzX2NsYXNzX3ZlY3Rvcl90b19ydXN0X3ZlY3RvclxudmFyIGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbWVzc2FnZXMgPSBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX3RvX3J1c3QoeFsxXSk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX3RvX3J1c3QoeFsyXSk7XG4gICAgdmFyIGV2YWxzMCA9IGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfdG9fcnVzdCh4WzNdWzFdKTtcbiAgICB2YXIgZXZhbHMxID0gY2FtbF9wYXN0YV9mcV9wcm9vZl9ldmFsdWF0aW9uc190b19ydXN0KHhbM11bMl0pO1xuICAgIHZhciBmdF9ldmFsMSA9IHhbNF07XG4gICAgdmFyIHB1YmxpY18gPSBjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KHhbNV0pO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXMgPSB4WzZdO1xuICAgIHZhciBjaGFsc19sZW4gPSBwcmV2X2NoYWxsZW5nZXMubGVuZ3RoO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfc2NhbGFycyA9IG5ldyBwbG9ua193YXNtLldhc21WZWNWZWNGcShjaGFsc19sZW4gLSAxKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX2NvbW1zID0gbmV3IEFycmF5KGNoYWxzX2xlbi0xKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoYWxzX2xlbjsgaSsrKSB7XG4gICAgICAgIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzLnB1c2goY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChwcmV2X2NoYWxsZW5nZXNbaV1bMV0pKTtcbiAgICAgICAgcHJldl9jaGFsbGVuZ2VzX2NvbW1zW2ktMV0gPSBjYW1sX3BhbGxhc19wb2x5X2NvbW1fdG9fcnVzdChwcmV2X2NoYWxsZW5nZXNbaV1bMl0pO1xuICAgIH1cbiAgICBwcmV2X2NoYWxsZW5nZXNfY29tbXMgPSBqc19jbGFzc192ZWN0b3JfdG9fcnVzdF92ZWN0b3IocHJldl9jaGFsbGVuZ2VzX2NvbW1zKTtcbiAgICByZXR1cm4gbmV3IHBsb25rX3dhc20uV2FzbUZxUHJvdmVyUHJvb2YobWVzc2FnZXMsIHByb29mLCBldmFsczAsIGV2YWxzMSwgZnRfZXZhbDEsIHB1YmxpY18sIHByZXZfY2hhbGxlbmdlc19zY2FsYXJzLCBwcmV2X2NoYWxsZW5nZXNfY29tbXMpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdFxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnFfY29tbWl0bWVudHNfb2ZfcnVzdCwgY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX29mX3J1c3QsIGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCwgY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdCwganNfY2xhc3NfdmVjdG9yX29mX3J1c3RfdmVjdG9yLCBjYW1sX3BhbGxhc19wb2x5X2NvbW1fb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbWVzc2FnZXMgPSBjYW1sX3Bhc3RhX2ZxX2NvbW1pdG1lbnRzX29mX3J1c3QoeC5jb21taXRtZW50cyk7XG4gICAgdmFyIHByb29mID0gY2FtbF9wYXN0YV9mcV9vcGVuaW5nX3Byb29mX29mX3J1c3QoeC5wcm9vZik7XG4gICAgdmFyIGV2YWxzMCA9IGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCh4LmV2YWxzMCk7XG4gICAgdmFyIGV2YWxzMSA9IGNhbWxfcGFzdGFfZnFfcHJvb2ZfZXZhbHVhdGlvbnNfb2ZfcnVzdCh4LmV2YWxzMSk7XG4gICAgdmFyIGZ0X2V2YWwxID0geC5mdF9ldmFsMTtcbiAgICB2YXIgcHVibGljXyA9IGNhbWxfZnFfdmVjdG9yX29mX3J1c3QoeC5wdWJsaWNfKTtcbiAgICB2YXIgcHJldl9jaGFsbGVuZ2VzX3NjYWxhcnMgPSB4LnByZXZfY2hhbGxlbmdlc19zY2FsYXJzO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXNfY29tbXMgPSBqc19jbGFzc192ZWN0b3Jfb2ZfcnVzdF92ZWN0b3IoeC5wcmV2X2NoYWxsZW5nZXNfY29tbXMsIHBsb25rX3dhc20uV2FzbUZxUG9seUNvbW0pO1xuICAgIHZhciBjaGFsc19sZW4gPSBwcmV2X2NoYWxsZW5nZXNfY29tbXMubGVuZ3RoO1xuICAgIHZhciBwcmV2X2NoYWxsZW5nZXMgPSBuZXcgQXJyYXkoY2hhbHNfbGVuKTtcbiAgICBwcmV2X2NoYWxsZW5nZXNbMF0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY2hhbHNfbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgcmVzWzBdID0gMDtcbiAgICAgICAgcmVzWzFdID0gY2FtbF9mcV92ZWN0b3Jfb2ZfcnVzdChwcmV2X2NoYWxsZW5nZXNfc2NhbGFycy5nZXQoaS0xKSk7XG4gICAgICAgIHJlc1syXSA9IGNhbWxfcGFsbGFzX3BvbHlfY29tbV9vZl9ydXN0KHByZXZfY2hhbGxlbmdlc19jb21tc1tpXSk7XG4gICAgICAgIHByZXZfY2hhbGxlbmdlc1tpXSA9IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIFswLCBtZXNzYWdlcywgcHJvb2YsIFswLCBldmFsczAsIGV2YWxzMV0sIGZ0X2V2YWwxLCBwdWJsaWNfLCBwcmV2X2NoYWxsZW5nZXNdO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcV92ZWN0b3JfdG9fcnVzdCwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgcnVzdF9hZmZpbmVfb2ZfY2FtbF9hZmZpbmUsIGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlID0gZnVuY3Rpb24oaW5kZXgsIHdpdG5lc3NfY29scywgcHJldl9jaGFsbGVuZ2VzLCBwcmV2X3Nncykge1xuICAgIHZhciB3ID0gbmV3IHBsb25rX3dhc20uV2FzbVZlY1ZlY0ZxKHdpdG5lc3NfY29scy5sZW5ndGgtMSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB3aXRuZXNzX2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcucHVzaChjYW1sX2ZxX3ZlY3Rvcl90b19ydXN0KHdpdG5lc3NfY29sc1tpXSkpO1xuICAgIH1cbiAgICB3aXRuZXNzX2NvbHMgPSB3O1xuICAgIHByZXZfY2hhbGxlbmdlcyA9IGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QocHJldl9jaGFsbGVuZ2VzKTtcbiAgICBwcmV2X3NncyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IocHJldl9zZ3MsIHJ1c3RfYWZmaW5lX29mX2NhbWxfYWZmaW5lLCBwbG9ua193YXNtLmNhbWxfcGFsbGFzX2FmZmluZV9vbmUpO1xuICAgIHZhciByZXMgPSBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfY3JlYXRlKGluZGV4LCB3aXRuZXNzX2NvbHMsIHByZXZfY2hhbGxlbmdlcywgcHJldl9zZ3MpO1xuICAgIHZhciBwcm9vZiA9IGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdChyZXMpO1xuICAgIHJldHVybiBwcm9vZjtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX3ZlcmlmeVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0LCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfdmVyaWZ5ID0gZnVuY3Rpb24oaW5kZXgsIHByb29mKSB7XG4gICAgaW5kZXggPSBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QoaW5kZXgpO1xuICAgIHByb29mID0gY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0KHByb29mKTtcbiAgICByZXR1cm4gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX3ZlcmlmeShpbmRleCwgcHJvb2YpO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9iYXRjaF92ZXJpZnkgPSBmdW5jdGlvbihpbmRleGVzLCBwcm9vZnMpIHtcbiAgICBpbmRleGVzID0gY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvcihpbmRleGVzLCBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QpO1xuICAgIHByb29mcyA9IGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IocHJvb2ZzLCBjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QpO1xuICAgIHJldHVybiBwbG9ua193YXNtLmNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfYmF0Y2hfdmVyaWZ5KGluZGV4ZXMsIHByb29mcyk7XG59O1xuXG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnFfcHJvb2Zfb2ZfcnVzdFxudmFyIGNhbWxfcGFzdGFfZnFfcGxvbmtfcHJvb2ZfZHVtbXkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0KHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kdW1teSgpKTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2RlZXBfY29weVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfcGFzdGFfZnFfcHJvb2ZfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl9vZl9ydXN0XG52YXIgY2FtbF9wYXN0YV9mcV9wbG9ua19wcm9vZl9kZWVwX2NvcHkgPSBmdW5jdGlvbihwcm9vZikge1xuICAgIHJldHVybiBjYW1sX3Bhc3RhX2ZxX3Byb29mX29mX3J1c3QocGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZxX3Bsb25rX3Byb29mX2RlZXBfY29weShjYW1sX3Bhc3RhX2ZxX3Byb29mX3RvX3J1c3QocHJvb2YpKSk7XG59O1xuXG5cblxuXG5cbi8vIFByb3ZpZGVzOiBjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IsIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcmFuZG9tX29yYWNsZXNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgam9pbnRfY29tYmluZXJfY2hhbCA9IHguam9pbnRfY29tYmluZXJfY2hhbDtcbiAgICB2YXIgam9pbnRfY29tYmluZXIgPSB4LmpvaW50X2NvbWJpbmVyO1xuICAgIHZhciBqb2ludF9jb21iaW5lcl9vY2FtbCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoam9pbnRfY29tYmluZXJfY2hhbCAhPT0gdW5kZWZpbmVkICYmIGpvaW50X2NvbWJpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgam9pbnRfY29tYmluZXJfb2NhbWwgPSBbMCwgWzAsIGpvaW50X2NvbWJpbmVyX2NoYWxdLCBqb2ludF9jb21iaW5lcl07XG4gICAgfVxuICAgIHJldHVybiBbMCxcbiAgICAgIGNhbWxfb3B0aW9uX29mX21heWJlX3VuZGVmaW5lZChqb2ludF9jb21iaW5lcl9vY2FtbCksXG4gICAgICB4LmJldGEsXG4gICAgICB4LmdhbW1hLFxuICAgICAgWzAsIHguYWxwaGFfY2hhbF0sXG4gICAgICB4LmFscGhhLFxuICAgICAgeC56ZXRhLFxuICAgICAgeC52LFxuICAgICAgeC51LFxuICAgICAgWzAsIHguemV0YV9jaGFsXSxcbiAgICAgIFswLCB4LnZfY2hhbF0sXG4gICAgICBbMCwgeC51X2NoYWxdXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX3JhbmRvbV9vcmFjbGVzX3RvX3J1c3Rcbi8vIFJlcXVpcmVzOiBjYW1sX3U4YXJyYXlfdmVjdG9yX3RvX3J1c3RfZmxhdF92ZWN0b3IsIGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZFxudmFyIGNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdCA9IGZ1bmN0aW9uKHgsIHJvS2xhc3MpIHtcbiAgICAvLyB2YXIgY2FtbF92ZWN0b3IgPSBbMCwgeFsxXSwgeFsyXSwgeFszXVsxXSwgeFs0XSwgeFs1XSwgeFs2XSwgeFs3XSwgeFs4XVsxXSwgeFs5XVsxXSwgeFsxMF1bMV1dO1xuICAgIHZhciBqb2ludF9jb21iaW5lcl9vY2FtbCA9IGNhbWxfb3B0aW9uX3RvX21heWJlX3VuZGVmaW5lZCh4WzFdKTtcbiAgICB2YXIgam9pbnRfY29tYmluZXJfY2hhbCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgam9pbnRfY29tYmluZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGpvaW50X2NvbWJpbmVyX29jYW1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgam9pbnRfY29tYmluZXJfY2hhbCA9IGpvaW50X2NvbWJpbmVyX29jYW1sWzFdWzFdO1xuICAgICAgICBqb2ludF9jb21iaW5lciA9IGpvaW50X2NvbWJpbmVyX29jYW1sWzJdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHJvS2xhc3MoXG4gICAgICBqb2ludF9jb21iaW5lcl9jaGFsLFxuICAgICAgam9pbnRfY29tYmluZXIsXG4gICAgICB4WzJdLFxuICAgICAgeFszXSxcbiAgICAgIHhbNF1bMV0sXG4gICAgICB4WzVdLFxuICAgICAgeFs2XSxcbiAgICAgIHhbN10sXG4gICAgICB4WzhdLFxuICAgICAgeFs5XVsxXSxcbiAgICAgIHhbMTBdWzFdLFxuICAgICAgeFsxMV1bMV0pO1xufTtcblxuLy8gUHJvdmlkZXM6IGNhbWxfb3JhY2xlc19vZl9ydXN0XG4vLyBSZXF1aXJlczogY2FtbF91OGFycmF5X3ZlY3Rvcl9vZl9ydXN0X2ZsYXRfdmVjdG9yLCBjYW1sX3JhbmRvbV9vcmFjbGVzX29mX3J1c3RcbnZhciBjYW1sX29yYWNsZXNfb2ZfcnVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gWzAsIGNhbWxfcmFuZG9tX29yYWNsZXNfb2ZfcnVzdCh4Lm8pLCBbMCwgeC5wX2V2YWwwLCB4LnBfZXZhbDFdLCBjYW1sX3U4YXJyYXlfdmVjdG9yX29mX3J1c3RfZmxhdF92ZWN0b3IoeC5vcGVuaW5nX3ByZWNoYWxsZW5nZXMsIDMyIC8qIFRPRE86IERvbid0IGhhcmRjb2RlICovKSwgeC5kaWdlc3RfYmVmb3JlX2V2YWx1YXRpb25zXTtcbn07XG5cbi8vIFByb3ZpZGVzOiBjYW1sX29yYWNsZXNfdG9fcnVzdFxuLy8gUmVxdWlyZXM6IGNhbWxfdThhcnJheV92ZWN0b3JfdG9fcnVzdF9mbGF0X3ZlY3RvciwgY2FtbF9yYW5kb21fb3JhY2xlc190b19ydXN0XG52YXIgY2FtbF9vcmFjbGVzX3RvX3J1c3QgPSBmdW5jdGlvbih4LCBrbGFzcywgcm9LbGFzcykge1xuICAgIHJldHVybiBuZXcga2xhc3MoXG4gICAgICAgIGNhbWxfcmFuZG9tX29yYWNsZXNfdG9fcnVzdCh4WzFdLCByb0tsYXNzKSxcbiAgICAgICAgeFsyXVsxXSxcbiAgICAgICAgeFsyXVsyXSxcbiAgICAgICAgY2FtbF91OGFycmF5X3ZlY3Rvcl90b19ydXN0X2ZsYXRfdmVjdG9yKHhbM10pLFxuICAgICAgICB4WzRdXG4gICAgKTtcbn07XG5cblxuXG5cblxuLy8gUHJvdmlkZXM6IGZwX29yYWNsZXNfY3JlYXRlXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcmFjbGVzX29mX3J1c3QsIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IsIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnBfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcF9wcm9vZl90b19ydXN0XG52YXIgZnBfb3JhY2xlc19jcmVhdGUgPSBmdW5jdGlvbihsZ3JfY29tbSwgdmVyaWZpZXJfaW5kZXgsIHByb29mKSB7XG4gICAgcmV0dXJuIGNhbWxfb3JhY2xlc19vZl9ydXN0KHBsb25rX3dhc20uZnBfb3JhY2xlc19jcmVhdGUoXG4gICAgICAgIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IobGdyX2NvbW0sIGNhbWxfdmVzdGFfcG9seV9jb21tX3RvX3J1c3QpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZwX3Bsb25rX3ZlcmlmaWVyX2luZGV4X3RvX3J1c3QodmVyaWZpZXJfaW5kZXgpLFxuICAgICAgICBjYW1sX3Bhc3RhX2ZwX3Byb29mX3RvX3J1c3QocHJvb2YpXG4gICAgKSk7XG59O1xuXG4vLyBQcm92aWRlczogZnBfb3JhY2xlc19kdW1teVxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfb3JhY2xlc19vZl9ydXN0XG52YXIgZnBfb3JhY2xlc19kdW1teSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX29yYWNsZXNfb2ZfcnVzdChwbG9ua193YXNtLmZwX29yYWNsZXNfZHVtbXkoKSk7XG59O1xuXG4vLyBQcm92aWRlczogZnBfb3JhY2xlc19kZWVwX2NvcHlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29yYWNsZXNfb2ZfcnVzdCwgY2FtbF9vcmFjbGVzX3RvX3J1c3RcbnZhciBmcF9vcmFjbGVzX2RlZXBfY29weSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcF9vcmFjbGVzX2RlZXBfY29weShcbiAgICAgIGNhbWxfb3JhY2xlc190b19ydXN0KHgsIHBsb25rX3dhc20uV2FzbUZwT3JhY2xlcywgcGxvbmtfd2FzbS5XYXNtRnBSYW5kb21PcmFjbGVzKSkpO1xufTtcblxuXG5cblxuXG4vLyBQcm92aWRlczogZnFfb3JhY2xlc19jcmVhdGVcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29yYWNsZXNfb2ZfcnVzdCwgY2FtbF9hcnJheV90b19ydXN0X3ZlY3RvciwgY2FtbF9wYWxsYXNfcG9seV9jb21tX3RvX3J1c3QsIGNhbWxfcGFzdGFfZnFfcGxvbmtfdmVyaWZpZXJfaW5kZXhfdG9fcnVzdCwgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0XG52YXIgZnFfb3JhY2xlc19jcmVhdGUgPSBmdW5jdGlvbihsZ3JfY29tbSwgdmVyaWZpZXJfaW5kZXgsIHByb29mKSB7XG4gICAgcmV0dXJuIGNhbWxfb3JhY2xlc19vZl9ydXN0KHBsb25rX3dhc20uZnFfb3JhY2xlc19jcmVhdGUoXG4gICAgICAgIGNhbWxfYXJyYXlfdG9fcnVzdF92ZWN0b3IobGdyX2NvbW0sIGNhbWxfcGFsbGFzX3BvbHlfY29tbV90b19ydXN0KSxcbiAgICAgICAgY2FtbF9wYXN0YV9mcV9wbG9ua192ZXJpZmllcl9pbmRleF90b19ydXN0KHZlcmlmaWVyX2luZGV4KSxcbiAgICAgICAgY2FtbF9wYXN0YV9mcV9wcm9vZl90b19ydXN0KHByb29mKVxuICAgICkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGZxX29yYWNsZXNfZHVtbXlcbi8vIFJlcXVpcmVzOiBwbG9ua193YXNtLCBjYW1sX29yYWNsZXNfb2ZfcnVzdFxudmFyIGZxX29yYWNsZXNfZHVtbXkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2FtbF9vcmFjbGVzX29mX3J1c3QocGxvbmtfd2FzbS5mcV9vcmFjbGVzX2R1bW15KCkpO1xufTtcblxuLy8gUHJvdmlkZXM6IGZxX29yYWNsZXNfZGVlcF9jb3B5XG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9vcmFjbGVzX29mX3J1c3QsIGNhbWxfb3JhY2xlc190b19ydXN0XG52YXIgZnFfb3JhY2xlc19kZWVwX2NvcHkgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGNhbWxfb3JhY2xlc19vZl9ydXN0KFxuICAgICAgcGxvbmtfd2FzbS5mcV9vcmFjbGVzX2RlZXBfY29weShcbiAgICAgICAgY2FtbF9vcmFjbGVzX3RvX3J1c3QoeCwgcGxvbmtfd2FzbS5XYXNtRnFPcmFjbGVzLCBwbG9ua193YXNtLldhc21GcVJhbmRvbU9yYWNsZXMpKSk7XG59O1xuXG5cbi8vIFRoaXMgaXMgZmFrZSAtLSBwYXJhbWV0ZXJzIGFyZSBvbmx5IG5lZWRlZCBvbiB0aGUgUnVzdCBzaWRlLCBzbyBubyBuZWVkIHRvIHJldHVybiBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcG9zZWlkb25fcGFyYW1zX2NyZWF0ZVxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9wYXJhbXNfY3JlYXRlKCkge1xuICAgIHJldHVybiBbMF07XG59XG4vLyBQcm92aWRlczogY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9wYXJhbXNfY3JlYXRlXG5mdW5jdGlvbiBjYW1sX3Bhc3RhX2ZxX3Bvc2VpZG9uX3BhcmFtc19jcmVhdGUoKSB7XG4gICAgcmV0dXJuIFswXTtcbn1cblxuLy8gUHJvdmlkZXM6IGNhbWxfcGFzdGFfZnBfcG9zZWlkb25fYmxvY2tfY2lwaGVyXG4vLyBSZXF1aXJlczogcGxvbmtfd2FzbSwgY2FtbF9mcF92ZWN0b3JfdG9fcnVzdCwgY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdFxuZnVuY3Rpb24gY2FtbF9wYXN0YV9mcF9wb3NlaWRvbl9ibG9ja19jaXBoZXIoX2Zha2VfcGFyYW1zLCBmcF92ZWN0b3IpIHtcbiAgICAvLyAxLiBnZXQgcGVybXV0ZWQgZmllbGQgdmVjdG9yIGZyb20gcnVzdFxuICAgIHZhciB3YXNtX2ZsYXRfdmVjdG9yID0gcGxvbmtfd2FzbS5jYW1sX3Bhc3RhX2ZwX3Bvc2VpZG9uX2Jsb2NrX2NpcGhlcihjYW1sX2ZwX3ZlY3Rvcl90b19ydXN0KGZwX3ZlY3RvcikpO1xuICAgIHZhciBuZXdfZnBfdmVjdG9yID0gY2FtbF9mcF92ZWN0b3Jfb2ZfcnVzdCh3YXNtX2ZsYXRfdmVjdG9yKTtcbiAgICAvLyAyLiB3cml0ZSBiYWNrIG1vZGlmaWVkIGZpZWxkIHZlY3RvciB0byBvcmlnaW5hbCBvbmVcbiAgICBuZXdfZnBfdmVjdG9yLmZvckVhY2goZnVuY3Rpb24gKGEsIGkpIHtcbiAgICAgICAgZnBfdmVjdG9yW2ldID0gYTtcbiAgICB9KTtcbn1cbi8vIFByb3ZpZGVzOiBjYW1sX3Bhc3RhX2ZxX3Bvc2VpZG9uX2Jsb2NrX2NpcGhlclxuLy8gUmVxdWlyZXM6IHBsb25rX3dhc20sIGNhbWxfZnFfdmVjdG9yX3RvX3J1c3QsIGNhbWxfZnFfdmVjdG9yX29mX3J1c3RcbmZ1bmN0aW9uIGNhbWxfcGFzdGFfZnFfcG9zZWlkb25fYmxvY2tfY2lwaGVyKF9mYWtlX3BhcmFtcywgZnFfdmVjdG9yKSB7XG4gICAgLy8gMS4gZ2V0IHBlcm11dGVkIGZpZWxkIHZlY3RvciBmcm9tIHJ1c3RcbiAgICB2YXIgd2FzbV9mbGF0X3ZlY3RvciA9IHBsb25rX3dhc20uY2FtbF9wYXN0YV9mcV9wb3NlaWRvbl9ibG9ja19jaXBoZXIoY2FtbF9mcV92ZWN0b3JfdG9fcnVzdChmcV92ZWN0b3IpKTtcbiAgICB2YXIgbmV3X2ZxX3ZlY3RvciA9IGNhbWxfZnFfdmVjdG9yX29mX3J1c3Qod2FzbV9mbGF0X3ZlY3Rvcik7XG4gICAgLy8gMi4gd3JpdGUgYmFjayBtb2RpZmllZCBmaWVsZCB2ZWN0b3IgdG8gb3JpZ2luYWwgb25lXG4gICAgbmV3X2ZxX3ZlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uIChhLCBpKSB7XG4gICAgICAgIGZxX3ZlY3RvcltpXSA9IGE7XG4gICAgfSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKXAoWystXT9bMC05XSspL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA0XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzRdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhhKSxiLGMsZCxlKTtcbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gICAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG5pZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuaWYoY2FtbF9jdXJyZW50X2Rpci5zbGljZSgtMSkgIT09IFwiL1wiKSBjYW1sX2N1cnJlbnRfZGlyICs9IFwiL1wiXG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxudmFyIGNhbWxfcm9vdCA9IGNhbWxfY3VycmVudF9kaXIubWF0Y2goL1teXFwvXSpcXC8vKVswXTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKG5hbWUuY2hhckNvZGVBdCgwKSAhPSA0NylcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogaWYobmNvbXAubGVuZ3RoID09IDApIG5jb21wLnB1c2goXCJcIik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IG5jb21wLnB1c2goY29tcFtpXSk7YnJlYWtcbiAgICB9XG4gIH1cbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QrXCJzdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCtcInN0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBuYW1lICsgXCIvXCI7XG4gIHZhciByZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmKG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT0gMFxuICAgICAgICYmICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpKVxuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGhcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYoanNvb19tb3VudF9wb2ludFtpXS5wYXRoID09IG5hbWUpIGlkeCA9IGk7XG4gIGlmKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsMSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0Y3dkKCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX2N1cnJlbnRfZGlyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2hkaXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfY2hkaXIoZGlyKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZGlyKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICBpZihyb290LnJlc3QpIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGggKyByb290LnJlc3QgKyBcIi9cIjtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoZGlyKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfYV9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9hX2RpcihuYW1lKXtcbiAgbmFtZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSk7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSlcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCkgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBjYW1sX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSA9IGNhbWxfY3JlYXRlX2ZpbGU7XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgY29udGVudCA9ICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpOmNvbnRlbnQ7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9ieXRlcyhidWYpXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAodGFnKSB7IHJldHVybiB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBhcmcpIHsgdGhyb3cgWzAsIHRhZywgYXJnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgLy9GSVhNRSwgY2FuIGhhcHBlbiB3aXRoIHRvbyBtYW55IGFyZ3VtZW50c1xuICBpZih0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZjtcbiAgdmFyIG4gPSBmLmxlbmd0aCB8IDA7XG4gIGlmKG4gPT09IDApIHJldHVybiBmLmFwcGx5KG51bGwsYXJncyk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGggfCAwO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuIHwgMDtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKSxhcmdzLnNsaWNlKG4pKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCl7XG4gICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIG5hcmdzW2FyZ3MubGVuZ3RoK2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MpXG4gICAgbiA9IGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudilcbiAgICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuYXJndlxuICAgICAmJiBnLnByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBnLnByb2Nlc3MuYXJndlxuICAgIC8vbm9kZWpzXG4gICAgbWFpbiA9IGFyZ3ZbMV07XG4gICAgYXJncyA9IGFyZ3Yuc2xpY2UoMik7XG4gIH1cblxuICB2YXIgcCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG1haW4pO1xuICB2YXIgYXJnczIgPSBbMCwgcF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YgKGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndiAoYSkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpe1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSl7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQse3N0ZGlvOiAnaW5oZXJpdCd9KTsgcmV0dXJuIDB9XG4gICAgY2F0Y2ggKGUpIHtyZXR1cm4gMX1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vd14weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4ICgpIHsgcmV0dXJuIDE7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlVuaXhcIiksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuLy9Qcm92aWRlczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoKTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKSByZXR1cm4gMVxuICB9XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSkgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9zdHJpbmcoYnVmLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBidWYsIHBvcywgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZ2V0KHRoaXMuZGF0YSwgb2Zmc2V0KTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcblxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJicm93c2VyXCIpXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnJlYWRkaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYlxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX2J5dGVzKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuV2Vha01hcCgpO1xuICB9O1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5sb29rdXAuc2V0KHYsIHRoaXMub2Jqcy5sZW5ndGgpO1xuICB0aGlzLm9ianMucHVzaCh2KTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24odikge1xuICB2YXIgaSA9IHRoaXMubG9va3VwLmdldCh2KTtcbiAgcmV0dXJuIChpID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWQgOiB0aGlzLm9ianMubGVuZ3RoIC0gaTsgICAvKiBpbmRleCBpcyByZWxhdGl2ZSAqL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA+PSA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSBmYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA8IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IHRydWVcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbnZhciBjYW1sX291dHB1dF92YWwgPSBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gV3JpdGVyICgpIHsgdGhpcy5jaHVuayA9IFtdOyB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OjIwLCBibG9ja19sZW46MCwgb2JqX2NvdW50ZXI6MCwgc2l6ZV8zMjowLCBzaXplXzY0OjAsXG4gICAgd3JpdGU6ZnVuY3Rpb24gKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9hdDpmdW5jdGlvbiAocG9zLCBzaXplLCB2YWx1ZSkge1xuICAgICAgdmFyIHBvcyA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3BvcysrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9jb2RlOmZ1bmN0aW9uIChzaXplLCBjb2RlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9IGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9zaGFyZWQ6ZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8ICgxIDw8IDgpKSB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8ICgxIDw8IDE2KSkgdGhpcy53cml0ZV9jb2RlKDE2LCAweDA1IC8qY3N0LkNPREVfU0hBUkVEMTYqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgdGhpcy53cml0ZV9jb2RlKDMyLCAweDA2IC8qY3N0LkNPREVfU0hBUkVEMzIqLywgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHBvczpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNodW5rX2lkeCB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodiwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IGNhbWxfbGlzdF90b19qc19hcnJheShmbGFncyk7XG5cbiAgICB2YXIgbm9fc2hhcmluZyA9IChmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xKSxcbiAgICAgICAgY2xvc3VyZXMgPSAgKGZsYWdzLmluZGV4T2YoMSAvKk1hcnNoYWwuQ2xvc3VyZXMqLykgIT09IC0xKTtcbiAgICAgICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIFRoaXMgY29kZSBzdXBwb3J0cyBib3RoIEFycmF5IGFuZCBNbEludDY0IGltcGxlbWVudGF0aW9ucyBvZiBpbnQ2NCBpblxuLy8ganNfb2Zfb2NhbWwgKHByZS0gdnMgcG9zdC04ODc1MDdkYjFlYjhlZmQ3NzkwNzBjYmVkYWIzNzc0MDk4YTUyOTM5KS5cbi8vXG4vLyBDb21waWxhdGlvbiBpcyBjdXJyZW50bHkgYnJva2VuIG9uIHRoZSBNbEludDY0IGltcGxlbWVudGF0aW9uLCBkdWUgdG9cbi8vIHJlbW92ZWQgaW50ZXJuYWwganNfb2Zfb2NhbWwgcHJpbWl0aXZlcy4gUmVtb3ZpbmcgdGhlc2UgKGFuZCB0aGUgQXJyYXlcbi8vIGltcGxlbWVudGF0aW9ucywgc2lnbmFsbGVkIGJ5IFtpbnN0YW5jZW9mIEFycmF5XSBjaGVja3MpIHdpbGwgY2F1c2Vcbi8vIGNvbXBpbGF0aW9uIHRvIHN1Y2NlZWQuXG4vL1xuLy8gVE9ETzogYnVpbGQtdGltZSBtYWdpYyB0byBzdHViIHRoZSB1bmF2YWlsYWJsZSBwcmltaXRpdmVzIG9uIGxhdGVyIHZlcnNpb25zLlxuXG4vL1Byb3ZpZGVzOiBVSW50MzIgY29uc3RcbnZhciBVSW50MzIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIFVJbnQzMiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHggPj4+IDA7XG4gICAgfTtcbiAgICBVSW50MzIucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJpbnRlZ2Vyczp1aW50MzJcIjtcbiAgICByZXR1cm4gVUludDMyO1xufSkoKTtcblxuLy9Qcm92aWRlczogaW50ZWdlcnNfaW50MzJfb2ZfdWludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc19pbnQzMl9vZl91aW50MzIoaSkge1xuICAgIHJldHVybiAoaS52YWx1ZSB8IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc19zaXplX3Rfc2l6ZVxuZnVuY3Rpb24gaW50ZWdlcnNfc2l6ZV90X3NpemUodW5pdCkge1xuICAgIHJldHVybiA0OyAvLyBTZXQgc2l6ZV90ID0gdTMyXG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQxNl9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQxNl9vZl9zdHJpbmcoeCkge1xuICAgIHZhciB5ID0gaW50ZWdlcnNfdWludDMyX29mX3N0cmluZyh4KTtcbiAgICByZXR1cm4gKHkudmFsdWUgJiAweEZGRkYpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfYWRkXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9hZGQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgKyB5LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3N1YlxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfc3ViKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMih4LnZhbHVlIC0geS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9kaXZcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX2Rpdih4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSAvIHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbG9nYW5kXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9sb2dhbmQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgJiB5LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX2xvZ29yXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9sb2dvcih4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoeC52YWx1ZSB8IHkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfbG9neG9yXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9sb2d4b3IoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgXiB5LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX21heFxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfbWF4KHVuaXQpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMigweEZGRkZGRkZGKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX211bFxuLy9SZXF1aXJlczogaW50ZWdlcnNfdWludDMyX3RvX2ludDY0LCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF90b19pbnQzMiwgVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfbXVsKHgsIHkpIHtcbiAgICAvLyBDb252ZXJ0IHRvIDY0LWJpdCBhbmQgY29tcHV0ZSB0aGVyZS5cbiAgICB2YXIgeF82NCA9IGludGVnZXJzX3VpbnQzMl90b19pbnQ2NCh4KTtcbiAgICB2YXIgeV82NCA9IGludGVnZXJzX3VpbnQzMl90b19pbnQ2NCh5KTtcbiAgICByZXR1cm4gbmV3IFVJbnQzMiAoY2FtbF9pbnQ2NF90b19pbnQzMihjYW1sX2ludDY0X211bCh4XzY0LCB5XzY0KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfb2ZfaW50XG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9vZl9pbnQoaSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfb2ZfaW50MzJcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX29mX2ludDMyKGkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQzMihpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX29mX2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2ludDMyLCBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9vZl9pbnQ2NChpKSB7XG4gICAgcmV0dXJuIG5ldyBVSW50MzIoY2FtbF9pbnQ2NF90b19pbnQzMihpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nLCBpbnRlZ2Vyc191aW50MzJfb2ZfaW50NjQsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfb2Zfc3RyaW5nKHMpIHtcbiAgICAvLyBUbyBtYXRjaCB0aGUgQyBpbXBsZW1lbnRhdGlvbiwgd2Ugc2hvdWxkIHBhcnNlIHRoZSBzdHJpbmcgYXMgYW4gdWludDY0XG4gICAgLy8gYW5kIHRoZW4gZG93bmNhc3QuXG4gICAgdmFyIG1heF92YWwgPSBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgweGZmZmZmZiwgMHhmZmZmZmYsIDB4ZmZmZik7XG4gICAgcmV0dXJuIGludGVnZXJzX3VpbnQzMl9vZl9pbnQ2NChpbnRlZ2Vyc191aW50X29mX3N0cmluZyhzLCBtYXhfdmFsKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9yZW1cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGUsIFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX3JlbSh4LCB5KSB7XG4gICAgaWYgKHkudmFsdWUgPT0gMCkge1xuICAgICAgICBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgJSB5LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3NoaWZ0X2xlZnRcbi8vUmVxdWlyZXM6IFVJbnQzMlxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX3NoaWZ0X2xlZnQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgPDwgeSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQzMl9zaGlmdF9yaWdodFxuLy9SZXF1aXJlczogVUludDMyXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfc2hpZnRfcmlnaHQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDMyKHgudmFsdWUgPj4+IHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfdG9faW50XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfdG9faW50KGkpIHtcbiAgICByZXR1cm4gKGkudmFsdWUgfCAwKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX3RvX2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDMyX3RvX2ludDY0KGkpIHtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoaS52YWx1ZSAmIDB4ZmZmZmZmLCAoaS52YWx1ZSA+Pj4gMjQpICYgMHhmZmZmZmYsIChpLnZhbHVlID4+PiAzMSkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl90b19zdHJpbmcoaSkge1xuICAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhpLnZhbHVlLnRvU3RyaW5nKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBVSW50NjQgY29uc3RcbnZhciBVSW50NjQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBVSW50NjQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHg7IC8vIHggaXMgYW4gTWxJbnQ2NFxuICAgIH07XG4gICAgVUludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiaW50ZWdlcnM6dWludDY0XCI7XG4gICAgcmV0dXJuIFVJbnQ2NDtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9hZGRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9hZGQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfYWRkKHgudmFsdWUsIHkudmFsdWUpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfZGl2KHgsIHkpIHtcbiAgICBpZiAoeS52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gICAgfVxuICAgIC8vIENvZXJjZSB0aGUgaGlnaCBwYXJ0cyB0byBiZSB1bnNpZ25lZCBiZWZvcmUgZGl2aXNpb24uXG4gICAgeC52YWx1ZS5oaSA9IHgudmFsdWUuaGkgPj4+IDA7XG4gICAgeS52YWx1ZS5oaSA9IHkudmFsdWUuaGkgPj4+IDA7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoeC52YWx1ZS51ZGl2bW9kKHkudmFsdWUpLnF1b3RpZW50KTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2xvZ2FuZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hbmQsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2xvZ2FuZCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9hbmQoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbG9nb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb3IsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2xvZ29yKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X29yKHgudmFsdWUsIHkudmFsdWUpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X2xvZ3hvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF94b3IsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X2xvZ3hvcih4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF94b3IoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbWF4XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbWF4KHVuaXQpIHtcbiAgICB2YXIgeCA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4ZmZmZmZmLCAweGZmZmZmZiwgMHhmZmZmKTtcbiAgICB4LmhpID0geC5oaSA+Pj4gMDtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NCh4KTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X211bFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X211bCh4LCB5KSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9tdWwoeC52YWx1ZSwgeS52YWx1ZSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfb2ZfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9vZl9pbnQoaSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfb2ZfaW50MzIoaSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfb2ZfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9vZl9pbnQ2NChpKSB7XG4gICAgcmV0dXJuIG5ldyBVSW50NjQoY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoaS5sbywgaS5taSwgaS5oaSA+Pj4gMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSwgY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9pbnQ2NF91bHQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nKHMsIG1heF92YWwpIHtcbiAgICAvLyBOb3RlOiBUaGlzIGNvZGUgbWF0Y2hlcyB0aGUgYmVoYXZpb3Igb2YgdGhlIEMgZnVuY3Rpb24uXG4gICAgLy8gSW4gcGFydGljdWxhcixcbiAgICAvLyAtIG9ubHkgYmFzZS0xMCBudW1iZXJzIGFyZSBhY2NlcHRlZFxuICAgIC8vIC0gbmVnYXRpdmUgbnVtYmVycyBhcmUgYWNjZXB0ZWQgYW5kIGNvZXJjZWQgdG8gMidzLWNvbXBsZW1lbnQgdWludDY0XG4gICAgLy8gLSB0aGUgbG9uZ2VzdCBudW1lcmljIHByZWZpeCBpcyBhY2NlcHRlZCwgb25seSByYWlzaW5nIGFuIGVycm9yIHdoZW4gdGhlcmVcbiAgICAvLyAgIGlzbid0IGEgbnVtZXJpYyBwcmVmaXhcbiAgICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgfVxuICAgIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PT0gNDUpIHsgLy8gTWludXMgc2lnblxuICAgICAgICBpKys7XG4gICAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDQzKSB7IC8vIFBsdXMgc2lnblxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHZhciBub19kaWdpdHMgPSB0cnVlO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBoaWdoIGJ5dGUgaXMgdW5zaWduZWQgYmVmb3JlIGRpdmlzaW9uLlxuICAgIG1heF92YWwuaGkgPSBtYXhfdmFsLmhpID4+PiAwO1xuICAgIHZhciB0ZW4gPSBjYW1sX2ludDY0X29mX2ludDMyKDEwKTtcbiAgICB2YXIgbWF4X2Jhc2VfMTAgPSBtYXhfdmFsLnVkaXZtb2QodGVuKS5xdW90aWVudDtcbiAgICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigwKTtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICAgICAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSAxMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9fZGlnaXRzID0gZmFsc2U7XG4gICAgICAgIC8vIEFueSBkaWdpdCBoZXJlIHdvdWxkIG92ZXJmbG93LiBQaW4gdG8gdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICAgIGlmIChjYW1sX2ludDY0X3VsdChtYXhfYmFzZV8xMCwgcmVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heF92YWw7XG4gICAgICAgIH1cbiAgICAgICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKHRlbiwgcmVzKSwgZCk7XG4gICAgICAgIC8vIFRoZSBnaXZlbiBkaWdpdCB3YXMgdG9vIGxhcmdlLiBQaW4gdG8gdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4X3ZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9fZGlnaXRzKSB7XG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgICB9XG4gICAgLy8gU2V0IHRoZSBoaWdoIGJ5dGUgYXMgdW5zaWduZWQuXG4gICAgcmVzLmhpID0gcmVzLmhpID4+PiAwO1xuICAgIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIG1heF92YWwgPSBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgweGZmZmZmZiwgMHhmZmZmZmYsIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgVUludDY0KGludGVnZXJzX3VpbnRfb2Zfc3RyaW5nKHMsIG1heF92YWwpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDY0X3JlbVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSwgY2FtbF9pbnQ2NF9pc196ZXJvLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9yZW0oeCwgeSkge1xuICAgIGlmICh5LnZhbHVlLmlzWmVybygpKSB7XG4gICAgICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgICB9XG4gICAgLy8gQ29lcmNlIHRoZSBoaWdoIHBhcnRzIHRvIGJlIHVuc2lnbmVkIGJlZm9yZSBkaXZpc2lvbi5cbiAgICB4LnZhbHVlLmhpID0geC52YWx1ZS5oaSA+Pj4gMDtcbiAgICB5LnZhbHVlLmhpID0geS52YWx1ZS5oaSA+Pj4gMDtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NCh4LnZhbHVlLnVkaXZtb2QoeS52YWx1ZSkubW9kdWx1cyk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9zaGlmdF9sZWZ0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQsIFVJbnQ2NFxuZnVuY3Rpb24gaW50ZWdlcnNfdWludDY0X3NoaWZ0X2xlZnQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfc2hpZnRfbGVmdCh4LnZhbHVlLCB5KSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9zaGlmdF9yaWdodFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfc2hpZnRfcmlnaHQoeCwgeSkge1xuICAgIHJldHVybiBuZXcgVUludDY0KGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeC52YWx1ZSwgeSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3N1YiwgVUludDY0XG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfc3ViKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X3N1Yih4LnZhbHVlLCB5LnZhbHVlKSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF90b19pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9faW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF90b19pbnQoaSkge1xuICAgIHJldHVybiBjYW1sX2ludDY0X3RvX2ludDMyKGkudmFsdWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfdG9faW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfdG9faW50NjQoaSkge1xuICAgIGkgPSBpLnZhbHVlO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShpLmxvLCBpLm1pLCBpLmhpIHwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF90b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZm9ybWF0LCBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF90b19zdHJpbmcoaSkge1xuICAgIHJldHVybiBjYW1sX2ludDY0X2Zvcm1hdChjYW1sX25ld19zdHJpbmcoXCIldVwiKSwgaS52YWx1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBVSW50NjRcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgICByZXR1cm4gbmV3IFVJbnQ2NChjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpKTtcbn1cbiAgXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gICAgY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdi52YWx1ZSwgc2l6ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9oYXNoXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50NjRfaGFzaCh2KSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfaGFzaCh2LnZhbHVlKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDhfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBpbnRlZ2Vyc191aW50MzJfb2Zfc3RyaW5nXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50OF9vZl9zdHJpbmcoeCkge1xuICAgIHZhciB5ID0gaW50ZWdlcnNfdWludDMyX29mX3N0cmluZyh4KTtcbiAgICByZXR1cm4gKHgudmFsdWUgJiAweEZGKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludF9zaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50X3NpemUodW5pdCkge1xuICAgIHJldHVybiA0O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191bG9uZ19zaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc191bG9uZ19zaXplKHVuaXQpIHtcbiAgICByZXR1cm4gNDtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWxvbmdsb25nX3NpemVcbmZ1bmN0aW9uIGludGVnZXJzX3Vsb25nbG9uZ19zaXplKHVuaXQpIHtcbiAgICByZXR1cm4gODtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdW5zaWduZWRfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzLCBpbnRlZ2Vyc191aW50OF9kZXNlcmlhbGl6ZSwgaW50ZWdlcnNfdWludDE2X2Rlc2VyaWFsaXplLCBpbnRlZ2Vyc191aW50MzJfc2VyaWFsaXplLCBpbnRlZ2Vyc191aW50MzJfZGVzZXJpYWxpemUsIGludGVnZXJzX3VpbnQzMl9oYXNoLCBpbnRlZ2Vyc191aW50MzJfY29tcGFyZSwgaW50ZWdlcnNfdWludDY0X2NvbXBhcmUsIGludGVnZXJzX3VpbnQ2NF9oYXNoLCBpbnRlZ2Vyc191aW50NjRfbWFyc2hhbCwgaW50ZWdlcnNfdWludDY0X3VubWFyc2hhbFxuZnVuY3Rpb24gaW50ZWdlcnNfdW5zaWduZWRfaW5pdCh1bml0KSB7XG4gICAgY2FtbF9jdXN0b21fb3BzW1wiaW50ZWdlcnM6dWludDhcIl0gPVxuICAgIHsgZGVzZXJpYWxpemU6IGludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplXG4gICAgLCBmaXhlZF9sZW5ndGg6IDEgfTtcbiAgICBjYW1sX2N1c3RvbV9vcHNbXCJpbnRlZ2Vyczp1aW50MTZcIl0gPVxuICAgIHsgZGVzZXJpYWxpemU6IGludGVnZXJzX3VpbnQxNl9kZXNlcmlhbGl6ZVxuICAgICwgZml4ZWRfbGVuZ3RoOiAyIH07XG4gICAgY2FtbF9jdXN0b21fb3BzW1wiaW50ZWdlcnM6dWludDMyXCJdID1cbiAgICB7IHNlcmlhbGl6ZTogaW50ZWdlcnNfdWludDMyX3NlcmlhbGl6ZVxuICAgICwgZGVzZXJpYWxpemU6IGludGVnZXJzX3VpbnQzMl9kZXNlcmlhbGl6ZVxuICAgICwgZml4ZWRfbGVuZ3RoOiA0XG4gICAgLCBoYXNoOiBpbnRlZ2Vyc191aW50MzJfaGFzaFxuICAgICwgY29tcGFyZTogaW50ZWdlcnNfdWludDMyX2NvbXBhcmUgfTtcbiAgICBjYW1sX2N1c3RvbV9vcHNbXCJpbnRlZ2Vyczp1aW50NjRcIl0gPVxuICAgIHsgc2VyaWFsaXplOiBpbnRlZ2Vyc191aW50NjRfbWFyc2hhbFxuICAgICwgZGVzZXJpYWxpemU6IGludGVnZXJzX3VpbnQ2NF91bm1hcnNoYWxcbiAgICAsIGhhc2g6IGludGVnZXJzX3VpbnQ2NF9oYXNoXG4gICAgLCBjb21wYXJlOiBpbnRlZ2Vyc191aW50NjRfY29tcGFyZSB9O1xuICAgIHJldHVybiB1bml0O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191c2hvcnRfc2l6ZVxuZnVuY3Rpb24gaW50ZWdlcnNfdXNob3J0X3NpemUodW5pdCkge1xuICAgIHJldHVybiA0O1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MzJfc2VyaWFsaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50MzJfc2VyaWFsaXplKHdyaXRlciwgdiwgc2l6ZSkge1xuICAgIHdyaXRlci53cml0ZSgzMiwgdi52YWx1ZSk7XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgc2l6ZVsxXSA9IDQ7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ4X2Rlc2VyaWFsaXplXG5mdW5jdGlvbiBpbnRlZ2Vyc191aW50OF9kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpIHtcbiAgICBzaXplWzBdID0gMTtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQ4dSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlZ2Vyc191aW50MTZfZGVzZXJpYWxpemVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQxNl9kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpIHtcbiAgICBzaXplWzBdID0gMjtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnUoKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBVSW50MzJcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpIHtcbiAgICBzaXplWzBdID0gNDtcbiAgICByZXR1cm4gbmV3IFVJbnQzMihyZWFkZXIucmVhZDMydSgpKTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX2hhc2hcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9oYXNoKHYpIHtcbiAgICByZXR1cm4gdi52YWx1ZTtcbn1cblxuLy9Qcm92aWRlczogaW50ZWdlcnNfdWludDMyX2NvbXBhcmVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQzMl9jb21wYXJlKHgsIHkpIHtcbiAgICBpZiAoeC52YWx1ZSA+IHkudmFsdWUpIHsgcmV0dXJuIDE7IH1cbiAgICBpZiAoeC52YWx1ZSA8IHkudmFsdWUpIHsgcmV0dXJuIC0xOyB9XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGludGVnZXJzX3VpbnQ2NF9jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NvbXBhcmVcbmZ1bmN0aW9uIGludGVnZXJzX3VpbnQ2NF9jb21wYXJlKHgsIHkpIHtcbiAgICB4LnZhbHVlLmhpID0geC52YWx1ZS5oaSA+Pj4gMDtcbiAgICB5LnZhbHVlLmhpID0geS52YWx1ZS5oaSA+Pj4gMDtcbiAgICByZXR1cm4geC52YWx1ZS51Y29tcGFyZSh5LnZhbHVlKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3NcblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKXtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDc6IGNhc2UgMTA6IGNhc2UgMTE6IHJldHVybiAyO1xuICBkZWZhdWx0OiByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDE6ICB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gZy5JbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgY2FzZSA0OiAgdmlldyA9IGcuSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBnLlVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgNzogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTA6IHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICB9XG4gIGlmICghdmlldykgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUgKiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPCA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycmF5XCJcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA+PSA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycjAyXCJcblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IGNhbWxfYmFfY3VzdG9tX25hbWU7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGlmKGJhLmNhbWxfY3VzdG9tID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGJhLmRpbXNbaV0gPCAweGZmZmYpXG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSlcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgd3JpdGVyLndyaXRlKDgsMCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoYmEuZ2V0KGkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGogPSBiYS5nZXQoaSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzFdKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMV0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzJdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDQ7XG4gIHN6WzFdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSl7XG4gIHZhciBudW1fZGltcyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHdyb25nIG51bWJlciBvZiBiaWdhcnJheSBkaW1lbnNpb25zXCIpO1xuICB2YXIgdGFnID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIGtpbmQgPSB0YWcgJiAweGZmXG4gIHZhciBsYXlvdXQgPSAodGFnID4+IDgpICYgMTtcbiAgdmFyIGRpbXMgPSBbXVxuICBpZihuYW1lID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZV9kaW0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgaWYoc2l6ZV9kaW0gPT0gMHhmZmZmKXtcbiAgICAgICAgdmFyIHNpemVfZGltX2hpID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgdmFyIHNpemVfZGltX2xvID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgaWYoc2l6ZV9kaW1faGkgIT0gMClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGJpZ2FycmF5IGRpbWVuc2lvbiBvdmVyZmxvdyBpbiAzMmJpdFwiKTtcbiAgICAgICAgc2l6ZV9kaW0gPSBzaXplX2RpbV9sbztcbiAgICAgIH1cbiAgICAgIGRpbXMucHVzaChzaXplX2RpbSk7XG4gICAgfVxuICBlbHNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYmEpe1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19hbGxvY1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19hbGxvYyhfLHNpemUpe1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGUoMTIsIDAsIFswLHNpemVdKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2lzX21tYXBwZWRfc3R1YlxuZnVuY3Rpb24gYmlnc3RyaW5nX2lzX21tYXBwZWRfc3R1Yih4KXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X3N0dWIoczEsIGkxLCBzMiwgaTIsIGxlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGNhbWxfYmFfc2V0XzEoczIsaTIgKyBpLGNhbWxfYmFfZ2V0XzEoczEsaTEgKyBpKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXQsIGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViKHZfc3RyLCB2X3NyY19wb3MsIHZfYnN0ciwgdl9kc3RfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykgY2FtbF9iYV9zZXRfMSh2X2JzdHIsdl9kc3RfcG9zICsgaSxjYW1sX2J5dGVzX2dldCh2X3N0cix2X3NyY19wb3MgKyBpKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQsIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViKHZfYnN0ciwgdl9zcmNfcG9zLCB2X3N0ciwgdl9kc3RfcG9zLCB2X2xlbil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKXtcbiAgICB2YXIgYyA9IGNhbWxfYmFfZ2V0XzEodl9ic3RyLHZfc3JjX3BvcyArIGkpO1xuICAgIGNhbWxfYnl0ZXNfc2V0KHZfc3RyLHZfZHN0X3BvcyArIGksYyk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0LCBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWIodl9zdHIsIHZfc3JjX3Bvcywgdl9ic3RyLCB2X2RzdF9wb3MsIHZfbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSBjYW1sX2JhX3NldF8xKHZfYnN0cix2X2RzdF9wb3MgKyBpLGNhbWxfc3RyaW5nX2dldCh2X3N0cix2X3NyY19wb3MgKyBpKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtc2V0X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tZW1zZXRfc3R1YihiaWdzdHJpbmcsIHZfcG9zLCB2X2xlbiwgdl9jaGFyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykge1xuICAgIGNhbWxfYmFfc2V0XzEoYmlnc3RyaW5nLCB2X3BvcyArIGksIHZfY2hhcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbWNtcF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtY21wX3N0dWIodl9zMSwgdl9zMV9wb3MsIHZfczIsIHZfczJfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMSh2X3MxLHZfczFfcG9zICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHZfczIsdl9zMl9wb3MgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG52YXIgaW50ZXJuYWxoYXNoX2ZvbGRfYmlnc3RyaW5nID0gY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2ZpbmRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19maW5kKGJzLCBjaHIsIHBvcywgbGVuKXtcbiAgd2hpbGUobGVuID4gMCl7XG4gICAgaWYoY2FtbF9iYV9nZXRfMShicyxwb3MpID09IGNocikgcmV0dXJuIHBvcztcbiAgICBwb3MrKztcbiAgICBsZW4tLTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogcGFyc2luZy5jIDg5ODMgMjAwOC0wOC0wNiAwOTozODoyNVogeGxlcm95ICQgKi9cblxuLyogVGhlIFBEQSBhdXRvbWF0b24gZm9yIHBhcnNlcnMgZ2VuZXJhdGVkIGJ5IGNhbWx5YWNjICovXG5cbi8qIFRoZSBwdXNoZG93biBhdXRvbWF0YSAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZW5naW5lKHRhYmxlcywgZW52LCBjbWQsIGFyZylcbntcbiAgdmFyIEVSUkNPREUgPSAyNTY7XG5cbiAgLy92YXIgU1RBUlQgPSAwO1xuICAvL3ZhciBUT0tFTl9SRUFEID0gMTtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzEgPSAyO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMiA9IDM7XG4gIC8vdmFyIFNFTUFOVElDX0FDVElPTl9DT01QVVRFRCA9IDQ7XG4gIC8vdmFyIEVSUk9SX0RFVEVDVEVEID0gNTtcbiAgdmFyIGxvb3AgPSA2O1xuICB2YXIgdGVzdHNoaWZ0ID0gNztcbiAgdmFyIHNoaWZ0ID0gODtcbiAgdmFyIHNoaWZ0X3JlY292ZXIgPSA5O1xuICB2YXIgcmVkdWNlID0gMTA7XG5cbiAgdmFyIFJFQURfVE9LRU4gPSAwO1xuICB2YXIgUkFJU0VfUEFSU0VfRVJST1IgPSAxO1xuICB2YXIgR1JPV19TVEFDS1NfMSA9IDI7XG4gIHZhciBHUk9XX1NUQUNLU18yID0gMztcbiAgdmFyIENPTVBVVEVfU0VNQU5USUNfQUNUSU9OID0gNDtcbiAgdmFyIENBTExfRVJST1JfRlVOQ1RJT04gPSA1O1xuXG4gIHZhciBlbnZfc19zdGFjayA9IDE7XG4gIHZhciBlbnZfdl9zdGFjayA9IDI7XG4gIHZhciBlbnZfc3ltYl9zdGFydF9zdGFjayA9IDM7XG4gIHZhciBlbnZfc3ltYl9lbmRfc3RhY2sgPSA0O1xuICB2YXIgZW52X3N0YWNrc2l6ZSA9IDU7XG4gIHZhciBlbnZfc3RhY2tiYXNlID0gNjtcbiAgdmFyIGVudl9jdXJyX2NoYXIgPSA3O1xuICB2YXIgZW52X2x2YWwgPSA4O1xuICB2YXIgZW52X3N5bWJfc3RhcnQgPSA5O1xuICB2YXIgZW52X3N5bWJfZW5kID0gMTA7XG4gIHZhciBlbnZfYXNwID0gMTE7XG4gIHZhciBlbnZfcnVsZV9sZW4gPSAxMjtcbiAgdmFyIGVudl9ydWxlX251bWJlciA9IDEzO1xuICB2YXIgZW52X3NwID0gMTQ7XG4gIHZhciBlbnZfc3RhdGUgPSAxNTtcbiAgdmFyIGVudl9lcnJmbGFnID0gMTY7XG5cbiAgLy8gdmFyIF90YmxfYWN0aW9ucyA9IDE7XG4gIHZhciB0YmxfdHJhbnNsX2NvbnN0ID0gMjtcbiAgdmFyIHRibF90cmFuc2xfYmxvY2sgPSAzO1xuICB2YXIgdGJsX2xocyA9IDQ7XG4gIHZhciB0YmxfbGVuID0gNTtcbiAgdmFyIHRibF9kZWZyZWQgPSA2O1xuICB2YXIgdGJsX2Rnb3RvID0gNztcbiAgdmFyIHRibF9zaW5kZXggPSA4O1xuICB2YXIgdGJsX3JpbmRleCA9IDk7XG4gIHZhciB0YmxfZ2luZGV4ID0gMTA7XG4gIHZhciB0YmxfdGFibGVzaXplID0gMTE7XG4gIHZhciB0YmxfdGFibGUgPSAxMjtcbiAgdmFyIHRibF9jaGVjayA9IDEzO1xuICAvLyB2YXIgX3RibF9lcnJvcl9mdW5jdGlvbiA9IDE0O1xuICAvLyB2YXIgX3RibF9uYW1lc19jb25zdCA9IDE1O1xuICAvLyB2YXIgX3RibF9uYW1lc19ibG9jayA9IDE2O1xuXG4gIGlmICghdGFibGVzLmRnb3RvKSB7XG4gICAgdGFibGVzLmRlZnJlZCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2RlZnJlZF0pO1xuICAgIHRhYmxlcy5zaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9zaW5kZXhdKTtcbiAgICB0YWJsZXMuY2hlY2sgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfY2hlY2tdKTtcbiAgICB0YWJsZXMucmluZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfcmluZGV4XSk7XG4gICAgdGFibGVzLnRhYmxlICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3RhYmxlXSk7XG4gICAgdGFibGVzLmxlbiAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xlbl0pO1xuICAgIHRhYmxlcy5saHMgICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9saHNdKTtcbiAgICB0YWJsZXMuZ2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZ2luZGV4XSk7XG4gICAgdGFibGVzLmRnb3RvICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2Rnb3RvXSk7XG4gIH1cblxuICB2YXIgcmVzID0gMCwgbiwgbjEsIG4yLCBzdGF0ZTE7XG5cbiAgLy8gUkVTVE9SRVxuICB2YXIgc3AgPSBlbnZbZW52X3NwXTtcbiAgdmFyIHN0YXRlID0gZW52W2Vudl9zdGF0ZV07XG4gIHZhciBlcnJmbGFnID0gZW52W2Vudl9lcnJmbGFnXTtcblxuICBleGl0OmZvciAoOzspIHtcbiAgICBzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgY2FzZSA1Oi8vRVJST1JfREVURUNURUQ6XG4gICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgZXJyZmxhZyA9IDM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlMV07XG4gICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBFUlJDT0RFKSB7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDg6Ly9zaGlmdDpcbiAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgaWYgKGVycmZsYWcgPiAwKSBlcnJmbGFnLS07XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDk6Ly9zaGlmdF9yZWNvdmVyOlxuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIHZhciBtID0gdGFibGVzLmxlbltuXTtcbiAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgZW52W2Vudl9ydWxlX2xlbl0gPSBtO1xuICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwXTtcbiAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gc3RhdGUxKVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18yO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDM6Ly9TVEFDS1NfR1JPV05fMjpcbiAgICAgIHJlcyA9IENPTVBVVEVfU0VNQU5USUNfQUNUSU9OO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIC8qIFNob3VsZCBub3QgaGFwcGVuICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlIGNvbnN0XG4vL0R1bW15IGZ1bmN0aW9uIVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKCkgeyByZXR1cm4gMDsgfVxuIiwiLy9Qcm92aWRlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih1bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiB1bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiB1bml4X2lzYXR0eSBcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsIHYpIHtcbiAgc3dpdGNoICh2LnQgJiA2KSB7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAodik7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHYuYyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgdi5jKTtcbiAgfVxuICByZXR1cm4gaFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSB2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zZXRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgICAgeyBqdXN0aWZ5OicrJywgc2lnbnN0eWxlOictJywgZmlsbGVyOicgJywgYWx0ZXJuYXRlOmZhbHNlLFxuICAgICAgICBiYXNlOjAsIHNpZ25lZGNvbnY6ZmFsc2UsIHdpZHRoOjAsIHVwcGVyY2FzZTpmYWxzZSxcbiAgICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgICBmLnByZWMgPSAwO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLnByZWMgPSBmLnByZWMgKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIGNhc2UgJ2QnOiBjYXNlICdpJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAndSc6XG4gICAgICBmLmJhc2UgPSAxMDsgYnJlYWs7XG4gICAgY2FzZSAneCc6XG4gICAgICBmLmJhc2UgPSAxNjsgYnJlYWs7XG4gICAgY2FzZSAnWCc6XG4gICAgICBmLmJhc2UgPSAxNjsgZi51cHBlcmNhc2UgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICdvJzpcbiAgICAgIGYuYmFzZSA9IDg7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBjYXNlICdmJzogY2FzZSAnZyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLmNvbnYgPSBjOyBicmVhaztcbiAgICBjYXNlICdFJzogY2FzZSAnRic6IGNhc2UgJ0cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgZi5jb252ID0gYy50b0xvd2VyQ2FzZSAoKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwciAoZikgeyByZXR1cm4gZigpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gbyBpbnN0YW5jZW9mIGM7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3I/am9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yLnVzZXJBZ2VudDpcIlwiO1xuICByZXR1cm4gdWEuaW5kZXhPZihcIk1TSUVcIikgIT0gLTEgJiYgdWEuaW5kZXhPZihcIk9wZXJhXCIpICE9IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lc2NhcGUgY29uc3QgKGNvbnN0KVxudmFyIGNhbWxfanNfcmVnZXhwcyA9IHsgYW1wOi8mL2csIGx0Oi88L2csIHF1b3Q6L1xcXCIvZywgYWxsOi9bJjxcXFwiXS8gfTtcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lc2NhcGUgKHMpIHtcbiAgaWYgKCFjYW1sX2pzX3JlZ2V4cHMuYWxsLnRlc3QocykpIHJldHVybiBzO1xuICByZXR1cm4gcy5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5hbXAsIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMubHQsIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5xdW90LCBcIiZxdW90O1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VudGl0aWVzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZW50aXRpZXMocykge1xuICB2YXIgZW50aXR5ID0gL14mIz9bMC05YS16QS1aXSs7JC9cbiAgaWYocy5tYXRjaChlbnRpdHkpKVxuICB7XG4gICAgdmFyIHN0ciwgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICB0ZW1wLmlubmVySFRNTD0gcztcbiAgICBzdHI9IHRlbXAudGV4dENvbnRlbnQgfHwgdGVtcC5pbm5lclRleHQ7XG4gICAgdGVtcD1udWxsO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9mYWlsd2l0aChcIkludmFsaWQgZW50aXR5IFwiICsgcyk7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8gRGVidWdnaW5nIGNvbnNvbGVcbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU/am9vX2dsb2JhbF9vYmplY3QuY29uc29sZTp7fTtcbiAgdmFyIG0gPSBbXCJsb2dcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJhc3NlcnRcIiwgXCJkaXJcIiwgXCJkaXJ4bWxcIixcbiAgICAgICAgICAgXCJ0cmFjZVwiLCBcImdyb3VwXCIsIFwiZ3JvdXBDb2xsYXBzZWRcIiwgXCJncm91cEVuZFwiLCBcInRpbWVcIiwgXCJ0aW1lRW5kXCJdO1xuICBmdW5jdGlvbiBmICgpIHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgaWYgKCFjW21baV1dKSBjW21baV1dPWY7XG4gIHJldHVybiBjO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZVxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lKHJlcykge1xuICB2YXIgYyA9IDE7XG4gIHdoaWxlKHJlcyAmJiByZXMuam9vX3RyYW1wKXtcbiAgICByZXMgPSByZXMuam9vX3RyYW1wLmFwcGx5KG51bGwsIHJlcy5qb29fYXJncyk7XG4gICAgYysrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lX3JldHVyblxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpIHtcbiAgcmV0dXJuIHtqb29fdHJhbXA6Zixqb29fYXJnczphcmdzfTtcbn1cblxuLy9Qcm92aWRlczoganNfcHJpbnRfc3Rkb3V0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3Rkb3V0KHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZG91dC53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAgJiYgdi5sb2cgJiYgdi5sb2cocyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZGVyciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZGVycihzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRlcnIud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgJiYgdi5lcnJvciAmJiB2LmVycm9yKHMpO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICBpZihqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1dyYXAgRXJyb3IgaW4gSnMuRXJyb3IgZXhjZXB0aW9uXG4gIGlmKGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICByZXR1cm4gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICByZXR1cm4gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChTdHJpbmcoZSkpXTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5FcnJvcihcIkpzIGV4Y2VwdGlvbiBjb250YWluaW5nIGJhY2t0cmFjZVwiKTtcbiAgcmV0dXJuIGV4bjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIGV4bi5qc19lcnJvcjsgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIGRlbGV0ZSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zdGRfb3V0cHV0KGNoYW5pZCxzKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBzdHIgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpO1xuICB2YXIgc2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5vZmZzZXQsIHN0ciwgMCwgc2xlbik7XG4gIGNoYW4ub2Zmc2V0ICs9IHNsZW47XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsTWxGYWtlRmlsZVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyLCBqc19wcmludF9zdGRvdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoaWR4LG91dHB1dCxmaWxlLGZsYWdzKSB7XG4gIGlmKGNhbWxfZ2xvYmFsX2RhdGEuZmRzID09PSB1bmRlZmluZWQpIGNhbWxfZ2xvYmFsX2RhdGEuZmRzID0gbmV3IEFycmF5KCk7XG4gIGZsYWdzPWZsYWdzP2ZsYWdzOnt9O1xuICB2YXIgaW5mbyA9IHt9O1xuICBpbmZvLmZpbGUgPSBmaWxlO1xuICBpbmZvLm9mZnNldCA9IGZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjA7XG4gIGluZm8uZmxhZ3MgPSBmbGFncztcbiAgaW5mby5vdXRwdXQgPSBvdXRwdXQ7XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2lkeF0gPSBpbmZvO1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCB8fCBpZHggPiBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4KVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggPSBpZHg7XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuIChuYW1lLCBmbGFncywgX3Blcm1zKSB7XG4gIHZhciBmID0ge307XG4gIHdoaWxlKGZsYWdzKXtcbiAgICBzd2l0Y2goZmxhZ3NbMV0pe1xuICAgIGNhc2UgMDogZi5yZG9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMTogZi53cm9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMjogZi5hcHBlbmQgPSAxO2JyZWFrO1xuICAgIGNhc2UgMzogZi5jcmVhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNDogZi50cnVuY2F0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA1OiBmLmV4Y2wgPSAxOyBicmVhaztcbiAgICBjYXNlIDY6IGYuYmluYXJ5ID0gMTticmVhaztcbiAgICBjYXNlIDc6IGYudGV4dCA9IDE7YnJlYWs7XG4gICAgY2FzZSA4OiBmLm5vbmJsb2NrID0gMTticmVhaztcbiAgICB9XG4gICAgZmxhZ3M9ZmxhZ3NbMl07XG4gIH1cbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LGYpO1xuICB2YXIgaWR4ID0gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeD9jYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4OjA7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChpZHgrMSxjYW1sX3N0ZF9vdXRwdXQsZmlsZSxmKTtcbn1cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMCxjYW1sX3N0ZF9vdXRwdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkaW5cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMSxqc19wcmludF9zdGRvdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3Rkb3V0XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDIsanNfcHJpbnRfc3RkZXJyLCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGVyclxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKCkge1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcjpcIlwiXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3lzX29wZW4sY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcblxuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICByZWZpbGw6bnVsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF07XG4gIGRhdGEuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGRhdGEuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2hhbi5maWxlLmNsb3NlKCk7XG4gIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5maWxlLmxlbmd0aCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGggKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQoY2hhbmlkLGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbikge1xuICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgdmFyIHN0cl9sZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgaWYgKHN0cl9sZW4gPT0gMCkgY2hhbi5yZWZpbGwgPSBudWxsO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5maWxlLmxlbmd0aCgpLCBzdHIsIDAsIHN0cl9sZW4pO1xuICByZXR1cm4gc3RyX2xlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCA9PSBudWxsKSByZXR1cm47XG4gIGlmIChjaGFuLmZpbGUubGVuZ3RoKCkgIT0gY2hhbi5vZmZzZXQpIHJldHVybjtcbiAgY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dCAoY2hhbmlkLCBzLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgbDIgPSBjaGFuLmZpbGUubGVuZ3RoKCkgLSBjaGFuLm9mZnNldDtcbiAgaWYgKGwyID09IDAgJiYgY2hhbi5yZWZpbGwgIT0gbnVsbCkgbDIgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgaWYgKGwyIDwgbCkgbCA9IGwyO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCwgcywgaSwgbCk7XG4gIGNoYW4ub2Zmc2V0ICs9IGw7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKDgpO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCw4KTtcblxuICAvLyBIZWFkZXIgaXMgMjAgYnl0ZXNcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGJ1ZiwgMCkgKyAyMDtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcblxuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub2Zmc2V0ID49IGNoYW4uZmlsZS5sZW5ndGgoKSlcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmZpbGUucmVhZF9vbmUoY2hhbi5vZmZzZXQpO1xuICBjaGFuLm9mZnNldCsrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBmaWxlID0gY2hhbi5maWxlO1xuICB3aGlsZSAoKGNoYW4ub2Zmc2V0ICsgMykgPj0gZmlsZS5sZW5ndGgoKSkge1xuICAgIHZhciBsID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gICAgaWYgKGwgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9XG4gIHZhciBvID0gY2hhbi5vZmZzZXQ7XG4gIHZhciByID0oZmlsZS5yZWFkX29uZShvICApIDw8IDI0KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysxKSA8PCAxNilcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMikgPDwgOClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMykpO1xuICBjaGFuLm9mZnNldCs9NDtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCl9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLm9mZnNldDtcbiAgdmFyIGxlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYocCA+PSBsZW4pIHsgcmV0dXJuIDA7fVxuICB3aGlsZSh0cnVlKSB7XG4gICAgaWYocCA+PSBsZW4pIHJldHVybiAtIChwIC0gY2hhbi5vZmZzZXQpO1xuICAgIGlmKGNoYW4uZmlsZS5yZWFkX29uZShwKSA9PSAxMCkgcmV0dXJuIHAgLSBjaGFuLm9mZnNldCArIDE7XG4gICAgcCsrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlciA9PSBcIlwiKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5mZFxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXVxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgIHN3aXRjaChvdXRwdXQubGVuZ3RoKXtcbiAgICBjYXNlIDI6IG91dHB1dChjaGFuaWQsY2hhbi5idWZmZXIpO2JyZWFrO1xuICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICB9O1xuICB9XG4gIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIHZhciBieXRlcztcbiAgaWYob2Zmc2V0ID09IDAgJiYgY2FtbF9tbF9ieXRlc19sZW5ndGgoYnVmZmVyKSA9PSBsZW4pXG4gICAgYnl0ZXMgPSBidWZmZXI7XG4gIGVsc2Uge1xuICAgIGJ5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoYnVmZmVyLG9mZnNldCxieXRlcywwLGxlbik7XG4gIH1cbiAgdmFyIHN0cmluZyA9IGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ5dGVzKTtcbiAgdmFyIGpzc3RyaW5nID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzdHJpbmcpO1xuICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgaWYoaWQgPCAwKVxuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgZWxzZSB7XG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgY2hhbi5idWZmZXIgKz0ganNzdHJpbmcuc3Vic3RyKGlkKzEpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXRcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nKGgsIGJzKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLGJzLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGFcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChieXRlczIpKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShzbGljZSksIDAsIGJ5dGVzMiwgcG9zMiwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8vLy8vLy8vIEJJTl9QUk9UXG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX2Zsb2F0X2FycmF5X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfc2V0LCBjYW1sX2JhX2dldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViKHZfc3JjX3Bvcywgdl9idWYsIHZfZHN0X3Bvcywgdl9hcnIsIHZfbGVuKXtcbiAgdmFyIGM7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspe1xuICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3LWpdID0gY2FtbF9iYV9nZXRfMSh2X2J1Zix2X3NyY19wb3MraisoaSo4KSk7XG4gICAgYyA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCkpO1xuICAgIGNhbWxfYXJyYXlfc2V0KHZfYXJyLHZfZHN0X3BvcytpLGMpO1xuICB9XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViKHZfc3JjX3Bvcywgdl9idWYsIHZfZHN0X3Bvcywgdl9zdHIsIHZfbGVuKXtcbiAgdmFyIGM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKXtcbiAgICBjID0gY2FtbF9iYV9nZXRfMSh2X2J1Zix2X3NyY19wb3MraSk7XG4gICAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCh2X3N0cix2X2RzdF9wb3MraSxjKTtcbiAgfVxuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXQsIGNhbWxfYmFfc2V0XzFcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1Yih2X3NyY19wb3MsIHZfYXJyLCB2X2RzdF9wb3MsIHZfYnVmLCB2X2xlbil7XG4gIHZhciBjO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKyl7XG4gICAgdmFyIGYgPSBjYW1sX2FycmF5X2dldCh2X2Fycix2X3NyY19wb3MraSk7XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChmKSk7XG4gICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKVxuICAgICAgY2FtbF9iYV9zZXRfMSh2X2J1Zix2X2RzdF9wb3MraisoaSo4KSwgYVs3LWpdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfc3RyaW5nX2J1Zl9zdHViICh2X3NyY19wb3MsIHZfc3RyLCB2X2RzdF9wb3MsIHZfYnVmLCB2X2xlbil7XG4gIHZhciBjO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKyl7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodl9zdHIsdl9zcmNfcG9zK2kpO1xuICAgIGNhbWxfYmFfc2V0XzEodl9idWYsdl9kc3RfcG9zK2ksYyk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnl0ZXNfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfYnl0ZXNfYnVmX3N0dWIgKHZfc3JjX3Bvcywgdl9zdHIsIHZfZHN0X3Bvcywgdl9idWYsIHZfbGVuKXtcbiAgdmFyIGM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKXtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2X3N0cix2X3NyY19wb3MraSk7XG4gICAgY2FtbF9iYV9zZXRfMSh2X2J1Zix2X2RzdF9wb3MraSxjKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2JhX3NldF8xLCBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9zdHViICh2X3NyY19wb3MsIHZfc3JjLCB2X2RzdF9wb3MsIHZfZHN0LCB2X2xlbil7XG4gIHZhciB2X3NyYzIgPSBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKHZfc3JjLmRhdGEuYnVmZmVyKTtcbiAgdmFyIHZfZHN0MiA9IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIodl9kc3QuZGF0YS5idWZmZXIpO1xuICB2YXIgYztcbiAgZm9yKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspe1xuICAgIGMgPSBjYW1sX2JhX2dldF8xKHZfc3JjMix2X3NyY19wb3MraSk7XG4gICAgY2FtbF9iYV9zZXRfMSh2X2RzdDIsdl9kc3RfcG9zK2ksYyk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggdHlwZW9mIHk9PT1cImZ1bmN0aW9uXCIgKSB7IHguZnVuID0geTsgcmV0dXJuIDA7IH1cbiAgaWYoIHkuZnVuICkgeyB4LmZ1biA9IHkuZnVuOyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IG51bGwpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG4iLCIvL0ltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BldGVyb2xzb24vQmlnSW50ZWdlci5qcyM0ZTk5YjE1Yjc5NTEzMzhmMTY0NzI4Mzc3YzkwNmNhYWU1YTc4MjAyXG5cbi8vUHJvdmlkZXM6IGJpZ0ludCBjb25zdFxudmFyIGJpZ0ludCA9IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgQkFTRSA9IDFlNyxcbiAgICAgICAgTE9HX0JBU0UgPSA3LFxuICAgICAgICBNQVhfSU5UID0gOTAwNzE5OTI1NDc0MDk5MixcbiAgICAgICAgTUFYX0lOVF9BUlIgPSBzbWFsbFRvQXJyYXkoTUFYX0lOVCksXG4gICAgICAgIERFRkFVTFRfQUxQSEFCRVQgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuXG4gICAgdmFyIEJpZ0ludCA9IGpvb19nbG9iYWxfb2JqZWN0LkJpZ0ludDtcblxuICAgIHZhciBzdXBwb3J0c05hdGl2ZUJpZ0ludCA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIjtcblxuICAgIGZ1bmN0aW9uIEludGVnZXIodiwgcmFkaXgsIGFscGhhYmV0LCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEludGVnZXJbMF07XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXggIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiArcmFkaXggPT09IDEwICYmICFhbHBoYWJldCA/IHBhcnNlVmFsdWUodikgOiBwYXJzZUJhc2UodiwgcmFkaXgsIGFscGhhYmV0LCBjYXNlU2Vuc2l0aXZlKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmlnSW50ZWdlcih2YWx1ZSwgc2lnbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2lnbiA9IHNpZ247XG4gICAgICAgIHRoaXMuaXNTbWFsbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbWxfY3VzdG9tID0gJ196JztcbiAgICB9XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcblxuICAgIGZ1bmN0aW9uIFNtYWxsSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2lnbiA9IHZhbHVlIDwgMDtcbiAgICAgICAgdGhpcy5pc1NtYWxsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW1sX2N1c3RvbSA9ICdfeic7XG4gICAgfVxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcblxuICAgIGZ1bmN0aW9uIE5hdGl2ZUJpZ0ludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2FtbF9jdXN0b20gPSAnX3onO1xuICAgIH1cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XG5cbiAgICBmdW5jdGlvbiBpc1ByZWNpc2Uobikge1xuICAgICAgICByZXR1cm4gLU1BWF9JTlQgPCBuICYmIG4gPCBNQVhfSU5UO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNtYWxsVG9BcnJheShuKSB7IC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zIGRvZXNuJ3QgcmVmZXJlbmNlIEJBU0UsIG5lZWQgdG8gY2hhbmdlIHRoaXMgZnVuY3Rpb24gaWYgQkFTRSBjaGFuZ2VzXG4gICAgICAgIGlmIChuIDwgMWU3KVxuICAgICAgICAgICAgcmV0dXJuIFtuXTtcbiAgICAgICAgaWYgKG4gPCAxZTE0KVxuICAgICAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpXTtcbiAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTE0KV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlUb1NtYWxsKGFycikgeyAvLyBJZiBCQVNFIGNoYW5nZXMgdGhpcyBmdW5jdGlvbiBtYXkgbmVlZCB0byBjaGFuZ2VcbiAgICAgICAgdHJpbShhcnIpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDQgJiYgY29tcGFyZUFicyhhcnIsIE1BWF9JTlRfQVJSKSA8IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBhcnJbMF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gYXJyWzBdICsgYXJyWzFdICogQkFTRTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gYXJyWzBdICsgKGFyclsxXSArIGFyclsyXSAqIEJBU0UpICogQkFTRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaW0odikge1xuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xuICAgICAgICB3aGlsZSAodlstLWldID09PSAwKTtcbiAgICAgICAgdi5sZW5ndGggPSBpICsgMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHsgLy8gZnVuY3Rpb24gc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gWWFmZmxlJ3MgbGlicmFyeSBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0JpZ0ludGVnZXJcbiAgICAgICAgdmFyIHggPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgeFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xuICAgICAgICBpZiAobiA+IDApIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZChhLCBiKSB7IC8vIGFzc3VtZXMgYSBhbmQgYiBhcmUgYXJyYXlzIHdpdGggYS5sZW5ndGggPj0gYi5sZW5ndGhcbiAgICAgICAgdmFyIGxfYSA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgbF9iID0gYi5sZW5ndGgsXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGxfYSksXG4gICAgICAgICAgICBjYXJyeSA9IDAsXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIHN1bSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxfYjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gPSBhW2ldICsgYltpXSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBzdW0gPj0gYmFzZSA/IDEgOiAwO1xuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGxfYSkge1xuICAgICAgICAgICAgc3VtID0gYVtpXSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBzdW0gPT09IGJhc2UgPyAxIDogMDtcbiAgICAgICAgICAgIHJbaSsrXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgPiAwKSByLnB1c2goY2FycnkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRBbnkoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggPj0gYi5sZW5ndGgpIHJldHVybiBhZGQoYSwgYik7XG4gICAgICAgIHJldHVybiBhZGQoYiwgYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU21hbGwoYSwgY2FycnkpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBjYXJyeSBpcyBudW1iZXIgd2l0aCAwIDw9IGNhcnJ5IDwgTUFYX0lOVFxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgc3VtLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gPSBhW2ldIC0gYmFzZSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHN1bSAvIGJhc2UpO1xuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcbiAgICAgICAgICAgIGNhcnJ5ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgcltpKytdID0gY2FycnkgJSBiYXNlO1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbChhLCBNYXRoLmFicyhiKSksIHRoaXMuc2lnbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZEFueShhLCBiKSwgdGhpcy5zaWduKTtcbiAgICB9O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBsdXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKGEgKyBiKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSArIGIpO1xuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShNYXRoLmFicyhiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGIsIE1hdGguYWJzKGEpKSwgYSA8IDApO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgKyBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcbiAgICB9XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5wbHVzID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hZGQ7XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiKSB7IC8vIGFzc3VtZXMgYSBhbmQgYiBhcmUgYXJyYXlzIHdpdGggYSA+PSBiXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShhX2wpLFxuICAgICAgICAgICAgYm9ycm93ID0gMCxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgaSwgZGlmZmVyZW5jZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJfbDsgaSsrKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSAtIGJvcnJvdyAtIGJbaV07XG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlICs9IGJhc2U7XG4gICAgICAgICAgICAgICAgYm9ycm93ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBib3Jyb3cgPSAwO1xuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gYl9sOyBpIDwgYV9sOyBpKyspIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93O1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSBkaWZmZXJlbmNlICs9IGJhc2U7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByW2krK10gPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBhX2w7IGkrKykge1xuICAgICAgICAgICAgcltpXSA9IGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgdHJpbShyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VidHJhY3RBbnkoYSwgYiwgc2lnbikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChjb21wYXJlQWJzKGEsIGIpID49IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYSwgYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGIsIGEpO1xuICAgICAgICAgICAgc2lnbiA9ICFzaWduO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXJyYXlUb1NtYWxsKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHNpZ24pIHZhbHVlID0gLXZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih2YWx1ZSwgc2lnbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VidHJhY3RTbWFsbChhLCBiLCBzaWduKSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgYiBpcyBudW1iZXIgd2l0aCAwIDw9IGIgPCBNQVhfSU5UXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxuICAgICAgICAgICAgY2FycnkgPSAtYixcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgaSwgZGlmZmVyZW5jZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gYmFzZSk7XG4gICAgICAgICAgICBkaWZmZXJlbmNlICU9IGJhc2U7XG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZSA8IDAgPyBkaWZmZXJlbmNlICsgYmFzZSA6IGRpZmZlcmVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgciA9IGFycmF5VG9TbWFsbChyKTtcbiAgICAgICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoc2lnbikgciA9IC1yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIocik7XG4gICAgICAgIH0gcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKVxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwoYSwgTWF0aC5hYnMoYiksIHRoaXMuc2lnbik7XG4gICAgICAgIHJldHVybiBzdWJ0cmFjdEFueShhLCBiLCB0aGlzLnNpZ24pO1xuICAgIH07XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEgLSBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChiLCBNYXRoLmFicyhhKSwgYSA+PSAwKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgLSBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcbiAgICB9XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5taW51cyA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuc3VidHJhY3Q7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih0aGlzLnZhbHVlLCAhdGhpcy5zaWduKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2lnbiA9IHRoaXMuc2lnbjtcbiAgICAgICAgdmFyIHNtYWxsID0gbmV3IFNtYWxsSW50ZWdlcigtdGhpcy52YWx1ZSk7XG4gICAgICAgIHNtYWxsLnNpZ24gPSAhc2lnbjtcbiAgICAgICAgcmV0dXJuIHNtYWxsO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KC10aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih0aGlzLnZhbHVlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoTWF0aC5hYnModGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgPj0gMCA/IHRoaXMudmFsdWUgOiAtdGhpcy52YWx1ZSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtdWx0aXBseUxvbmcoYSwgYikge1xuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcbiAgICAgICAgICAgIGwgPSBhX2wgKyBiX2wsXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCksXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIHByb2R1Y3QsIGNhcnJ5LCBpLCBhX2ksIGJfajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFfbDsgKytpKSB7XG4gICAgICAgICAgICBhX2kgPSBhW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiX2w7ICsraikge1xuICAgICAgICAgICAgICAgIGJfaiA9IGJbal07XG4gICAgICAgICAgICAgICAgcHJvZHVjdCA9IGFfaSAqIGJfaiArIHJbaSArIGpdO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xuICAgICAgICAgICAgICAgIHJbaSArIGogKyAxXSArPSBjYXJyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmltKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIHxifCA8IEJBU0VcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIGNhcnJ5ID0gMCxcbiAgICAgICAgICAgIHByb2R1Y3QsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHByb2R1Y3QgPSBhW2ldICogYiArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcbiAgICAgICAgICAgIHJbaV0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgIHJbaSsrXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoaWZ0TGVmdCh4LCBuKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSByLnB1c2goMCk7XG4gICAgICAgIHJldHVybiByLmNvbmNhdCh4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdWx0aXBseUthcmF0c3ViYSh4LCB5KSB7XG4gICAgICAgIHZhciBuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgICAgICBpZiAobiA8PSAzMCkgcmV0dXJuIG11bHRpcGx5TG9uZyh4LCB5KTtcbiAgICAgICAgbiA9IE1hdGguY2VpbChuIC8gMik7XG5cbiAgICAgICAgdmFyIGIgPSB4LnNsaWNlKG4pLFxuICAgICAgICAgICAgYSA9IHguc2xpY2UoMCwgbiksXG4gICAgICAgICAgICBkID0geS5zbGljZShuKSxcbiAgICAgICAgICAgIGMgPSB5LnNsaWNlKDAsIG4pO1xuXG4gICAgICAgIHZhciBhYyA9IG11bHRpcGx5S2FyYXRzdWJhKGEsIGMpLFxuICAgICAgICAgICAgYmQgPSBtdWx0aXBseUthcmF0c3ViYShiLCBkKSxcbiAgICAgICAgICAgIGFiY2QgPSBtdWx0aXBseUthcmF0c3ViYShhZGRBbnkoYSwgYiksIGFkZEFueShjLCBkKSk7XG5cbiAgICAgICAgdmFyIHByb2R1Y3QgPSBhZGRBbnkoYWRkQW55KGFjLCBzaGlmdExlZnQoc3VidHJhY3Qoc3VidHJhY3QoYWJjZCwgYWMpLCBiZCksIG4pKSwgc2hpZnRMZWZ0KGJkLCAyICogbikpO1xuICAgICAgICB0cmltKHByb2R1Y3QpO1xuICAgICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBhIHN1cmZhY2UgZml0IG9mIGEgZ3JhcGggcGxvdHRpbmcgdGhlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VcbiAgICAvLyBiZXR3ZWVuIGxvbmcgbXVsdGlwbGljYXRpb24gYW5kIGthcmF0c3ViYSBtdWx0aXBsaWNhdGlvbiB2ZXJzdXMgdGhlIGxlbmd0aHMgb2YgdGhlIHR3byBhcnJheXMuXG4gICAgZnVuY3Rpb24gdXNlS2FyYXRzdWJhKGwxLCBsMikge1xuICAgICAgICByZXR1cm4gLTAuMDEyICogbDEgLSAwLjAxMiAqIGwyICsgMC4wMDAwMTUgKiBsMSAqIGwyID4gMDtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZSxcbiAgICAgICAgICAgIHNpZ24gPSB0aGlzLnNpZ24gIT09IG4uc2lnbixcbiAgICAgICAgICAgIGFicztcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgaWYgKGIgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICAgICAgaWYgKGIgPT09IDEpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKGIgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzKGIpO1xuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChhLCBhYnMpLCBzaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlS2FyYXRzdWJhKGEubGVuZ3RoLCBiLmxlbmd0aCkpIC8vIEthcmF0c3ViYSBpcyBvbmx5IGZhc3RlciBmb3IgY2VydGFpbiBhcnJheSBzaXplc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5S2FyYXRzdWJhKGEsIGIpLCBzaWduKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhhLCBiKSwgc2lnbik7XG4gICAgfTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRpbWVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XG5cbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoYSwgYiwgc2lnbikgeyAvLyBhID49IDBcbiAgICAgICAgaWYgKGEgPCBCQVNFKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChiLCBhKSwgc2lnbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhiLCBzbWFsbFRvQXJyYXkoYSkpLCBzaWduKTtcbiAgICB9XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5fbXVsdGlwbHlCeVNtYWxsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGlzUHJlY2lzZShhLnZhbHVlICogdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEudmFsdWUgKiB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCBzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XG4gICAgfTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5fbXVsdGlwbHlCeVNtYWxsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICBpZiAoYS52YWx1ZSA9PT0gMSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChhLnZhbHVlID09PSAtMSkgcmV0dXJuIHRoaXMubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoTWF0aC5hYnMoYS52YWx1ZSksIHRoaXMudmFsdWUsIHRoaXMuc2lnbiAhPT0gYS5zaWduKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2KS5fbXVsdGlwbHlCeVNtYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50aW1lcyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVCaWdJbnQodGhpcy52YWx1ZSAqIHBhcnNlVmFsdWUodikudmFsdWUpO1xuICAgIH1cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRpbWVzID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tdWx0aXBseTtcblxuICAgIGZ1bmN0aW9uIHNxdWFyZShhKSB7XG4gICAgICAgIC8vY29uc29sZS5hc3NlcnQoMiAqIEJBU0UgKiBCQVNFIDwgTUFYX0lOVCk7XG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCArIGwpLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBhX2o7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGFfaSA9IGFbaV07XG4gICAgICAgICAgICBjYXJyeSA9IDAgLSBhX2kgKiBhX2k7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgIGFfaiA9IGFbal07XG4gICAgICAgICAgICAgICAgcHJvZHVjdCA9IDIgKiAoYV9pICogYV9qKSArIHJbaSArIGpdICsgY2Fycnk7XG4gICAgICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHByb2R1Y3QgLyBiYXNlKTtcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByW2kgKyBsXSA9IGNhcnJ5O1xuICAgICAgICB9XG4gICAgICAgIHRyaW0ocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZSh0aGlzLnZhbHVlKSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSAqIHRoaXMudmFsdWU7XG4gICAgICAgIGlmIChpc1ByZWNpc2UodmFsdWUpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUoc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSksIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICogdGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGl2TW9kMShhLCBiKSB7IC8vIExlZnQgb3ZlciBmcm9tIHByZXZpb3VzIHZlcnNpb24uIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDIgb24gc21hbGxlciBpbnB1dCBzaXplcy5cbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCA9IGJbYl9sIC0gMV0sXG4gICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uXG4gICAgICAgICAgICBsYW1iZGEgPSBNYXRoLmNlaWwoYmFzZSAvICgyICogZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSksXG4gICAgICAgICAgICByZW1haW5kZXIgPSBtdWx0aXBseVNtYWxsKGEsIGxhbWJkYSksXG4gICAgICAgICAgICBkaXZpc29yID0gbXVsdGlwbHlTbWFsbChiLCBsYW1iZGEpLFxuICAgICAgICAgICAgcXVvdGllbnREaWdpdCwgc2hpZnQsIGNhcnJ5LCBib3Jyb3csIGksIGwsIHE7XG4gICAgICAgIGlmIChyZW1haW5kZXIubGVuZ3RoIDw9IGFfbCkgcmVtYWluZGVyLnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3IucHVzaCgwKTtcbiAgICAgICAgZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0ID0gZGl2aXNvcltiX2wgLSAxXTtcbiAgICAgICAgZm9yIChzaGlmdCA9IGFfbCAtIGJfbDsgc2hpZnQgPj0gMDsgc2hpZnQtLSkge1xuICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IGJhc2UgLSAxO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gIT09IGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkge1xuICAgICAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBNYXRoLmZsb29yKChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICogYmFzZSArIHJlbWFpbmRlcltzaGlmdCArIGJfbCAtIDFdKSAvIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBxdW90aWVudERpZ2l0IDw9IGJhc2UgLSAxXG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBib3Jyb3cgPSAwO1xuICAgICAgICAgICAgbCA9IGRpdmlzb3IubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhcnJ5ICs9IHF1b3RpZW50RGlnaXQgKiBkaXZpc29yW2ldO1xuICAgICAgICAgICAgICAgIHEgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XG4gICAgICAgICAgICAgICAgYm9ycm93ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gKGNhcnJ5IC0gcSAqIGJhc2UpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gcTtcbiAgICAgICAgICAgICAgICBpZiAoYm9ycm93IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGJvcnJvdyArIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIGJvcnJvdyA9IC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93O1xuICAgICAgICAgICAgICAgICAgICBib3Jyb3cgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChib3Jyb3cgIT09IDApIHtcbiAgICAgICAgICAgICAgICBxdW90aWVudERpZ2l0IC09IDE7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2FycnkgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSBiYXNlICsgZGl2aXNvcltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcnJ5IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBjYXJyeSArIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGNhcnJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvcnJvdyArPSBjYXJyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtzaGlmdF0gPSBxdW90aWVudERpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlbm9ybWFsaXphdGlvblxuICAgICAgICByZW1haW5kZXIgPSBkaXZNb2RTbWFsbChyZW1haW5kZXIsIGxhbWJkYSlbMF07XG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChyZW1haW5kZXIpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXZNb2QyKGEsIGIpIHsgLy8gSW1wbGVtZW50YXRpb24gaWRlYSBzaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBTaWxlbnQgTWF0dCdzIGxpYnJhcnkgaHR0cDovL3NpbGVudG1hdHQuY29tL2JpZ2ludGVnZXIvXG4gICAgICAgIC8vIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDEgb24gbGFyZ2VyIGlucHV0IHNpemVzLlxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgcGFydCA9IFtdLFxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXG4gICAgICAgICAgICBndWVzcywgeGxlbiwgaGlnaHgsIGhpZ2h5LCBjaGVjaztcbiAgICAgICAgd2hpbGUgKGFfbCkge1xuICAgICAgICAgICAgcGFydC51bnNoaWZ0KGFbLS1hX2xdKTtcbiAgICAgICAgICAgIHRyaW0ocGFydCk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZUFicyhwYXJ0LCBiKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhsZW4gPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIGhpZ2h4ID0gcGFydFt4bGVuIC0gMV0gKiBiYXNlICsgcGFydFt4bGVuIC0gMl07XG4gICAgICAgICAgICBoaWdoeSA9IGJbYl9sIC0gMV0gKiBiYXNlICsgYltiX2wgLSAyXTtcbiAgICAgICAgICAgIGlmICh4bGVuID4gYl9sKSB7XG4gICAgICAgICAgICAgICAgaGlnaHggPSAoaGlnaHggKyAxKSAqIGJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBndWVzcyA9IE1hdGguY2VpbChoaWdoeCAvIGhpZ2h5KTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaGVjayA9IG11bHRpcGx5U21hbGwoYiwgZ3Vlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKGNoZWNrLCBwYXJ0KSA8PSAwKSBicmVhaztcbiAgICAgICAgICAgICAgICBndWVzcy0tO1xuICAgICAgICAgICAgfSB3aGlsZSAoZ3Vlc3MpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ3Vlc3MpO1xuICAgICAgICAgICAgcGFydCA9IHN1YnRyYWN0KHBhcnQsIGNoZWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocGFydCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdk1vZFNtYWxsKHZhbHVlLCBsYW1iZGEpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHF1b3RpZW50ID0gY3JlYXRlQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxuICAgICAgICAgICAgaSwgcSwgcmVtYWluZGVyLCBkaXZpc29yO1xuICAgICAgICByZW1haW5kZXIgPSAwO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgZGl2aXNvciA9IHJlbWFpbmRlciAqIGJhc2UgKyB2YWx1ZVtpXTtcbiAgICAgICAgICAgIHEgPSB0cnVuY2F0ZShkaXZpc29yIC8gbGFtYmRhKTtcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IGRpdmlzb3IgLSBxICogbGFtYmRhO1xuICAgICAgICAgICAgcXVvdGllbnRbaV0gPSBxIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCByZW1haW5kZXIgfCAwXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXZNb2RBbnkoc2VsZiwgdikge1xuICAgICAgICB2YXIgdmFsdWUsIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICBpZiAoc3VwcG9ydHNOYXRpdmVCaWdJbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IE5hdGl2ZUJpZ0ludChzZWxmLnZhbHVlIC8gbi52YWx1ZSksIG5ldyBOYXRpdmVCaWdJbnQoc2VsZi52YWx1ZSAlIG4udmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHNlbGYudmFsdWUsIGIgPSBuLnZhbHVlO1xuICAgICAgICB2YXIgcXVvdGllbnQ7XG4gICAgICAgIGlmIChiID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGl2aWRlIGJ5IHplcm9cIik7XG4gICAgICAgIGlmIChzZWxmLmlzU21hbGwpIHtcbiAgICAgICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUoYSAvIGIpKSwgbmV3IFNtYWxsSW50ZWdlcihhICUgYildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMSkgcmV0dXJuIFtzZWxmLCBJbnRlZ2VyWzBdXTtcbiAgICAgICAgICAgIGlmIChiID09IC0xKSByZXR1cm4gW3NlbGYubmVnYXRlKCksIEludGVnZXJbMF1dO1xuICAgICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGIpO1xuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRpdk1vZFNtYWxsKGEsIGFicyk7XG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBhcnJheVRvU21hbGwodmFsdWVbMF0pO1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaWduKSByZW1haW5kZXIgPSAtcmVtYWluZGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbiAhPT0gbi5zaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KSwgbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgc2VsZi5zaWduICE9PSBuLnNpZ24pLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShhYnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJpc29uID0gY29tcGFyZUFicyhhLCBiKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IC0xKSByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PT0gMCkgcmV0dXJuIFtJbnRlZ2VyW3NlbGYuc2lnbiA9PT0gbi5zaWduID8gMSA6IC0xXSwgSW50ZWdlclswXV07XG5cbiAgICAgICAgLy8gZGl2TW9kMSBpcyBmYXN0ZXIgb24gc21hbGxlciBpbnB1dCBzaXplc1xuICAgICAgICBpZiAoYS5sZW5ndGggKyBiLmxlbmd0aCA8PSAyMDApXG4gICAgICAgICAgICB2YWx1ZSA9IGRpdk1vZDEoYSwgYik7XG4gICAgICAgIGVsc2UgdmFsdWUgPSBkaXZNb2QyKGEsIGIpO1xuXG4gICAgICAgIHF1b3RpZW50ID0gdmFsdWVbMF07XG4gICAgICAgIHZhciBxU2lnbiA9IHNlbGYuc2lnbiAhPT0gbi5zaWduLFxuICAgICAgICAgICAgbW9kID0gdmFsdWVbMV0sXG4gICAgICAgICAgICBtU2lnbiA9IHNlbGYuc2lnbjtcbiAgICAgICAgaWYgKHR5cGVvZiBxdW90aWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHFTaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcbiAgICAgICAgICAgIHF1b3RpZW50ID0gbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCk7XG4gICAgICAgIH0gZWxzZSBxdW90aWVudCA9IG5ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBxU2lnbik7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAobVNpZ24pIG1vZCA9IC1tb2Q7XG4gICAgICAgICAgICBtb2QgPSBuZXcgU21hbGxJbnRlZ2VyKG1vZCk7XG4gICAgICAgIH0gZWxzZSBtb2QgPSBuZXcgQmlnSW50ZWdlcihtb2QsIG1TaWduKTtcbiAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgbW9kXTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGl2TW9kQW55KHRoaXMsIHYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVvdGllbnQ6IHJlc3VsdFswXSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogcmVzdWx0WzFdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmRpdm1vZCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kO1xuXG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gZGl2TW9kQW55KHRoaXMsIHYpWzBdO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5vdmVyID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlIC8gcGFyc2VWYWx1ZSh2KS52YWx1ZSk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm92ZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm92ZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGU7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gZGl2TW9kQW55KHRoaXMsIHYpWzFdO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5tb2QgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnJlbWFpbmRlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHRoaXMudmFsdWUgJSBwYXJzZVZhbHVlKHYpLnZhbHVlKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2Q7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlLFxuICAgICAgICAgICAgdmFsdWUsIHgsIHk7XG4gICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclsxXTtcbiAgICAgICAgaWYgKGEgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICBpZiAoYSA9PT0gMSkgcmV0dXJuIEludGVnZXJbMV07XG4gICAgICAgIGlmIChhID09PSAtMSkgcmV0dXJuIG4uaXNFdmVuKCkgPyBJbnRlZ2VyWzFdIDogSW50ZWdlclstMV07XG4gICAgICAgIGlmIChuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbi5pc1NtYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZXhwb25lbnQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBpcyB0b28gbGFyZ2UuXCIpO1xuICAgICAgICBpZiAodGhpcy5pc1NtYWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlID0gTWF0aC5wb3coYSwgYikpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IHRoaXM7XG4gICAgICAgIHkgPSBJbnRlZ2VyWzFdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGIgJiAxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XG4gICAgICAgICAgICAgICAgLS1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPT09IDApIGJyZWFrO1xuICAgICAgICAgICAgYiAvPSAyO1xuICAgICAgICAgICAgeCA9IHguc3F1YXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnBvdyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdztcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xuICAgICAgICB2YXIgXzAgPSBCaWdJbnQoMCksIF8xID0gQmlnSW50KDEpLCBfMiA9IEJpZ0ludCgyKTtcbiAgICAgICAgaWYgKGIgPT09IF8wKSByZXR1cm4gSW50ZWdlclsxXTtcbiAgICAgICAgaWYgKGEgPT09IF8wKSByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgaWYgKGEgPT09IF8xKSByZXR1cm4gSW50ZWdlclsxXTtcbiAgICAgICAgaWYgKGEgPT09IEJpZ0ludCgtMSkpIHJldHVybiBuLmlzRXZlbigpID8gSW50ZWdlclsxXSA6IEludGVnZXJbLTFdO1xuICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkpIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KF8wKTtcbiAgICAgICAgdmFyIHggPSB0aGlzO1xuICAgICAgICB2YXIgeSA9IEludGVnZXJbMV07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoKGIgJiBfMSkgPT09IF8xKSB7XG4gICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XG4gICAgICAgICAgICAgICAgLS1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPT09IF8wKSBicmVhaztcbiAgICAgICAgICAgIGIgLz0gXzI7XG4gICAgICAgICAgICB4ID0geC5zcXVhcmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZXhwLCBtb2QpIHtcbiAgICAgICAgZXhwID0gcGFyc2VWYWx1ZShleHApO1xuICAgICAgICBtb2QgPSBwYXJzZVZhbHVlKG1vZCk7XG4gICAgICAgIGlmIChtb2QuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0YWtlIG1vZFBvdyB3aXRoIG1vZHVsdXMgMFwiKTtcbiAgICAgICAgdmFyIHIgPSBJbnRlZ2VyWzFdLFxuICAgICAgICAgICAgYmFzZSA9IHRoaXMubW9kKG1vZCk7XG4gICAgICAgIGlmIChleHAuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBleHAgPSBleHAubXVsdGlwbHkoSW50ZWdlclstMV0pO1xuICAgICAgICAgICAgYmFzZSA9IGJhc2UubW9kSW52KG1vZCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGV4cC5pc1Bvc2l0aXZlKCkpIHtcbiAgICAgICAgICAgIGlmIChiYXNlLmlzWmVybygpKSByZXR1cm4gSW50ZWdlclswXTtcbiAgICAgICAgICAgIGlmIChleHAuaXNPZGQoKSkgciA9IHIubXVsdGlwbHkoYmFzZSkubW9kKG1vZCk7XG4gICAgICAgICAgICBleHAgPSBleHAuZGl2aWRlKDIpO1xuICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc3F1YXJlKCkubW9kKG1vZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1vZFBvdyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93O1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZUFicyhhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGFbaV0gPiBiW2ldID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xuICAgICAgICBpZiAobi5pc1NtYWxsKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYik7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXG4gICAgICAgICAgICBhID0gTWF0aC5hYnModGhpcy52YWx1ZSksXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xuICAgICAgICAgICAgYiA9IE1hdGguYWJzKGIpO1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2YXIgYiA9IHBhcnNlVmFsdWUodikudmFsdWU7XG4gICAgICAgIGEgPSBhID49IDAgPyBhIDogLWE7XG4gICAgICAgIGIgPSBiID49IDAgPyBiIDogLWI7XG4gICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBhYm91dCBjb21wYXJpc29uIHdpdGggSW5maW5pdHk6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRlcm9sc29uL0JpZ0ludGVnZXIuanMvaXNzdWVzLzYxXG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gbi5zaWduID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24gPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYikgKiAodGhpcy5zaWduID8gLTEgOiAxKTtcbiAgICB9O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XG5cbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhID09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcbiAgICAgICAgICAgIHJldHVybiBhIDwgMCA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSA8IDAgPyAxIDogLTE7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtcblxuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIGIgPSBwYXJzZVZhbHVlKHYpLnZhbHVlO1xuICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbiAgICB9XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5jb21wYXJlVG8gPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmNvbXBhcmU7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID09PSAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5lcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpICE9PSAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5uZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm5vdEVxdWFscyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmd0ID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ncmVhdGVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmd0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcjtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPCAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sdCA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUubGVzc2VyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sdCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyID0gQmlnSW50ZWdlci5wcm90b3R5cGUubHQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXI7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID49IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmdlcSA9IE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5nZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdlcSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscztcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA8PSAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5sZXEgPSBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHM7XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAwO1xuICAgIH07XG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIEJpZ0ludCgxKSkgPT09IEJpZ0ludCgwKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlWzBdICYgMSkgPT09IDE7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiAxKSA9PT0gMTtcbiAgICB9O1xuICAgIE5hdGl2ZUJpZ0ludC5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIEJpZ0ludCgxKSkgPT09IEJpZ0ludCgxKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2lnbjtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPiAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbjtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPCAwO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc05lZ2F0aXZlID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc05lZ2F0aXZlO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMudmFsdWUpID09PSAxO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFicygpLnZhbHVlID09PSBCaWdJbnQoMSk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IDA7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IEJpZ0ludCgwKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xuICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobi5pc1VuaXQoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChuLmNvbXBhcmVBYnMoMikgPT09IDApIHJldHVybiB0aGlzLmlzRXZlbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2QobikuaXNaZXJvKCk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5O1xuXG4gICAgZnVuY3Rpb24gaXNCYXNpY1ByaW1lKHYpIHtcbiAgICAgICAgdmFyIG4gPSB2LmFicygpO1xuICAgICAgICBpZiAobi5pc1VuaXQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobi5lcXVhbHMoMikgfHwgbi5lcXVhbHMoMykgfHwgbi5lcXVhbHMoNSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobi5pc0V2ZW4oKSB8fCBuLmlzRGl2aXNpYmxlQnkoMykgfHwgbi5pc0RpdmlzaWJsZUJ5KDUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChuLmxlc3Nlcig0OSkpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgcHJpbWU6IGxldCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZpZ3VyZSBpdCBvdXRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaWxsZXJSYWJpblRlc3QobiwgYSkge1xuICAgICAgICB2YXIgblByZXYgPSBuLnByZXYoKSxcbiAgICAgICAgICAgIGIgPSBuUHJldixcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgZCwgdCwgaSwgeDtcbiAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIGIgPSBiLmRpdmlkZSgyKSwgcisrO1xuICAgICAgICBuZXh0OiBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG4ubGVzc2VyKGFbaV0pKSBjb250aW51ZTtcbiAgICAgICAgICAgIHggPSBiaWdJbnQoYVtpXSkubW9kUG93KGIsIG4pO1xuICAgICAgICAgICAgaWYgKHguaXNVbml0KCkgfHwgeC5lcXVhbHMoblByZXYpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoZCA9IHIgLSAxOyBkICE9IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpLm1vZChuKTtcbiAgICAgICAgICAgICAgICBpZiAoeC5pc1VuaXQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh4LmVxdWFscyhuUHJldikpIGNvbnRpbnVlIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gU2V0IFwic3RyaWN0XCIgdG8gdHJ1ZSB0byBmb3JjZSBHUkgtc3VwcG9ydGVkIGxvd2VyIGJvdW5kIG9mIDIqbG9nKE4pXjJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gZnVuY3Rpb24gKHN0cmljdCkge1xuICAgICAgICB2YXIgaXNQcmltZSA9IGlzQmFzaWNQcmltZSh0aGlzKTtcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIGJpdHMgPSBuLmJpdExlbmd0aCgpO1xuICAgICAgICBpZiAoYml0cyA8PSA2NClcbiAgICAgICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzN10pO1xuICAgICAgICB2YXIgbG9nTiA9IE1hdGgubG9nKDIpICogYml0cy50b0pTTnVtYmVyKCk7XG4gICAgICAgIHZhciB0ID0gTWF0aC5jZWlsKChzdHJpY3QgPT09IHRydWUpID8gKDIgKiBNYXRoLnBvdyhsb2dOLCAyKSkgOiBsb2dOKTtcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBpID0gMDsgaSA8IHQ7IGkrKykge1xuICAgICAgICAgICAgYS5wdXNoKGJpZ0ludChpICsgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzUHJpbWUgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xuICAgICAgICB2YXIgbiA9IHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciB0ID0gaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkID8gNSA6IGl0ZXJhdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGEgPSBbXSwgaSA9IDA7IGkgPCB0OyBpKyspIHtcbiAgICAgICAgICAgIGEucHVzaChiaWdJbnQucmFuZEJldHdlZW4oMiwgbi5taW51cygyKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHQgPSBiaWdJbnQuemVybywgbmV3VCA9IGJpZ0ludC5vbmUsIHIgPSBwYXJzZVZhbHVlKG4pLCBuZXdSID0gdGhpcy5hYnMoKSwgcSwgbGFzdFQsIGxhc3RSO1xuICAgICAgICB3aGlsZSAoIW5ld1IuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHEgPSByLmRpdmlkZShuZXdSKTtcbiAgICAgICAgICAgIGxhc3RUID0gdDtcbiAgICAgICAgICAgIGxhc3RSID0gcjtcbiAgICAgICAgICAgIHQgPSBuZXdUO1xuICAgICAgICAgICAgciA9IG5ld1I7XG4gICAgICAgICAgICBuZXdUID0gbGFzdFQuc3VidHJhY3QocS5tdWx0aXBseShuZXdUKSk7XG4gICAgICAgICAgICBuZXdSID0gbGFzdFIuc3VidHJhY3QocS5tdWx0aXBseShuZXdSKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyLmlzVW5pdCgpKSB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgYW5kIFwiICsgbi50b1N0cmluZygpICsgXCIgYXJlIG5vdCBjby1wcmltZVwiKTtcbiAgICAgICAgaWYgKHQuY29tcGFyZSgwKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHQgPSB0LmFkZChuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0Lm5lZ2F0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLm1vZEludiA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kSW52ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52O1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbikge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLCAxKSwgdGhpcy5zaWduKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICsgMSA8IE1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlICsgMSk7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUiwgZmFsc2UpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlICsgQmlnSW50KDEpKTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAodGhpcy5zaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsIDEpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcbiAgICB9O1xuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIC0gMSA+IC1NQVhfSU5UKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSAtIDEpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsIHRydWUpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludCh0aGlzLnZhbHVlIC0gQmlnSW50KDEpKTtcbiAgICB9XG5cbiAgICB2YXIgcG93ZXJzT2ZUd28gPSBbMV07XG4gICAgd2hpbGUgKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSA8PSBCQVNFKSBwb3dlcnNPZlR3by5wdXNoKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSk7XG4gICAgdmFyIHBvd2VyczJMZW5ndGggPSBwb3dlcnNPZlR3by5sZW5ndGgsIGhpZ2hlc3RQb3dlcjIgPSBwb3dlcnNPZlR3b1twb3dlcnMyTGVuZ3RoIC0gMV07XG5cbiAgICBmdW5jdGlvbiBzaGlmdF9pc1NtYWxsKG4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG4pIDw9IEJBU0U7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLnRvSlNOdW1iZXIoKTtcbiAgICAgICAgaWYgKCFzaGlmdF9pc1NtYWxsKG4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0KC1uKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICAgIGlmIChyZXN1bHQuaXNaZXJvKCkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShoaWdoZXN0UG93ZXIyKTtcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseShwb3dlcnNPZlR3b1tuXSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0O1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciByZW1RdW87XG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KS50b0pTTnVtYmVyKCk7XG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDwgMCkgcmV0dXJuIHRoaXMuc2hpZnRMZWZ0KC1uKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaXNaZXJvKCkgfHwgKHJlc3VsdC5pc05lZ2F0aXZlKCkgJiYgcmVzdWx0LmlzVW5pdCgpKSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIGhpZ2hlc3RQb3dlcjIpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIHBvd2Vyc09mVHdvW25dKTtcbiAgICAgICAgcmV0dXJuIHJlbVF1b1sxXS5pc05lZ2F0aXZlKCkgPyByZW1RdW9bMF0ucHJldigpIDogcmVtUXVvWzBdO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodDtcblxuICAgIGZ1bmN0aW9uIGJpdHdpc2UoeCwgeSwgZm4pIHtcbiAgICAgICAgeSA9IHBhcnNlVmFsdWUoeSk7XG4gICAgICAgIHZhciB4U2lnbiA9IHguaXNOZWdhdGl2ZSgpLCB5U2lnbiA9IHkuaXNOZWdhdGl2ZSgpO1xuICAgICAgICB2YXIgeFJlbSA9IHhTaWduID8geC5ub3QoKSA6IHgsXG4gICAgICAgICAgICB5UmVtID0geVNpZ24gPyB5Lm5vdCgpIDogeTtcbiAgICAgICAgdmFyIHhEaWdpdCA9IDAsIHlEaWdpdCA9IDA7XG4gICAgICAgIHZhciB4RGl2TW9kID0gbnVsbCwgeURpdk1vZCA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKCF4UmVtLmlzWmVybygpIHx8ICF5UmVtLmlzWmVybygpKSB7XG4gICAgICAgICAgICB4RGl2TW9kID0gZGl2TW9kQW55KHhSZW0sIGhpZ2hlc3RQb3dlcjIpO1xuICAgICAgICAgICAgeERpZ2l0ID0geERpdk1vZFsxXS50b0pTTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAoeFNpZ24pIHtcbiAgICAgICAgICAgICAgICB4RGlnaXQgPSBoaWdoZXN0UG93ZXIyIC0gMSAtIHhEaWdpdDsgLy8gdHdvJ3MgY29tcGxlbWVudCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5RGl2TW9kID0gZGl2TW9kQW55KHlSZW0sIGhpZ2hlc3RQb3dlcjIpO1xuICAgICAgICAgICAgeURpZ2l0ID0geURpdk1vZFsxXS50b0pTTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAoeVNpZ24pIHtcbiAgICAgICAgICAgICAgICB5RGlnaXQgPSBoaWdoZXN0UG93ZXIyIC0gMSAtIHlEaWdpdDsgLy8gdHdvJ3MgY29tcGxlbWVudCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4UmVtID0geERpdk1vZFswXTtcbiAgICAgICAgICAgIHlSZW0gPSB5RGl2TW9kWzBdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4oeERpZ2l0LCB5RGlnaXQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VtID0gZm4oeFNpZ24gPyAxIDogMCwgeVNpZ24gPyAxIDogMCkgIT09IDAgPyBiaWdJbnQoLTEpIDogYmlnSW50KDApO1xuICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICBzdW0gPSBzdW0ubXVsdGlwbHkoaGlnaGVzdFBvd2VyMikuYWRkKGJpZ0ludChyZXN1bHRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkucHJldigpO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5ub3QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdDtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmFuZCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYW5kID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kO1xuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSB8IGI7IH0pO1xuICAgIH07XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS5vciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3IgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vcjtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIF4gYjsgfSk7XG4gICAgfTtcbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnhvciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUueG9yID0gQmlnSW50ZWdlci5wcm90b3R5cGUueG9yO1xuXG4gICAgdmFyIExPQk1BU0tfSSA9IDEgPDwgMzAsIExPQk1BU0tfQkkgPSAoQkFTRSAmIC1CQVNFKSAqIChCQVNFICYgLUJBU0UpIHwgTE9CTUFTS19JO1xuICAgIGZ1bmN0aW9uIHJvdWdoTE9CKG4pIHsgLy8gZ2V0IGxvd2VzdE9uZUJpdCAocm91Z2gpXG4gICAgICAgIC8vIFNtYWxsSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMzApXG4gICAgICAgIC8vIEJpZ0ludGVnZXI6IHJldHVybiBNaW4obG93ZXN0T25lQml0KG4pLCAxIDw8IDE0KSBbQkFTRT0xZTddXG4gICAgICAgIHZhciB2ID0gbi52YWx1ZSxcbiAgICAgICAgICAgIHggPSB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IHYgfCBMT0JNQVNLX0kgOlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2ID09PSBcImJpZ2ludFwiID8gdiB8IEJpZ0ludChMT0JNQVNLX0kpIDpcbiAgICAgICAgICAgICAgICAgICAgdlswXSArIHZbMV0gKiBCQVNFIHwgTE9CTUFTS19CSTtcbiAgICAgICAgcmV0dXJuIHggJiAteDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLCBiYXNlKSB7XG4gICAgICAgIGlmIChiYXNlLmNvbXBhcmVUbyh2YWx1ZSkgPD0gMCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGludGVnZXJMb2dhcml0aG0odmFsdWUsIGJhc2Uuc3F1YXJlKGJhc2UpKTtcbiAgICAgICAgICAgIHZhciBwID0gdG1wLnA7XG4gICAgICAgICAgICB2YXIgZSA9IHRtcC5lO1xuICAgICAgICAgICAgdmFyIHQgPSBwLm11bHRpcGx5KGJhc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHQuY29tcGFyZVRvKHZhbHVlKSA8PSAwID8geyBwOiB0LCBlOiBlICogMiArIDEgfSA6IHsgcDogcCwgZTogZSAqIDIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwOiBiaWdJbnQoMSksIGU6IDAgfTtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcztcbiAgICAgICAgaWYgKG4uY29tcGFyZVRvKGJpZ0ludCgwKSkgPCAwKSB7XG4gICAgICAgICAgICBuID0gbi5uZWdhdGUoKS5zdWJ0cmFjdChiaWdJbnQoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmNvbXBhcmVUbyhiaWdJbnQoMCkpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYmlnSW50KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaWdJbnQoaW50ZWdlckxvZ2FyaXRobShuLCBiaWdJbnQoMikpLmUpLmFkZChiaWdJbnQoMSkpO1xuICAgIH1cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLmJpdExlbmd0aCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIpIHtcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xuICAgICAgICByZXR1cm4gYS5ncmVhdGVyKGIpID8gYSA6IGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1pbihhLCBiKSB7XG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcbiAgICAgICAgcmV0dXJuIGEubGVzc2VyKGIpID8gYSA6IGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdjZChhLCBiKSB7XG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpLmFicygpO1xuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcbiAgICAgICAgaWYgKGEuZXF1YWxzKGIpKSByZXR1cm4gYTtcbiAgICAgICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBiO1xuICAgICAgICBpZiAoYi5pc1plcm8oKSkgcmV0dXJuIGE7XG4gICAgICAgIHZhciBjID0gSW50ZWdlclsxXSwgZCwgdDtcbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgZCA9IG1pbihyb3VnaExPQihhKSwgcm91Z2hMT0IoYikpO1xuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKGQpO1xuICAgICAgICAgICAgYiA9IGIuZGl2aWRlKGQpO1xuICAgICAgICAgICAgYyA9IGMubXVsdGlwbHkoZCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShyb3VnaExPQihhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICBiID0gYi5kaXZpZGUocm91Z2hMT0IoYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuZ3JlYXRlcihiKSkge1xuICAgICAgICAgICAgICAgIHQgPSBiOyBiID0gYTsgYSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5zdWJ0cmFjdChhKTtcbiAgICAgICAgfSB3aGlsZSAoIWIuaXNaZXJvKCkpO1xuICAgICAgICByZXR1cm4gYy5pc1VuaXQoKSA/IGEgOiBhLm11bHRpcGx5KGMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsY20oYSwgYikge1xuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYikuYWJzKCk7XG4gICAgICAgIHJldHVybiBhLmRpdmlkZShnY2QoYSwgYikpLm11bHRpcGx5KGIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5kQmV0d2VlbihhLCBiKSB7XG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcbiAgICAgICAgdmFyIGxvdyA9IG1pbihhLCBiKSwgaGlnaCA9IG1heChhLCBiKTtcbiAgICAgICAgdmFyIHJhbmdlID0gaGlnaC5zdWJ0cmFjdChsb3cpLmFkZCgxKTtcbiAgICAgICAgaWYgKHJhbmdlLmlzU21hbGwpIHJldHVybiBsb3cuYWRkKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKSk7XG4gICAgICAgIHZhciBkaWdpdHMgPSB0b0Jhc2UocmFuZ2UsIEJBU0UpLnZhbHVlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIHJlc3RyaWN0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvcCA9IHJlc3RyaWN0ZWQgPyBkaWdpdHNbaV0gOiBCQVNFO1xuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gdHJ1bmNhdGUoTWF0aC5yYW5kb20oKSAqIHRvcCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkaWdpdCk7XG4gICAgICAgICAgICBpZiAoZGlnaXQgPCB0b3ApIHJlc3RyaWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG93LmFkZChJbnRlZ2VyLmZyb21BcnJheShyZXN1bHQsIEJBU0UsIGZhbHNlKSk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlQmFzZSA9IGZ1bmN0aW9uICh0ZXh0LCBiYXNlLCBhbHBoYWJldCwgY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICBhbHBoYWJldCA9IGFscGhhYmV0IHx8IERFRkFVTFRfQUxQSEFCRVQ7XG4gICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGFscGhhYmV0ID0gYWxwaGFiZXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgYWJzQmFzZSA9IE1hdGguYWJzKGJhc2UpO1xuICAgICAgICB2YXIgYWxwaGFiZXRWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhbHBoYWJldFZhbHVlc1thbHBoYWJldFtpXV0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldO1xuICAgICAgICAgICAgaWYgKGMgPT09IFwiLVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjIGluIGFscGhhYmV0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhYmV0VmFsdWVzW2NdID49IGFic0Jhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiMVwiICYmIGFic0Jhc2UgPT09IDEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIgKyBiYXNlICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiYXNlID0gcGFyc2VWYWx1ZShiYXNlKTtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IFtdO1xuICAgICAgICB2YXIgaXNOZWdhdGl2ZSA9IHRleHRbMF0gPT09IFwiLVwiO1xuICAgICAgICBmb3IgKGkgPSBpc05lZ2F0aXZlID8gMSA6IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRleHRbaV07XG4gICAgICAgICAgICBpZiAoYyBpbiBhbHBoYWJldFZhbHVlcykgZGlnaXRzLnB1c2gocGFyc2VWYWx1ZShhbHBoYWJldFZhbHVlc1tjXSkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGRvIHsgaSsrOyB9IHdoaWxlICh0ZXh0W2ldICE9PSBcIj5cIiAmJiBpIDwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUodGV4dC5zbGljZShzdGFydCArIDEsIGkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgY2hhcmFjdGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xuICAgICAgICB2YXIgdmFsID0gSW50ZWdlclswXSwgcG93ID0gSW50ZWdlclsxXSwgaTtcbiAgICAgICAgZm9yIChpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuYWRkKGRpZ2l0c1tpXS50aW1lcyhwb3cpKTtcbiAgICAgICAgICAgIHBvdyA9IHBvdy50aW1lcyhiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZSA/IHZhbC5uZWdhdGUoKSA6IHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoZGlnaXQsIGFscGhhYmV0KSB7XG4gICAgICAgIGFscGhhYmV0ID0gYWxwaGFiZXQgfHwgREVGQVVMVF9BTFBIQUJFVDtcbiAgICAgICAgaWYgKGRpZ2l0IDwgYWxwaGFiZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbZGlnaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjxcIiArIGRpZ2l0ICsgXCI+XCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9CYXNlKG4sIGJhc2UpIHtcbiAgICAgICAgYmFzZSA9IGJpZ0ludChiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbm9uemVybyBudW1iZXJzIHRvIGJhc2UgMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UuZXF1YWxzKC0xKSkge1xuICAgICAgICAgICAgaWYgKG4uaXNaZXJvKCkpIHJldHVybiB7IHZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlIH07XG4gICAgICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoLW4udG9KU051bWJlcigpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsIFsxLCAwXSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYXJyID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkobi50b0pTTnVtYmVyKCkgLSAxKSlcbiAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMCwgMV0pO1xuICAgICAgICAgICAgYXJyLnVuc2hpZnQoWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgYXJyKSxcbiAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpICYmIGJhc2UuaXNQb3NpdGl2ZSgpKSB7XG4gICAgICAgICAgICBuZWcgPSB0cnVlO1xuICAgICAgICAgICAgbiA9IG4uYWJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UuaXNVbml0KCkpIHtcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4geyB2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZSB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBBcnJheS5hcHBseShudWxsLCBBcnJheShuLnRvSlNOdW1iZXIoKSkpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCAxKSxcbiAgICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBuZWdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgbGVmdCA9IG4sIGRpdm1vZDtcbiAgICAgICAgd2hpbGUgKGxlZnQuaXNOZWdhdGl2ZSgpIHx8IGxlZnQuY29tcGFyZUFicyhiYXNlKSA+PSAwKSB7XG4gICAgICAgICAgICBkaXZtb2QgPSBsZWZ0LmRpdm1vZChiYXNlKTtcbiAgICAgICAgICAgIGxlZnQgPSBkaXZtb2QucXVvdGllbnQ7XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBkaXZtb2QucmVtYWluZGVyO1xuICAgICAgICAgICAgaWYgKGRpZ2l0LmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgICAgIGRpZ2l0ID0gYmFzZS5taW51cyhkaWdpdCkuYWJzKCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0LnB1c2goZGlnaXQudG9KU051bWJlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaChsZWZ0LnRvSlNOdW1iZXIoKSk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvdXQucmV2ZXJzZSgpLCBpc05lZ2F0aXZlOiBuZWcgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0Jhc2VTdHJpbmcobiwgYmFzZSwgYWxwaGFiZXQpIHtcbiAgICAgICAgdmFyIGFyciA9IHRvQmFzZShuLCBiYXNlKTtcbiAgICAgICAgcmV0dXJuIChhcnIuaXNOZWdhdGl2ZSA/IFwiLVwiIDogXCJcIikgKyBhcnIudmFsdWUubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHgsIGFscGhhYmV0KTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xuICAgICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcbiAgICB9O1xuXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0b0Jhc2UodGhpcywgcmFkaXgpO1xuICAgIH07XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XG4gICAgfTtcblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4LCBhbHBoYWJldCkge1xuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcbiAgICAgICAgaWYgKHJhZGl4ICE9PSAxMCkgcmV0dXJuIHRvQmFzZVN0cmluZyh0aGlzLCByYWRpeCwgYWxwaGFiZXQpO1xuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWUsIGwgPSB2Lmxlbmd0aCwgc3RyID0gU3RyaW5nKHZbLS1sXSksIHplcm9zID0gXCIwMDAwMDAwXCIsIGRpZ2l0O1xuICAgICAgICB3aGlsZSAoLS1sID49IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gU3RyaW5nKHZbbF0pO1xuICAgICAgICAgICAgc3RyICs9IHplcm9zLnNsaWNlKGRpZ2l0Lmxlbmd0aCkgKyBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lnbiA9IHRoaXMuc2lnbiA/IFwiLVwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHNpZ24gKyBzdHI7XG4gICAgfTtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgsIGFscGhhYmV0KSB7XG4gICAgICAgIGlmIChyYWRpeCA9PT0gdW5kZWZpbmVkKSByYWRpeCA9IDEwO1xuICAgICAgICBpZiAocmFkaXggIT0gMTApIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgsIGFscGhhYmV0KTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b1N0cmluZyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICBOYXRpdmVCaWdJbnQucHJvdG90eXBlLnRvSlNPTiA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNPTiA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLCAxMCk7XG4gICAgfTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZjtcblxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XG4gICAgTmF0aXZlQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mID0gTmF0aXZlQmlnSW50LnByb3RvdHlwZS50b0pTTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmdWYWx1ZSh2KSB7XG4gICAgICAgIGlmIChpc1ByZWNpc2UoK3YpKSB7XG4gICAgICAgICAgICB2YXIgeCA9ICt2O1xuICAgICAgICAgICAgaWYgKHggPT09IHRydW5jYXRlKHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0c05hdGl2ZUJpZ0ludCA/IG5ldyBOYXRpdmVCaWdJbnQoQmlnSW50KHgpKSA6IG5ldyBTbWFsbEludGVnZXIoeCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpZ24gPSB2WzBdID09PSBcIi1cIjtcbiAgICAgICAgaWYgKHNpZ24pIHYgPSB2LnNsaWNlKDEpO1xuICAgICAgICB2YXIgc3BsaXQgPSB2LnNwbGl0KC9lL2kpO1xuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHNwbGl0LmpvaW4oXCJlXCIpKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdmFyIGV4cCA9IHNwbGl0WzFdO1xuICAgICAgICAgICAgaWYgKGV4cFswXSA9PT0gXCIrXCIpIGV4cCA9IGV4cC5zbGljZSgxKTtcbiAgICAgICAgICAgIGV4cCA9ICtleHA7XG4gICAgICAgICAgICBpZiAoZXhwICE9PSB0cnVuY2F0ZShleHApIHx8ICFpc1ByZWNpc2UoZXhwKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIGV4cCArIFwiIGlzIG5vdCBhIHZhbGlkIGV4cG9uZW50LlwiKTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3BsaXRbMF07XG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBsYWNlID0gdGV4dC5pbmRleE9mKFwiLlwiKTtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2UgPj0gMCkge1xuICAgICAgICAgICAgICAgIGV4cCAtPSB0ZXh0Lmxlbmd0aCAtIGRlY2ltYWxQbGFjZSAtIDE7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgZGVjaW1hbFBsYWNlKSArIHRleHQuc2xpY2UoZGVjaW1hbFBsYWNlICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluY2x1ZGUgbmVnYXRpdmUgZXhwb25lbnQgcGFydCBmb3IgaW50ZWdlcnNcIik7XG4gICAgICAgICAgICB0ZXh0ICs9IChuZXcgQXJyYXkoZXhwICsgMSkpLmpvaW4oXCIwXCIpO1xuICAgICAgICAgICAgdiA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvXihbMC05XVswLTldKikkLy50ZXN0KHYpO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIgKyB2KTtcbiAgICAgICAgaWYgKHN1cHBvcnRzTmF0aXZlQmlnSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUJpZ0ludChCaWdJbnQoc2lnbiA/IFwiLVwiICsgdiA6IHYpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IFtdLCBtYXggPSB2Lmxlbmd0aCwgbCA9IExPR19CQVNFLCBtaW4gPSBtYXggLSBsO1xuICAgICAgICB3aGlsZSAobWF4ID4gMCkge1xuICAgICAgICAgICAgci5wdXNoKCt2LnNsaWNlKG1pbiwgbWF4KSk7XG4gICAgICAgICAgICBtaW4gLT0gbDtcbiAgICAgICAgICAgIGlmIChtaW4gPCAwKSBtaW4gPSAwO1xuICAgICAgICAgICAgbWF4IC09IGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJpbShyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodikge1xuICAgICAgICBpZiAoc3VwcG9ydHNOYXRpdmVCaWdJbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KEJpZ0ludCh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlY2lzZSh2KSkge1xuICAgICAgICAgICAgaWYgKHYgIT09IHRydW5jYXRlKHYpKSB0aHJvdyBuZXcgRXJyb3IodiArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyVmFsdWUodik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmdWYWx1ZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQmlnSW50KHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICAvLyBQcmUtZGVmaW5lIG51bWJlcnMgaW4gcmFuZ2UgWy05OTksOTk5XVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIEludGVnZXJbaV0gPSBwYXJzZVZhbHVlKGkpO1xuICAgICAgICBpZiAoaSA+IDApIEludGVnZXJbLWldID0gcGFyc2VWYWx1ZSgtaSk7XG4gICAgfVxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgSW50ZWdlci5vbmUgPSBJbnRlZ2VyWzFdO1xuICAgIEludGVnZXIuemVybyA9IEludGVnZXJbMF07XG4gICAgSW50ZWdlci5taW51c09uZSA9IEludGVnZXJbLTFdO1xuICAgIEludGVnZXIubWF4ID0gbWF4O1xuICAgIEludGVnZXIubWluID0gbWluO1xuICAgIEludGVnZXIuZ2NkID0gZ2NkO1xuICAgIEludGVnZXIubGNtID0gbGNtO1xuICAgIEludGVnZXIuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgU21hbGxJbnRlZ2VyIHx8IHggaW5zdGFuY2VvZiBOYXRpdmVCaWdJbnQ7IH07XG4gICAgSW50ZWdlci5yYW5kQmV0d2VlbiA9IHJhbmRCZXR3ZWVuO1xuXG4gICAgSW50ZWdlci5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLm1hcChwYXJzZVZhbHVlKSwgcGFyc2VWYWx1ZShiYXNlIHx8IDEwKSwgaXNOZWdhdGl2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbnRlZ2VyO1xufSkoKTtcbiIsIi8qIGdsb2JhbCBiaWdJbnQgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8vIFdlIHJlcHJlc2VudCBhIFtaLnRdIGFzIGEgamF2YXNjcmlwdCAzMmJpdCBpbnRlZ2VycyBpZiBpdCBmaXRzIG9yIGFzIGEgYmlnSW50LlxuXG4vL1Byb3ZpZGVzOiBtbF96X25vcm1hbGl6ZVxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X25vcm1hbGl6ZSh4KXtcbiAgdmFyIHkgPSB4LnRvSlNOdW1iZXIgKCkgfCAwO1xuICBpZih4LmVxdWFscyhiaWdJbnQoeSkpKSByZXR1cm4geTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vZXh0ZXJuYWwgaW5pdDogdW5pdCAtPiB1bml0XG4vL1Byb3ZpZGVzOiBtbF96X2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfemFyaXRoX21hcnNoYWwsIGNhbWxfemFyaXRoX3VubWFyc2hhbCwgY2FtbF9jdXN0b21fb3BzLCBtbF96X2hhc2hcbmZ1bmN0aW9uIG1sX3pfaW5pdCh1bml0KSB7XG4gIGNhbWxfY3VzdG9tX29wc1snX3onXSA9XG4gICAgeyBzZXJpYWxpemUgOiBjYW1sX3phcml0aF9tYXJzaGFsLFxuICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX3phcml0aF91bm1hcnNoYWwsXG4gICAgICBoYXNoIDogbWxfel9oYXNofTtcbiAgcmV0dXJuIDAgfVxuXG4vL2V4dGVybmFsIG1sX3pfaW5zdGFsbF9mcmFtZXRhYmxlOiB1bml0IC0+IHVuaXRcbi8vUHJvdmlkZXM6IG1sX3pfaW5zdGFsbF9mcmFtZXRhYmxlIGNvbnN0XG5mdW5jdGlvbiBtbF96X2luc3RhbGxfZnJhbWV0YWJsZSh1bml0KSB7IHJldHVybiAwIH1cblxuLy9leHRlcm5hbCBuZWc6IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9uZWcgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbmVnKHoxKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLm5lZ2F0ZSgpKTtcbn1cblxuLy9leHRlcm5hbCBhZGQ6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2FkZCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9hZGQoejEsIHoyKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLmFkZChiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgc3ViOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9zdWIgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfc3ViKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5zdWJ0cmFjdChiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgbXVsOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbXVsKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5tdWx0aXBseShiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgZGl2OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9kaXZcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfZGl2KHoxLCB6Mikge1xuICB6MiA9IGJpZ0ludCh6MilcbiAgaWYoejIuZXF1YWxzKGJpZ0ludCgwKSkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuZGl2aWRlKGJpZ0ludCh6MikpKVxufVxuXG4vL2V4dGVybmFsIGNkaXY6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2NkaXZcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9kaXYsIG1sX3pfc2lnbiwgbWxfel9hZGRcbmZ1bmN0aW9uIG1sX3pfY2Rpdih6MSwgejIpIHtcbiAgdmFyIHoxX3BvcyA9IG1sX3pfc2lnbih6MSk7XG4gIHZhciB6Ml9wb3MgPSBtbF96X3NpZ24oejIpO1xuICBpZiAoejFfcG9zICogejJfcG9zID4gMCkgLyogTXVsdGlwbGljYXRpb24gaXMgbGlrZSBhIHNpZ253aXNlIHhvciAqLyB7XG4gICAgaWYgKCFiaWdJbnQoejEpLm1vZChiaWdJbnQoejIpKS5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgICAgcmV0dXJuIG1sX3pfYWRkKG1sX3pfZGl2KHoxLCB6MiksIGJpZ0ludCgxKSkgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWxfel9kaXYoejEsIHoyKTtcbn1cblxuLy9leHRlcm5hbCBmZGl2OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9mZGl2XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfZGl2LCBtbF96X3NpZ24sIG1sX3pfc3ViXG5mdW5jdGlvbiBtbF96X2ZkaXYoejEsIHoyKSB7XG4gIHZhciB6MV9wb3MgPSBtbF96X3NpZ24oejEpO1xuICB2YXIgejJfcG9zID0gbWxfel9zaWduKHoyKTtcbiAgaWYgKHoxX3BvcyAqIHoyX3BvcyA8IDApIC8qIE11bHRpcGxpY2F0aW9uIGlzIGxpa2UgYSBzaWdud2lzZSB4b3IgKi8ge1xuICAgIGlmICghYmlnSW50KHoxKS5tb2QoYmlnSW50KHoyKSkuZXF1YWxzKGJpZ0ludCgwKSkpIHtcbiAgICAgIHJldHVybiBtbF96X3N1YihtbF96X2Rpdih6MSwgejIpLCBiaWdJbnQoMSkpIDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1sX3pfZGl2KHoxLCB6Mik7XG59XG5cbi8vZXh0ZXJuYWwgcmVtOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9yZW1cbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfcmVtKHoxLCB6Mikge1xuICB6MiA9IGJpZ0ludCh6Mik7XG4gIGlmICh6Mi5lcXVhbHMoYmlnSW50KDApKSkge1xuICAgIGNhbWxfcmFpc2VfemVyb19kaXZpZGUoKTtcbiAgfVxuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5tb2QoejIpKTtcbn1cblxuLy9leHRlcm5hbCBkaXZfcmVtOiB0IC0+IHQgLT4gKHQgKiB0KVxuLy9Qcm92aWRlczogbWxfel9kaXZfcmVtXG4vL1JlcXVpcmVzOiBtbF96X2RpdiwgbWxfel9yZW1cbmZ1bmN0aW9uIG1sX3pfZGl2X3JlbSh6MSwgejIpIHtcbiAgcmV0dXJuIFswLCBtbF96X2Rpdih6MSx6MiksIG1sX3pfcmVtKHoxLCB6MildXG59XG4vL2V4dGVybmFsIHN1Y2M6IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9zdWNjIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3N1Y2MoejEpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkubmV4dCgpKTtcbn1cblxuLy9leHRlcm5hbCBwcmVkOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfcHJlZCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9wcmVkKHoxKSB7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnByZXYoKSk7XG59XG5cbi8vZXh0ZXJuYWwgYWJzOiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfYWJzIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2Ficyh6MSkge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5hYnMoKSk7XG59XG5cbi8vZXh0ZXJuYWwgbG9nYW5kOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9sb2dhbmQgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfbG9nYW5kKHoxLCB6Mikge1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYmlnSW50KHoxKS5hbmQoYmlnSW50KHoyKSkpO1xufVxuXG4vL2V4dGVybmFsIGxvZ29yOiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9sb2dvciBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9sb2dvcih6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkub3IoYmlnSW50KHoyKSkpO1xufVxuXG4vL2V4dGVybmFsIGxvZ3hvcjogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfbG9neG9yIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2xvZ3hvcih6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkueG9yKGJpZ0ludCh6MikpKTtcbn1cblxuLy9leHRlcm5hbCBsb2dub3Q6IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9sb2dub3QgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCxtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9sb2dub3QoejEpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkubm90KCkpO1xufVxuXG4vL2V4dGVybmFsIHNoaWZ0X2xlZnQ6IHQgLT4gaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfc2hpZnRfbGVmdCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9zaGlmdF9sZWZ0KHoxLCBhbXQpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuc2hpZnRMZWZ0KGFtdCkpO1xufVxuXG4vL2V4dGVybmFsIHNoaWZ0X3JpZ2h0OiB0IC0+IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3NoaWZ0X3JpZ2h0IGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X3NoaWZ0X3JpZ2h0KHoxLCBhbXQpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludCh6MSkuc2hpZnRSaWdodChhbXQpKTtcbn1cblxuLy9leHRlcm5hbCBzaGlmdF9yaWdodF90cnVuYzogdCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9zaGlmdF9yaWdodF90cnVuYyBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X2RpdlxuZnVuY3Rpb24gbWxfel9zaGlmdF9yaWdodF90cnVuYyh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfZGl2KGJpZ0ludCh6MSksIGJpZ0ludCgyKS5wb3coejIpKVxufVxuXG4vL2V4dGVybmFsIG9mX2ludDogaW50IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfb2ZfaW50IGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfb2ZfaW50KGkpIHtcbiAgcmV0dXJuIGkgfCAwO1xufVxuXG4vL2V4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBtbF96X29mX2ludFxuZnVuY3Rpb24gbWxfel9vZl9pbnQzMihpMzIpIHtcbiAgcmV0dXJuIG1sX3pfb2ZfaW50KGkzMik7XG59XG5cbi8vZXh0ZXJuYWwgb2ZfbmF0aXZlaW50OiBuYXRpdmVpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9uYXRpdmVpbnQgY29uc3Rcbi8vUmVxdWlyZXM6IG1sX3pfb2ZfaW50XG5mdW5jdGlvbiBtbF96X29mX25hdGl2ZWludCh6KSB7XG4gIHJldHVybiBtbF96X29mX2ludCh6KVxufVxuXG4vL2V4dGVybmFsIG9mX2ludDY0OiBpbnQ2NCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2ludDY0IGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9uZWcsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X29mX2ludDY0KGk2NCkge1xuICB2YXIgbmVnID0gZmFsc2U7XG4gIGlmKGNhbWxfaW50NjRfY29tcGFyZShpNjQsIFsyNTUsMCwwLDBdKSA8IDApIHtcbiAgICBuZWcgPSB0cnVlO1xuICAgIGk2NCA9IGNhbWxfaW50NjRfbmVnKGk2NClcbiAgfVxuICB2YXIgeCA9IGJpZ0ludChpNjRbMV0pLmFkZChiaWdJbnQoaTY0WzJdKS5zaGlmdExlZnQoMjQpKS5hZGQoYmlnSW50KGk2NFszXSkuc2hpZnRMZWZ0KDQ4KSk7XG4gIGlmKG5lZykgeyB4ID0geC5uZWdhdGUoKSB9O1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoeClcbn1cblxuLy9leHRlcm5hbCBvZl9mbG9hdDogZmxvYXQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9vZl9mbG9hdFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX25hbWVkX3ZhbHVlLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9vZl9mbG9hdChmMSkge1xuICBpZihmMSA9PSBJbmZpbml0eSB8fCBmMSA9PSAtSW5maW5pdHkgfHwgZjEgIT0gZjEpXG4gICAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX25hbWVkX3ZhbHVlKFwibWxfel9vdmVyZmxvd1wiKSk7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoZjE8MD9NYXRoLmNlaWwoZjEpOk1hdGguZmxvb3IoZjEpKSk7XG59XG5cbi8vZXh0ZXJuYWwgdG9faW50OiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel90b19pbnRcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gbWxfel90b19pbnQoejEpIHtcbiAgaWYgKHoxID09ICh6MSB8IDApKSByZXR1cm4gejEgfCAwO1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbn1cblxuLy9leHRlcm5hbCB0b19pbnQzMjogdCAtPiBpbnQzMlxuLy9Qcm92aWRlczogbWxfel90b19pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogbWxfel90b19pbnRcbmZ1bmN0aW9uIG1sX3pfdG9faW50MzIoejEpIHsgcmV0dXJuIG1sX3pfdG9faW50KHoxKSB9XG5cbi8vZXh0ZXJuYWwgdG9faW50NjQ6IHQgLT4gaW50NjRcbi8vUHJvdmlkZXM6IG1sX3pfdG9faW50NjRcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9maXRzX2ludDY0LCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX25hbWVkX3ZhbHVlXG5mdW5jdGlvbiBtbF96X3RvX2ludDY0KHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKVxuICBpZighbWxfel9maXRzX2ludDY0KHoxKSkge1xuICAgIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICB9XG4gIHZhciBhID0gejEuYW5kKGJpZ0ludCgweGZmZmZmZikpLnRvSlNOdW1iZXIoKXwwO1xuICB2YXIgYiA9IHoxLnNoaWZ0UmlnaHQoMjQpLmFuZChiaWdJbnQoMHhmZmZmZmYpKS50b0pTTnVtYmVyKCl8MDtcbiAgdmFyIGMgPSB6MS5zaGlmdFJpZ2h0KDQ4KS5hbmQoYmlnSW50KDB4ZmZmZikpLnRvSlNOdW1iZXIoKXwwO1xuICB2YXIgeCA9IFsgMjU1LCBhLCBiLCBjXTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vZXh0ZXJuYWwgdGVzdGJpdDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X3Rlc3RiaXRcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel90ZXN0Yml0KHoscG9zKXtcbiAgeiA9IGJpZ0ludCh6KTtcbiAgcmV0dXJuICh6LnNoaWZ0UmlnaHQocG9zKS5hbmQoYmlnSW50KDEpKS50b0pTTnVtYmVyKCkpfDA7XG59XG5cbi8vZXh0ZXJuYWwgdG9fbmF0aXZlaW50OiB0IC0+IG5hdGl2ZWludFxuLy9Qcm92aWRlczogbWxfel90b19uYXRpdmVpbnRcbi8vUmVxdWlyZXM6IG1sX3pfdG9faW50XG5mdW5jdGlvbiBtbF96X3RvX25hdGl2ZWludCh6MSkgeyByZXR1cm4gbWxfel90b19pbnQoejEpIH1cblxuLy9leHRlcm5hbCBmb3JtYXQ6IHN0cmluZyAtPiB0IC0+IHN0cmluZ1xuLy9Qcm92aWRlczogbWxfel9mb3JtYXQgXG4vL1JlcXVpcmVzOiBiaWdJbnRcbi8vUmVxdWlyZXM6IGNhbWxfdG9fanNfc3RyaW5nLCBjYW1sX2pzX3RvX3N0cmluZywgY2FtbF9mYWlsd2l0aCwgY2FtbF9uZXdfc3RyaW5nLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9mb3JtYXQoZm10LCB6MSkge1xuICB6MSA9IGJpZ0ludCh6MSk7XG4gIHZhciBmbXQgPSBmbXQudG9TdHJpbmcoKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL1phcml0aC9ibG9iL2QwNTU1ZDQ1MWNlMjk1YzQ0OTdmMjRhOGQ5OTkzZjhkZDIzMDk3ZGYvei5tbGlwI0wyOTdcbiAgdmFyIGJhc2UgPSAxMDtcbiAgdmFyIGNhcyA9IDA7XG4gIHZhciB3aWR0aCA9IDA7XG4gIHZhciBhbHQgPSAwO1xuICB2YXIgZGlyID0gMDtcbiAgdmFyIHNpZ24gPSAnJztcbiAgdmFyIHBhZCA9ICcgJztcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBwcmVmaXg9XCJcIjtcbiAgd2hpbGUoZm10W2lkeF0gPT0gJyUnKSBpZHgrKztcbiAgZm9yKDs7IGlkeCsrKSB7XG4gICAgaWYoZm10W2lkeF0gPT0gJyMnKSBhbHQgPSAxO1xuICAgIGVsc2UgaWYgKGZtdFtpZHhdID09ICcwJykgcGFkID0gJzAnO1xuICAgIGVsc2UgaWYgKGZtdFtpZHhdID09ICctJykgZGlyID0gMTtcbiAgICBlbHNlIGlmIChmbXRbaWR4XSA9PSAnICcgfHwgZm10W2lkeF0gPT0gJysnKSBzaWduID0gZm10W2lkeF07XG4gICAgZWxzZSBicmVhaztcbiAgfVxuICBpZih6MS5sdChiaWdJbnQoMCkpKXtzaWduID0gJy0nO3oxID0gejEubmVnYXRlKCl9O1xuICBmb3IoO2ZtdFtpZHhdPj0nMCcgJiYgZm10W2lkeF0gPD0nOSc7aWR4KyspXG4gICAgd2lkdGg9MTAqd2lkdGggKyAoK2ZtdFtpZHhdKTtcbiAgc3dpdGNoKGZtdFtpZHhdKXtcbiAgY2FzZSAnaSc6IGNhc2UgJ2QnOiBjYXNlICd1JzogYnJlYWs7XG4gIGNhc2UgJ2InOiBiYXNlID0gMjsgaWYoYWx0KSBwcmVmaXggPSBcIjBiXCI7IGJyZWFrO1xuICBjYXNlICdvJzogYmFzZSA9IDg7IGlmKGFsdCkgcHJlZml4ID0gXCIwb1wiOyBicmVhaztcbiAgY2FzZSAneCc6IGJhc2UgPSAxNjsgaWYoYWx0KSBwcmVmaXggPSBcIjB4XCI7IGJyZWFrO1xuICBjYXNlICdYJzogYmFzZSA9IDE2OyBpZihhbHQpIHByZWZpeCA9IFwiMFhcIjsgY2FzID0gMTsgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9mYWlsd2l0aChcIlVuc3VwcG9ydGVkIGZvcm1hdCAnXCIgKyBmbXQgKyBcIidcIik7XG4gIH1cbiAgaWYgKGRpcikgcGFkID0gJyAnO1xuICB2YXIgcmVzID0gejEudG9TdHJpbmcoYmFzZSk7XG4gIGlmIChjYXMgPT09IDEpIHtcbiAgICByZXMgPSByZXMudG9VcHBlckNhc2UoKTtcbiAgfVxuICB2YXIgc2l6ZSA9IHJlcy5sZW5ndGg7XG4gIGlmIChwYWQgPT0gJyAnKSB7XG4gICAgaWYoZGlyKSB7XG4gICAgICByZXMgPSBzaWduICsgcHJlZml4ICsgcmVzO1xuICAgICAgZm9yKDtyZXMubGVuZ3RoPHdpZHRoOykgcmVzID0gcmVzICsgcGFkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBzaWduICsgcHJlZml4ICsgcmVzO1xuICAgICAgZm9yKDtyZXMubGVuZ3RoPHdpZHRoOykgcmVzID0gcGFkICsgcmVzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJlID0gc2lnbiArIHByZWZpeDtcbiAgICBmb3IoO3Jlcy5sZW5ndGgrcHJlLmxlbmd0aDx3aWR0aDspIHJlcyA9IHBhZCArIHJlcztcbiAgICByZXMgPSBwcmUgKyByZXM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhyZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3pfb2ZfanNfc3RyaW5nX2Jhc2Vcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF90b19qc19zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIGpzb29fel9vZl9qc19zdHJpbmdfYmFzZShiYXNlLCBzKSB7XG4gIGlmIChiYXNlID09IDApIHsgLy8gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL1phcml0aC9ibG9iL2I4ZGJhZjQ4YTc5MjcwNjFkZjY5OWFkN2NlNjQyYmI0ZjFmZTUzMDgvY2FtbF96LmMjTDU5OFxuICAgIGJhc2UgPSAxMDtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIHNpZ24gPSAxO1xuICAgIGlmKHNbcF0gPT0gJy0nKSB7IHNpZ24gPSAtMTsgcCsrIH1cbiAgICBlbHNlIGlmIChzW3BdID09ICcrJykgeyBwKysgfVxuICAgIGlmIChzW3BdID09ICcwJykge1xuICAgICAgcCArKztcbiAgICAgIGlmIChzLmxlbmd0aCA9PSBwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJjID0gc1twXTtcbiAgICAgICAgaWYgKGJjID09ICdvJyB8fCBiYyA9PSAnTycpIHtcbiAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgfSBlbHNlIGlmIChiYyA9PSAneCcgfHwgYmMgPT0gJ1gnKSB7XG4gICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICB9IGVsc2UgaWYgKGJjID09ICdiJyB8fCBiYyA9PSAnQicpIHtcbiAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZihiYXNlICE9IDEwKSB7XG4gICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHArMSk7XG4gICAgICAgICAgaWYoc2lnbiA9PSAtMSkgcyA9IFwiLVwiICsgcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL3JlbW92ZSBsZWFkaW5nICcrJ1xuICBpZiAoc1swXSA9PSAnKycpIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgLy9yZW1vdmUgbGVhZGluZyAnMCdzXG4gIHMgPSBzLnJlcGxhY2UoL14wKy8sICcnKTtcbiAgLy9ub3JtYWxpemUgXCJlbXB0eVwiIG51bWJlcnNcbiAgaWYocyA9PSAnLScgfHwgcyA9PSAnJykgcyA9ICcwJztcblxuICBmdW5jdGlvbiBkaWdpdChjb2RlKXtcbiAgICBpZihjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHJldHVybiBjb2RlIC0gNDg7XG4gICAgaWYoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikgcmV0dXJuIGNvZGUgLSA5NyArIDEwO1xuICAgIGlmKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgcmV0dXJuIGNvZGUgLSA2NSArIDEwO1xuICB9XG4gIHZhciBpID0gMDtcbiAgaWYoc1tpXSA9PSAnLScpIGkrKztcbiAgZm9yKCA7IGkgPCBzLmxlbmd0aCA7IGkrKyl7XG4gICAgdmFyIGMgPSBkaWdpdChzLmNoYXJDb2RlQXQoaSkpO1xuICAgIGlmKGMgPT0gdW5kZWZpbmVkIHx8IGMgPj0gYmFzZSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloub2Zfc3Vic3RyaW5nX2Jhc2U6IGludmFsaWQgZGlnaXRcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludChzLCBiYXNlKSk7XG4gIFxufVxuXG4vL2V4dGVybmFsIG9mX3N1YnN0cmluZ19iYXNlOiBpbnQgLT4gc3RyaW5nIC0+IHBvczppbnQgLT4gbGVuOmludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX3N1YnN0cmluZ19iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGpzb29fel9vZl9qc19zdHJpbmdfYmFzZSwgY2FtbF90b19qc19zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBtbF96X29mX3N1YnN0cmluZ19iYXNlKGJhc2UsIHMsIHBvcywgbGVuKSB7XG4gIGlmKHBvcyAhPSAwIHx8IGxlbiAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICBzID0gY2FtbF9hcnJheV9vZl9zdHJpbmcocyk7XG4gICAgaWYgKHMubGVuZ3RoIC0gcG9zIDwgbGVuKSB7XG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLm9mX3N1YnN0cmluZ19iYXNlOiBpbnZhbGlkIG9mZnNldCBvciBsZW5ndGhcIik7XG4gICAgfVxuICAgIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShzLnNsaWNlKHBvcyxwb3MrbGVuKSk7XG4gIH1cbiAgcmV0dXJuIGpzb29fel9vZl9qc19zdHJpbmdfYmFzZShiYXNlLCBjYW1sX3RvX2pzX3N0cmluZyhzKSk7XG59XG5cbi8vZXh0ZXJuYWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuLy9Qcm92aWRlczogbWxfel9jb21wYXJlIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfY29tcGFyZSh6MSwgejIpIHtcbiAgcmV0dXJuIGJpZ0ludCh6MSkuY29tcGFyZShiaWdJbnQoejIpKTtcbn1cblxuLy9leHRlcm5hbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZXF1YWwgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9lcXVhbCh6MSwgejIpIHtcbiAgcmV0dXJuIGJpZ0ludCh6MSkuZXF1YWxzKGJpZ0ludCh6MikpO1xufVxuXG4vL2V4dGVybmFsIHNpZ246IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3NpZ24gY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9zaWduKHoxKSB7XG4gIHJldHVybiBiaWdJbnQoejEpLmNvbXBhcmUoYmlnSW50Lnplcm8pO1xufVxuXG4vL2V4dGVybmFsIGdjZDogdCAtPiB0IC0+IHRcbi8vUHJvdmlkZXM6IG1sX3pfZ2NkXG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2djZCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKGJpZ0ludC5nY2QoYmlnSW50KHoxKSwgYmlnSW50KHoyKSkuYWJzKCkpO1xufVxuXG4vL2V4dGVybmFsIG51bWJpdHM6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X251bWJpdHMgY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gbWxfel9udW1iaXRzKHoxKSB7XG4gIHoxID0gYmlnSW50KHoxKS5hYnMoKTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgdXBwZXJCb3VuZCA9IGJpZ0ludC5vbmU7XG4gIHdoaWxlICh1cHBlckJvdW5kLmxlcSh6MSkpIHtcbiAgICBuICs9IDE7XG4gICAgdXBwZXJCb3VuZCA9IHVwcGVyQm91bmQubXVsdGlwbHkoMik7XG4gIH1cbiAgcmV0dXJuIG47IC8vIDJee24tMX0gPD0gfHh8IDwgMl5uXG59XG5cbi8vZXh0ZXJuYWwgZml0c19pbnQ6IHQgLT4gYm9vbFxuLy9Qcm92aWRlczogbWxfel9maXRzX2ludCBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfaW50KHoxKSB7XG4gIGlmKHoxID09ICh6MSB8IDApKSByZXR1cm4gMTtcbiAgZWxzZSByZXR1cm4gMDtcbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDMyOiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19pbnQzMlxuLy9SZXF1aXJlczogbWxfel9maXRzX2ludFxuZnVuY3Rpb24gbWxfel9maXRzX2ludDMyKHoxKSB7XG4gIHJldHVybiBtbF96X2ZpdHNfaW50KHoxKTtcbn1cblxuLy9leHRlcm5hbCBmaXRzX2ludDY0OiB0IC0+IGJvb2xcbi8vUHJvdmlkZXM6IG1sX3pfZml0c19pbnQ2NFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfaW50NjQoejEpIHtcbiAgejEgPSBiaWdJbnQoejEpXG4gIGlmICh6MS5jb21wYXJlKGJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIikpIDw9IDAgJiYgejEuY29tcGFyZShiaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSkgPj0gMClcbiAgICByZXR1cm4gMVxuICBlbHNlXG4gICAgcmV0dXJuIDBcbn1cblxuLy9leHRlcm5hbCBmaXRzX25hdGl2ZWludDogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X2ZpdHNfbmF0aXZlaW50XG4vL1JlcXVpcmVzOiBtbF96X2ZpdHNfaW50XG5mdW5jdGlvbiBtbF96X2ZpdHNfbmF0aXZlaW50KHoxKSB7XG4gIHJldHVybiBtbF96X2ZpdHNfaW50KHoxKTtcbn1cblxuLy9leHRlcm5hbCBwb3dtOiB0IC0+IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Bvd21cbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9ub3JtYWxpemUsIG1sX3pfaW52ZXJ0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBtbF96X3Bvd20oejEsIHoyLCB6Mykge1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgejEgPSBiaWdJbnQoejEpO1xuICB6MiA9IGJpZ0ludCh6Mik7XG4gIHozID0gYmlnSW50KHozKTtcbiAgaWYoejMuZXF1YWxzKHplcm8pKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIGlmKHozLmFicygpLmVxdWFscyhvbmUpKSByZXR1cm4gMDtcbiAgaWYoejIuZXF1YWxzKHplcm8pKSByZXR1cm4gMTtcbiAgaWYoejIubHQoMCkpIHtcbiAgICB2YXIgaW52ID0gYmlnSW50KG1sX3pfaW52ZXJ0KHoxLCB6MykpO1xuICAgIHZhciByID0gaW52Lm1vZFBvdyh6Mi5uZWdhdGUoKSwgejMpO1xuICAgIGlmKHIubHQoemVybykpIHIgPSByLmFkZCh6My5hYnMoKSk7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciByID0gYmlnSW50KHoxKS5tb2RQb3coejIsIHozKTtcbiAgICBpZihyLmx0KHplcm8pKSByID0gci5hZGQoejMuYWJzKCkpO1xuICAgIHJldHVybiBtbF96X25vcm1hbGl6ZShyKTtcbiAgfVxufVxuXG4vL2V4dGVybmFsIHBvd246IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3Bvd1xuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ZhaWx3aXRoLCBtbF96X25vcm1hbGl6ZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBtbF96X3Bvdyh6MSwgaTEpIHtcbiAgaTEgPSBiaWdJbnQoaTEpO1xuICBpZiAoaTEubHQoYmlnSW50KDApKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucG93OiBleHBvbmVudCBtdXN0IGJlIG5vbm5lZ2F0aXZlXCIpO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShiaWdJbnQoejEpLnBvdyhpMSkpO1xufVxuXG4vL2V4dGVybmFsIGhhc2g6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIG1sX3pfaGFzaCh6MSkge1xuICB2YXIgYSA9IGJpZ0ludCh6MSkudG9BcnJheShNYXRoLnBvdygyLCAzMikpO1xuICB2YXIgYWNjID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgYWNjID0gY2FtbF9oYXNoX21peF9pbnQoYWNjLCBhLnZhbHVlW2ldKTtcbiAgfVxuICBpZihhLnZhbHVlLmxlbmd0aCAlIDIgIT0gMCkge1xuICAgIGFjYyA9IGNhbWxfaGFzaF9taXhfaW50KGFjYywgMCk7XG4gIH1cbiAgaWYoYS5pc05lZ2F0aXZlKXtcbiAgICBhY2MgPSBhY2MgKyAxXG4gIH1cbiAgcmV0dXJuIGFjYyB8IDBcbn1cblxuLy9leHRlcm5hbCB0b19iaXRzOiB0IC0+IHN0cmluZ1xuLy9Qcm92aWRlczogbWxfel90b19iaXRzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmcsIGNhbWxfc3RyX3JlcGVhdCwgYmlnSW50XG5mdW5jdGlvbiBtbF96X3RvX2JpdHMoejEpIHtcbiAgejEgPSBiaWdJbnQoejEpLmFicygpO1xuICB2YXIgcmVzID0gXCJcIjtcbiAgd2hpbGUoIXoxLmVxdWFscyhiaWdJbnQoMCkpKXtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh6MS5tb2QoYmlnSW50KDI1NikpKTtcbiAgICB6MSA9IHoxLmRpdmlkZShiaWdJbnQoMjU2KSk7XG4gIH1cbiAgd2hpbGUocmVzLmxlbmd0aCAlIDQgIT0gMCl7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gIH1cbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhyZXMpO1xufVxuXG4vL2V4dGVybmFsIG9mX2JpdHM6IHN0cmluZyAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X29mX2JpdHMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9vZl9iaXRzKHoxKSB7XG4gIHZhciByID0gYmlnSW50Lnplcm9cbiAgdmFyIGJhc2UxID0gYmlnSW50KDI1Nik7XG4gIHZhciBiYXNlID0gYmlnSW50Lm9uZTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh6MSk7IGkrKyl7XG4gICAgdmFyIGQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHoxLGkpO1xuICAgIHIgPSBiaWdJbnQoYmFzZSkubXVsdGlwbHkoZCkuYWRkKHIpO1xuICAgIGJhc2UgPSBiaWdJbnQoYmFzZSkubXVsdGlwbHkoYmFzZTEpO1xuICB9XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZShyKTtcbn1cblxuLy9leHRlcm5hbCBwb3dtX3NlYzogdCAtPiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9wb3dtX3NlY1xuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ZhaWx3aXRoLCBtbF96X3Bvd20sIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfel9wb3dtX3NlYyh6MSwgejIsIHozKSB7XG4gIHozID0gYmlnSW50KHozKS5hYnMoKTtcbiAgLy8gcG93bV9zZWMgcmVxdWlyZXMgdGhhdCB0aGUgZXhwb25lbnQgYmUgcG9zaXRpdmVcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgaWYgKGJpZ0ludCh6MikubHQob25lKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIloucG93bV9zZWM6IGV4cG9uZW50IG11c3QgYmUgcG9zaXRpdmVcIik7XG4gIH1cbiAgaWYgKCFiaWdJbnQoejMpLmFuZChvbmUpLmVxdWFscyhvbmUpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiWi5wb3dtX3NlYzogbW9kdWx1cyBtdXN0IGJlIG9kZFwiKTtcbiAgfVxuICByZXR1cm4gbWxfel9wb3dtKHoxLCB6MiwgejMpXG59XG5cbi8vZXh0ZXJuYWwgcm9vdDogdCAtPiBpbnQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9yb290XG4vL1JlcXVpcmVzOiBtbF96X3BvdywgIGJpZ0ludCwgbWxfel9ub3JtYWxpemUsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gbWxfel9yb290KHosIGkpIHtcbiAgdmFyIHplcm8gPSBiaWdJbnQoMCk7XG4gIHZhciBvbmUgPSBiaWdJbnQoMSk7XG4gIHogPSBiaWdJbnQoeik7XG5cbiAgaWYgKGkgJSAyID09PSAwICYmIHoubHQoemVybykpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLnJvb3Q6IGV2ZW4gcm9vdCBvZiBhIG5lZ2F0aXZlIG51bWJlclwiKTtcbiAgfVxuXG4gIGlmICh6LmVxdWFscyh6ZXJvKSB8fCB6LmVxdWFscyhvbmUpKSB7XG4gICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHopO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gemVybztcbiAgdmFyIGVuZCA9IHo7XG4gIHZhciBhbnMgPSBudWxsO1xuXG4gIHZhciB0d28gPSBiaWdJbnQoMik7XG5cbiAgd2hpbGUgKHN0YXJ0LmxlcShlbmQpKVxuICB7XG4gICAgdmFyIG1pZCA9IHN0YXJ0LmFkZChlbmQpLmRpdmlkZSh0d28pO1xuICAgIHZhciBwbyA9IG1pZC5wb3coaSk7XG4gICAgaWYgKHBvLmVxdWFscyh6KSkge1xuICAgICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKG1pZCk7XG4gICAgfSBlbHNlIGlmIChwby5sdCh6KSkge1xuICAgICAgc3RhcnQgPSBtaWQubmV4dCgpO1xuICAgICAgYW5zID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBtaWQucHJldigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWxfel9ub3JtYWxpemUoYW5zKTtcbn1cblxuLy9leHRlcm5hbCBpbnZlcnQ6IHQgLT4gdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2ludmVydFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBtbF96X2djZGV4dF9pbnRlcm4sIG1sX3pfbm9ybWFsaXplXG5mdW5jdGlvbiBtbF96X2ludmVydChhLCBuKSB7XG4gIC8vIEJlY2F1c2UgW2EubW9kSW52KG4pXSBwcm9kdWNlcyBkaWZmZXJlbnQgcmVzdWx0cyBmb3IgZWRnZSBjYXNlcyxcbiAgLy8gd2Ugd3JvdGUgb3VyIG93biBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBnY2RleHRfaW50ZXJuLlxuICBhID0gYmlnSW50KGEpO1xuICBuID0gYmlnSW50KG4pO1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgaWYobi5hYnMoKS5lcXVhbHMob25lKSlcbiAgICByZXR1cm4gMDtcbiAgaWYgKG4uZXF1YWxzKHplcm8pICYmIGEuYWJzKCkuZXF1YWxzKG9uZSkpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICBpZiAobi5lcXVhbHMoemVybykgfHwgYS5lcXVhbHMoemVybykpIHtcbiAgICBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIH1cbiAgdmFyIHggPSBtbF96X2djZGV4dF9pbnRlcm4oYSwgbik7XG4gIHZhciByID0gYmlnSW50KHhbMl0pO1xuICB2YXIgdG1wID0gYmlnSW50KGEpLm11bHRpcGx5KHIpLm1vZChuKTtcbiAgaWYodG1wLmx0KHplcm8pKSB0bXAgPSB0bXAuYWRkKG4uYWJzKCkpO1xuICBpZihyLmx0KHplcm8pKSByID0gci5hZGQobi5hYnMoKSk7XG4gIGlmKHRtcC5lcXVhbHMob25lKSkge1xuICAgIHJldHVybiBtbF96X25vcm1hbGl6ZShyKTtcbiAgfVxuICBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG59XG5cbi8vZXh0ZXJuYWwgcGVyZmVjdF9wb3dlcjogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X3BlcmZlY3RfcG93ZXJcbi8vUmVxdWlyZXM6IGJpZ0ludCwgY2FtbF9mYWlsd2l0aCwgbWxfel9udW1iaXRzLCBtbF96X3Jvb3QsIG1sX3pfcG93XG5mdW5jdGlvbiBtbF96X3BlcmZlY3RfcG93ZXIoeikge1xuICAvLyBSZXR1cm4gdHJ1ZSBpZiBvcCBpcyBhIHBlcmZlY3QgcG93ZXIsIGkuZS4sIGlmIHRoZXJlIGV4aXN0IGludGVnZXJzIGEgYW5kXG4gIC8vIGIsIHdpdGggYiA+IDEsIHN1Y2ggdGhhdCBvcCA9IGFeYi5cbiAgLy8gT3RoZXJ3aXNlIGZhbHNlLlxuICB6ID0gYmlnSW50KHopO1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcblxuICBpZiAoei5lcXVhbHMoemVybykgfHwgei5lcXVhbHMob25lKSB8fCB6LmVxdWFscyhvbmUubmVnYXRlKCkpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgdmFyIGxvZzJ6ID0gbWxfel9udW1iaXRzKHouYWJzKCkpO1xuICBmb3IgKHZhciBiID0gMjsgYiA8PSBsb2cyejsgYisrKSB7XG4gICAgaWYoei5sdCh6ZXJvKSAmJiBiICUgMiA9PSAwKSBjb250aW51ZTtcbiAgICB2YXIgenAgPSB6LmFicygpO1xuICAgIHZhciBwID0gYmlnSW50KG1sX3pfcm9vdCh6cCwgYikpO1xuICAgIGlmKHoubHQoemVybykpIHAgPSBwLm5lZ2F0ZSgpO1xuICAgIHZhciByID0gYmlnSW50KG1sX3pfcG93KHAsIGIpKTtcbiAgICBpZiAoei5lcXVhbHMocikpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9leHRlcm5hbCBwZXJmZWN0X3NxdWFyZTogdCAtPiBib29sXG4vL1Byb3ZpZGVzOiBtbF96X3BlcmZlY3Rfc3F1YXJlXG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfcm9vdFxuZnVuY3Rpb24gbWxfel9wZXJmZWN0X3NxdWFyZSh6KSB7XG4gIHogPSBiaWdJbnQoeik7XG4gIGlmICh6Lmx0KGJpZ0ludCgwKSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgcm9vdCA9IGJpZ0ludChtbF96X3Jvb3QoeiwgMikpO1xuICBpZiAocm9vdC5tdWx0aXBseShyb290KS5lcSh6KSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAwXG4gIH07XG59XG5cbi8vZXh0ZXJuYWwgcHJvYmFiX3ByaW1lOiB0IC0+IGludCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfcHJvYmFiX3ByaW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfcHJvYmFiX3ByaW1lKHosIGkpIHtcbiAgaWYgKGJpZ0ludCh6KS5pc1Byb2JhYmxlUHJpbWUoaSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL2V4dGVybmFsIG5leHRwcmltZTogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X25leHRwcmltZSBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9uZXh0cHJpbWUoejEpIHtcbiAgLy8gSW50ZXJlc3RpbmdseSwgdGhlIHphcml0aCBuZXh0X3ByaW1lIG9ubHkgcmV0dXJucyBcbiAgLy8gcHJvYmFiYWxpc3RpYyBwcmltZXMuICBXZSBkbyB0aGUgc2FtZSwgd2l0aCB0aGUgXG4gIC8vIHNhbWUgcHJvYmFibGlzdGljIHBhcmFtZXRlciBvZiAyNS5cbiAgLy8gaHR0cHM6Ly9mb3NzaWVzLm9yZy9kb3gvZ21wLTYuMS4yL21wel8ybmV4dHByaW1lXzhjX3NvdXJjZS5odG1sXG4gIFxuICB6MSA9IGJpZ0ludCh6MSlcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgdmFyIHR3byA9IGJpZ0ludCgyKTtcblxuICBpZiAoejEubHQob25lKSB8fCB6MS5lcXVhbHMob25lKSkge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgaWYgKHoxLmFuZChvbmUpLmVxdWFscyhvbmUpKSB7XG4gICAgejEgPSB6MS5hZGQodHdvKTtcbiAgfSBlbHNlIHtcbiAgICB6MSA9IHoxLmFkZChvbmUpO1xuICB9XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoejEuaXNQcm9iYWJsZVByaW1lKDI1KSkge1xuICAgICAgcmV0dXJuIG1sX3pfbm9ybWFsaXplKHoxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgejEgPSB6MS5hZGQodHdvKVxuICAgIH1cbiAgfVxufVxuXG4vL2V4dGVybmFsIGV4dHJhY3Q6IHQgLT4gaW50IC0+IGludCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X2V4dHJhY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGJpZ0ludCwgbWxfel9ub3JtYWxpemVcbmZ1bmN0aW9uIG1sX3pfZXh0cmFjdCh6MSwgcG9zLCBsZW4pIHtcbiAgejEgPSBiaWdJbnQoejEpO1xuICByZXR1cm4gbWxfel9ub3JtYWxpemUoejEuc2hpZnRSaWdodChwb3MpLmFuZChiaWdJbnQoMikucG93KGxlbikuc3VidHJhY3QoMSkpKTtcbn1cblxuLy9leHRlcm5hbCBnY2RleHRfaW50ZXJuOiB0IC0+IHQgLT4gKHQgKiB0ICogYm9vbClcbi8vUHJvdmlkZXM6IG1sX3pfZ2NkZXh0X2ludGVyblxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9nY2RleHRfaW50ZXJuKHoxLCB6Mikge1xuICB6MSA9IGJpZ0ludCh6MSk7XG4gIHoyID0gYmlnSW50KHoyKTtcbiAgdmFyIGdjZCA9IGJpZ0ludC5nY2QoejEsejIpO1xuICB2YXIgYSA9IHoxO1xuICB2YXIgYiA9IHoyO1xuICB2YXIgeCA9IGJpZ0ludCgwKTtcbiAgdmFyIGxhc3R4ID0gYmlnSW50KDEpO1xuICB2YXIgeSA9IGJpZ0ludCgxKTtcbiAgdmFyIGxhc3R5ID0gYmlnSW50KDEpO1xuICB2YXIgcSwgdCwgcjtcbiAgaWYoejEuZXF1YWxzKGJpZ0ludCgwKSkpIHtcbiAgICBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIH1cbiAgd2hpbGUoIWIuZXF1YWxzKGJpZ0ludCgwKSkpIHtcbiAgICBxID0gYS5kaXZpZGUoYik7XG4gICAgciA9IGEuc3VidHJhY3QocS5tdWx0aXBseShiKSk7XG4gICAgdCA9IHg7XG4gICAgeCA9IGxhc3R4LnN1YnRyYWN0KHEubXVsdGlwbHkoeCkpO1xuICAgIGxhc3R4ID0gdDtcbiAgICB0ID0geTtcbiAgICB5ID0gbGFzdHkuc3VidHJhY3QocS5tdWx0aXBseSh5KSk7XG4gICAgbGFzdHkgPSB0O1xuICAgIGEgPSBiO1xuICAgIGIgPSByO1xuICB9XG4gIGlmKGEubHQoYmlnSW50KDApKSlcbiAgICByZXR1cm4gWzAsbWxfel9ub3JtYWxpemUoYS5uZWdhdGUoKSksbWxfel9ub3JtYWxpemUobGFzdHgubmVnYXRlKCkpLDFdXG4gIGVsc2VcbiAgICByZXR1cm4gWzAsbWxfel9ub3JtYWxpemUoYSksbWxfel9ub3JtYWxpemUobGFzdHgpLDFdXG59XG5cbi8vZXh0ZXJuYWwgc3FydDogdCAtPiB0XG4vL1Byb3ZpZGVzOiBtbF96X3NxcnRcbi8vUmVxdWlyZXM6IGJpZ0ludCwgbWxfel9yb290LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIG1sX3pfc3FydCh6MSkge1xuICB2YXIgeiA9IGJpZ0ludCh6MSk7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICBpZiAoei5sdCh6ZXJvKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouc3FydDogc3F1YXJlIHJvb3Qgb2YgYSBuZWdhdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgcmV0dXJuIG1sX3pfcm9vdCh6LCAyKTtcbn1cblxuLy9leHRlcm5hbCBzcXJ0X3JlbTogdCAtPiAodCAqIHQpXG4vL1Byb3ZpZGVzOiBtbF96X3NxcnRfcmVtXG4vL1JlcXVpcmVzOiBiaWdJbnQsIG1sX3pfcm9vdCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gbWxfel9zcXJ0X3JlbSh6KSB7XG4gIHogPSBiaWdJbnQoeik7XG4gIHZhciB6ZXJvID0gYmlnSW50KDApO1xuICBpZiAoei5sdCh6ZXJvKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlouc3FydF9yZW06IHNxdWFyZSByb290IG9mIGEgbmVnYXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIHZhciByb290ID0gYmlnSW50KG1sX3pfcm9vdCh6LCAyKSk7XG4gIHZhciBtdWwgPSByb290Lm11bHRpcGx5KHJvb3QpO1xuICB2YXIgZGlmZiA9IHouc3VidHJhY3QobXVsKTtcbiAgcmV0dXJuIFswLCBtbF96X25vcm1hbGl6ZShyb290KSwgbWxfel9ub3JtYWxpemUoZGlmZildXG59XG5cbi8vZXh0ZXJuYWwgdHJhaWxpbmdfemVyb3M6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3RyYWlsaW5nX3plcm9zIGNvbnN0XG4vL1JlcXVpcmVzOiBiaWdJbnRcbmZ1bmN0aW9uIG1sX3pfdHJhaWxpbmdfemVyb3Moeikge1xuICB6ID0gYmlnSW50KHopLmFicygpO1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgaWYgKHouZXF1YWxzKHplcm8pKSB7XG4gICAgLy8gbWF4X2ludCBpbiAzMmJpdFxuICAgIHJldHVybiAweDdmZmZmZmZmO1xuICB9XG4gIHZhciBpID0gMFxuICB6ID0gei54b3Ioei5wcmV2KCkpLnNoaWZ0UmlnaHQoMSk7XG4gIGZvciAoaSA9IDA7ICF6LmVxdWFscyhiaWdJbnQuemVybyk7IGkrKykge1xuICAgIHogPSB6LnNoaWZ0UmlnaHQoMSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbi8vZXh0ZXJuYWwgcG9wY291bnQ6IHQgLT4gaW50XG4vL1Byb3ZpZGVzOiBtbF96X3BvcGNvdW50XG4vL1JlcXVpcmVzOiBiaWdJbnQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX3pfcG9wY291bnQoeikge1xuICB6ID0gYmlnSW50KHopO1xuICB2YXIgemVybyA9IGJpZ0ludCgwKTtcbiAgdmFyIG9uZSA9IGJpZ0ludCgxKTtcbiAgaWYgKHoubHQoemVybykpIHtcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgIXouZXF1YWxzKHplcm8pOyBpKyspIHtcbiAgICB6ID0gei5hbmQoei5wcmV2KCkpO1xuICB9XG4gIGlmKGkgIT0gKGl8MCkpIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9uYW1lZF92YWx1ZShcIm1sX3pfb3ZlcmZsb3dcIikpO1xuICByZXR1cm4gaXwwO1xufVxuXG4vL2V4dGVybmFsIGhhbWRpc3Q6IHQgLT4gdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfaGFtZGlzdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X3BvcGNvdW50LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIG1sX3pfaGFtZGlzdCh6MSwgejIpIHtcbiAgaWYoYmlnSW50KHoxKS5pc05lZ2F0aXZlKCkgIT0gYmlnSW50KHoyKS5pc05lZ2F0aXZlICgpKXtcbiAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfbmFtZWRfdmFsdWUoXCJtbF96X292ZXJmbG93XCIpKTtcbiAgfVxuICBpZigoejEgIT0gKHoxIHwgMCkgfHwgejIgIT0gKHoyIHwgMCkpICYmIChiaWdJbnQoejEpLmlzTmVnYXRpdmUoKSB8fCBiaWdJbnQoejIpLmlzTmVnYXRpdmUgKCkpKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJaLmhhbWRpc3Q6IG5lZ2F0aXZlIGFyZ3VtZW50c1wiKTtcbiAgfVxuICByZXR1cm4gbWxfel9wb3Bjb3VudChiaWdJbnQoejEpLnhvcihiaWdJbnQoejIpKSk7XG59XG5cbi8vZXh0ZXJuYWwgc2l6ZTogdCAtPiBpbnRcbi8vUHJvdmlkZXM6IG1sX3pfc2l6ZSBjb25zdFxuLy9SZXF1aXJlczogYmlnSW50XG5mdW5jdGlvbiBtbF96X3NpemUoejEpIHtcbiAgLy8gQ2xhaW0gdG8gYmUgYSAzMi1iaXQgYXJjaGl0ZWN0dXJlLlxuICByZXR1cm4gYmlnSW50KHoxKS50b0FycmF5KE1hdGgucG93KDIsIDMyKSkudmFsdWUubGVuZ3RoO1xufVxuXG4vL2V4dGVybmFsIGRpdmV4YWN0OiB0IC0+IHQgLT4gdFxuLy9Qcm92aWRlczogbWxfel9kaXZleGFjdFxuLy9SZXF1aXJlczogYmlnSW50LCBtbF96X2RpdlxuZnVuY3Rpb24gbWxfel9kaXZleGFjdCh6MSwgejIpIHtcbiAgcmV0dXJuIG1sX3pfZGl2KHoxLCB6Mik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfemFyaXRoX21hcnNoYWxcbi8vUmVxdWlyZXM6IGJpZ0ludFxuZnVuY3Rpb24gY2FtbF96YXJpdGhfbWFyc2hhbCh3cml0ZXIsIHYsIHN6KSB7XG4gIHYgPSBiaWdJbnQodik7XG4gIHZhciBiaXRzID0gdi50b0FycmF5KE1hdGgucG93KDIsIDMyKSk7XG4gIHdyaXRlci53cml0ZSg4LCBiaXRzLmlzTmVnYXRpdmUgPzEgOiAwKTtcbiAgdmFyIGJsb2NrID0gYml0cy52YWx1ZS5sZW5ndGg7XG4gIHZhciBsZW4gPSBibG9jayAqIDQ7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gYmxvY2sgLSAxOyBpID49IDA7IGkgLS0pe1xuICAgIHdyaXRlci53cml0ZSg4LCAoYml0cy52YWx1ZVtpXSA+Pj4gMCApICYgMHhmZik7XG4gICAgd3JpdGVyLndyaXRlKDgsIChiaXRzLnZhbHVlW2ldID4+PiA4ICkgJiAweGZmKTtcbiAgICB3cml0ZXIud3JpdGUoOCwgKGJpdHMudmFsdWVbaV0gPj4+IDE2KSAmIDB4ZmYpO1xuICAgIHdyaXRlci53cml0ZSg4LCAoYml0cy52YWx1ZVtpXSA+Pj4gMjQpICYgMHhmZik7XG4gIH1cbiAgc3pbMF0gPSA0ICogKDEgKyAoKChsZW4gKyAzKSAvIDQpIHwgMCkpO1xuICBzelsxXSA9IDggKiAoMSArICgoKGxlbiArIDcpIC8gOCkgfCAwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfemFyaXRoX3VubWFyc2hhbFxuLy9SZXF1aXJlczogYmlnSW50LCBjYW1sX2ZhaWx3aXRoLCBtbF96X25vcm1hbGl6ZVxuZnVuY3Rpb24gY2FtbF96YXJpdGhfdW5tYXJzaGFsKHJlYWRlciwgc3opIHtcbiAgdmFyIG5lZ2F0ZTtcbiAgc3dpdGNoKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOiBuZWdhdGUgPSB0cnVlOyBicmVhaztcbiAgY2FzZSAwOiBuZWdhdGUgPSBmYWxzZTsgYnJlYWs7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogeiAobWFsZm9ybWVkIGlucHV0KVwiKTtcbiAgfVxuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgdmFyIHggPSBiaWdJbnQoMCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4gLyA0OyBpKyspe1xuICAgIHZhciB5ID0gYmlnSW50KHJlYWRlci5yZWFkOHUoKSk7XG4gICAgeSA9IHkuYWRkKChyZWFkZXIucmVhZDh1KCkpIDw8IDgpO1xuICAgIHkgPSB5LmFkZCgocmVhZGVyLnJlYWQ4dSgpKSA8PCAxNik7XG4gICAgeSA9IHkuYWRkKCgocmVhZGVyLnJlYWQ4dSgpKSA8PCAyNCkgPj4+IDApO1xuICAgIHggPSB5LnNoaWZ0TGVmdChpICogMzIpLmFkZCh4KTtcbiAgfVxuICBpZihuZWdhdGUpIHggPSB4Lm5lZ2F0ZSgpO1xuICBzelswXSA9IGxlbiArIDQ7XG4gIHJldHVybiBtbF96X25vcm1hbGl6ZSh4KVxufVxuIiwiLy8vLy8vLy8vIENPUkVfS0VSTkVMXG5cbi8vUHJvdmlkZXM6IGNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbnZhciBjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdCA9IGNhbWxfYXJyYXlfYmxpdFxuLy9Qcm92aWRlczogY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG52YXIgY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdCA9IGNhbWxfYXJyYXlfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF90aW1lX25zX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF90b19qc19zdHJpbmcsIGNhbWxfanNfdG9fc3RyaW5nXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF90aW1lX25zX2Zvcm1hdCh0aW1lLGZvcm1hdCl7XG4gIHZhciBkID0gbmV3IERhdGUodGltZSAqIDEwMDApO1xuICB2YXIgZm9ybWF0anMgPSBjYW1sX3RvX2pzX3N0cmluZyhmb3JtYXQpO1xuICB2YXIganN0cmluZyA9IGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lKGZvcm1hdGpzLCBkKTtcbiAgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nKGpzdHJpbmcpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19jb21wYWN0aW9uc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfY29tcGFjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19oZWFwX2NodW5rc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfaGVhcF9jaHVua3MgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2tlcm5lbF9nY19oZWFwX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19oZWFwX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWFqb3JfY29sbGVjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfa2VybmVsX2djX21ham9yX2NvbGxlY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9rZXJuZWxfZ2NfbWFqb3JfcGx1c19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY29yZV9rZXJuZWxfZ2NfbWFqb3JfcGx1c19taW5vcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX21ham9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19tYWpvcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX21pbm9yX2NvbGxlY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19taW5vcl9jb2xsZWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19taW5vcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX3Byb21vdGVkX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY19wcm9tb3RlZF93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfa2VybmVsX2djX3RvcF9oZWFwX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2tlcm5lbF9nY190b3BfaGVhcF93b3JkcyAoKSB7IHJldHVybiAwIH1cblxuLy9Qcm92aWRlczogQ29yZV9rZXJuZWxfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrXG5mdW5jdGlvbiBDb3JlX2tlcm5lbF9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2soeCl7XG4gIHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfbWQ1X2ZkXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiwgY2FtbF9tZDVfY2hhbiwgY2FtbF9tbF9jbG9zZV9jaGFubmVsXG5mdW5jdGlvbiBjb3JlX21kNV9mZChmZCl7XG4gICAgdmFyIGljID0gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4oZmQpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYW1sX21kNV9jaGFuKGljLCAtMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY2FtbF9tbF9jbG9zZV9jaGFubmVsKGljKTtcbiAgICB9XG59XG5cbi8vIFByb3ZpZGVzOiBjb3JlX21kNV9kaWdlc3Rfc3ViYmlnc3RyaW5nXG4vLyBSZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX2JsaXRfc3RyaW5nLCBjYW1sX2NyZWF0ZV9ieXRlcywgYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcbmZ1bmN0aW9uIGNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmcoYnVmLCBvZnMsIGxlbiwgcmVzKXtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViKGJ1Ziwgb2ZzLCBieXRlcywgMCwgbGVuKTtcbiAgICB2YXIgcmVzMiA9IGNhbWxfbWQ1X3N0cmluZyhieXRlcywgMCwgbGVuKTtcbiAgICBjYW1sX2JsaXRfc3RyaW5nKHJlczIsIDAsIHJlcywgMCwgMTYpO1xuICAgIHJldHVybiAwO1xufVxuXG4vL0JpZ3N0cmluZ1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZGVzdHJveV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX2Zyb21cbmZ1bmN0aW9uIGJpZ3N0cmluZ19kZXN0cm95X3N0dWIodl9ic3RyKSB7XG4gIGlmICh2X2JzdHIuZGF0YTIgIT0gbnVsbCkge1xuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX2Rlc3Ryb3k6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIH1cblxuICBpZiAodl9ic3RyLmhhc093blByb3BlcnR5KCdfX2lzX2RlYWxsb2NhdGVkJykpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdzdHJpbmdfZGVzdHJveTogYmlnc3RyaW5nIGlzIGFscmVhZHkgZGVhbGxvY2F0ZWRcIik7XG4gIH1cblxuICB2YXIgZGVzdHJveWVkX2RhdGEgPSBuZXcgdl9ic3RyLmRhdGEuX19wcm90b19fLmNvbnN0cnVjdG9yKDApO1xuICB2YXIgZGVzdHJveWVkX2JpZ3N0cmluZyA9XG4gICAgICBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRlc3Ryb3llZF9kYXRhLCBudWxsLCB2X2JzdHIuZGF0YV90eXBlLCB2X2JzdHIua2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdl9ic3RyLmxheW91dCwgWzBdKTtcbiAgZGVzdHJveWVkX2JpZ3N0cmluZy5fX2lzX2RlYWxsb2NhdGVkID0gdHJ1ZTtcblxuICAvLyBNdXRhdGUgdGhlIG9yaWdpbmFsIGJpZ3N0cmluZyBpbi1wbGFjZSwgdG8gc2ltdWxhdGUgd2hhdCB0aGUgQyB2ZXJzaW9uIGRvZXNcbiAgT2JqZWN0LmFzc2lnbih2X2JzdHIsIGRlc3Ryb3llZF9iaWdzdHJpbmcpO1xuXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfcmVhbGxvY1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV9mcm9tLCBiaWdzdHJpbmdfZGVzdHJveV9zdHViXG5mdW5jdGlvbiBiaWdzdHJpbmdfcmVhbGxvYyhiaWdzdHJpbmcsIHNpemUpIHtcbiAgICBpZiAoYmlnc3RyaW5nLmRhdGEyICE9IG51bGwpIHtcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnc3RyaW5nLnVuc2FmZV9kZXN0cm95X2FuZF9yZXNpemU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gICAgfVxuXG4gICAgaWYgKGJpZ3N0cmluZy5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19yZWFsbG9jOiBiaWdzdHJpbmcgaXMgYWxyZWFkeSBkZWFsbG9jYXRlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2RhdGEgPSBuZXcgYmlnc3RyaW5nLmRhdGEuX19wcm90b19fLmNvbnN0cnVjdG9yKHNpemUpO1xuICAgIG5ld19kYXRhLnNldChiaWdzdHJpbmcuZGF0YS5zbGljZSgwLCBzaXplKSk7XG4gICAgdmFyIG5ld19iaWdzdHJpbmcgPVxuICAgICAgICBjYW1sX2JhX2NyZWF0ZV9mcm9tKG5ld19kYXRhLCBudWxsLCBiaWdzdHJpbmcuZGF0YV90eXBlLCBiaWdzdHJpbmcua2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdzdHJpbmcubGF5b3V0LCBbc2l6ZV0pO1xuXG4gICAgYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YihiaWdzdHJpbmcpO1xuXG4gICAgcmV0dXJuIG5ld19iaWdzdHJpbmc7XG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQodikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvcyh4KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NseiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCkge1xuICB2YXIgbiA9IDMyO1xuICB2YXIgeTtcbiAgeSA9IHggPj4xNjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtMTY7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDg7IGlmICh5ICE9IDApIHsgbiA9IG4gLSA4OyB4ID0geTsgfVxuICB5ID0geCA+PiA0OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gNDsgeCA9IHk7IH1cbiAgeSA9IHggPj4gMjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDI7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDE7IGlmICh5ICE9IDApIHJldHVybiBuIC0gMjtcbiAgcmV0dXJuIG4gLSB4O1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9jbHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NselxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfdG9faW50MzJcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfY2x6KHgpIHtcbiAgdmFyIG4gPSA2NDtcbiAgdmFyIHk7XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDMyKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLTMyOyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxNik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0xNjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgOCk7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gODsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgNCk7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gNDsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gMjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMSk7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSByZXR1cm4gbiAtIDI7XG4gIHJldHVybiBuIC0gY2FtbF9pbnQ2NF90b19pbnQzMih4KTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIgY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViKGJhc2UsIGV4cG9uZW50KSB7XG4gIHZhciBvbmUgPSAxO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWV4cG9uZW50PT0wKSB7XG4gICAgbXVsWzFdID0gKG11bFsxXSAqIG11bFszXSkgfCAwO1xuICAgIG11bFsyXSA9IChtdWxbMV0gKiBtdWxbMV0pIHwgMDtcbiAgICBtdWxbM10gPSAobXVsWzJdICogbXVsWzFdKSB8IDA7XG4gICAgcmVzID0gKHJlcyAqIG11bFtleHBvbmVudCAmIDNdKSB8IDA7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCA+PiAyO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWRcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIoYmFzZSwgZXhwb25lbnQpIHtcbiAgdmFyIG9uZSA9IFsyNTUsMSwwLDBdO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWNhbWxfaW50NjRfaXNfemVybyhleHBvbmVudCkpIHtcbiAgICBtdWxbMV0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFszXSk7XG4gICAgbXVsWzJdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzFdLCBtdWxbMV0pO1xuICAgIG11bFszXSA9IGNhbWxfaW50NjRfbXVsKG11bFsyXSwgbXVsWzFdKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X211bChyZXMsIG11bFtleHBvbmVudFsxXSAmIDNdKTtcbiAgICBleHBvbmVudCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoZXhwb25lbnQsIDIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaGFzaF9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9oYXNoXG5mdW5jdGlvbiBCYXNlX2hhc2hfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaCgxLDEsMCxzKVxufVxuLy9Qcm92aWRlczogQmFzZV9oYXNoX2RvdWJsZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoXG5mdW5jdGlvbiBCYXNlX2hhc2hfZG91YmxlKGQpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaCgxLDEsMCxkKTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9hbV90ZXN0aW5nIGNvbnN0XG4vL1dlYWtkZWZcbmZ1bmN0aW9uIEJhc2VfYW1fdGVzdGluZyh4KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG52YXIgY2FtbF9tZDVfYnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHN3aXRjaCAocy50ICYgNikge1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgIHZhciBiID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPCA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5zZXRcIik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY2hlY2sgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jaGVjayh4LCBpKSB7XG4gIGlmKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSE9PXVuZGVmaW5lZCAmJiB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gIT09MClcbiAgICByZXR1cm4gMTtcbiAgZWxzZVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlXG52YXIgY2FtbF9lcGhlX2NyZWF0ZSA9IGNhbWxfd2Vha19jcmVhdGVcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfYmxpdFxudmFyIGNhbWxfZXBoZV9ibGl0X2tleSA9IGNhbWxfd2Vha19ibGl0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0XG52YXIgY2FtbF9lcGhlX2dldF9rZXkgPSBjYW1sX3dlYWtfZ2V0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRfY29weVxudmFyIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkgPSBjYW1sX3dlYWtfZ2V0X2NvcHlcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NoZWNrXG52YXIgY2FtbF9lcGhlX2NoZWNrX2tleSA9IGNhbWxfd2Vha19jaGVja1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCBbMCwgdl0pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCAwKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCl7XG4gIGRzdFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gc3JjW2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gZGF0YTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQ2NFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQgPSBjYW1sX2hhc2hfbWl4X2ludDY0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQgPSBjYW1sX2hhc2hfbWl4X2ludDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0ID0gY2FtbF9oYXNoX21peF9mbG9hdDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nID0gY2FtbF9oYXNoX21peF9zdHJpbmc7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9maW5hbFxuZnVuY3Rpb24gQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWUoc2VlZCkge1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoc2VlZCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9ydW5cbmZ1bmN0aW9uIGRlZmVycmVkX3J1bihmdW5jKSB7XG4gIHZhciBkZWZlcnJlZCA9IHtcbiAgICBwcm9taXNlOiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oZnVuYykgLy8gdGhlIG9jYW1sIHR5cGVzIGRvbid0IGtub3cgdGhpcywgYnV0IGZ1bmMgY2FuIGFjdHVhbGx5IGJlIGFzeW5jIG9yIHN5bmNcbiAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBkZWZlcnJlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgIGRlZmVycmVkLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICBkZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KSxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc0RldGVybWluZWQ6IGZhbHNlLFxuICB9O1xuICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9tYXBcbmZ1bmN0aW9uIGRlZmVycmVkX21hcChkZWZlcnJlZCwgZnVuYykge1xuICB2YXIgbmV3RGVmZXJyZWQgPSB7XG4gICAgcHJvbWlzZTogZGVmZXJyZWQucHJvbWlzZVxuICAgICAgLnRoZW4oZnVuYykgLy8gdGhlIG9jYW1sIHR5cGVzIGRvbid0IGtub3cgdGhpcywgYnV0IGZ1bmMgY2FuIGFjdHVhbGx5IGJlIGFzeW5jIG9yIHN5bmNcbiAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBuZXdEZWZlcnJlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBuZXdEZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgbmV3RGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgIG5ld0RlZmVycmVkLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICBuZXdEZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KSxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc0RldGVybWluZWQ6IGZhbHNlLFxuICB9O1xuICByZXR1cm4gbmV3RGVmZXJyZWQ7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9iaW5kXG5mdW5jdGlvbiBkZWZlcnJlZF9iaW5kKGRlZmVycmVkLCBmdW5jKSB7XG4gIHZhciBuZXdEZWZlcnJlZCA9IHtcbiAgICBwcm9taXNlOiBkZWZlcnJlZC5wcm9taXNlXG4gICAgICAudGhlbihmdW5jKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKGFub3RoZXJEZWZlcnJlZCkge1xuICAgICAgICByZXR1cm4gYW5vdGhlckRlZmVycmVkLnByb21pc2U7XG4gICAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIG5ld0RlZmVycmVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIG5ld0RlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBuZXdEZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgbmV3RGVmZXJyZWQuaXNFcnJvciA9IHRydWU7XG4gICAgICAgIG5ld0RlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLFxuICAgIGlzRXJyb3I6IGZhbHNlLFxuICAgIGlzRGV0ZXJtaW5lZDogZmFsc2UsXG4gIH07XG4gIHJldHVybiBuZXdEZWZlcnJlZDtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX3Vwb25cbmZ1bmN0aW9uIGRlZmVycmVkX3Vwb24oZGVmZXJyZWQsIGZ1bmMpIHtcbiAgZGVmZXJyZWQucHJvbWlzZVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmMoZGVmZXJyZWQudmFsdWUpO1xuICAgIH0pXG4gICAgLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX3Vwb25fZXhuXG5mdW5jdGlvbiBkZWZlcnJlZF91cG9uX2V4bihkZWZlcnJlZCwgZnVuYykge1xuICBkZWZlcnJlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmMoZGVmZXJyZWQudmFsdWUpO1xuICB9KTtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX2lzX2RldGVybWluZWRcbmZ1bmN0aW9uIGRlZmVycmVkX2lzX2RldGVybWluZWQoZGVmZXJyZWQpIHtcbiAgcmV0dXJuIGRlZmVycmVkLmlzRGV0ZXJtaW5lZDtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX3BlZWtcbmZ1bmN0aW9uIGRlZmVycmVkX3BlZWsoZGVmZXJyZWQpIHtcbiAgaWYgKCFkZWZlcnJlZC5pc0RldGVybWluZWQgfHwgZGVmZXJyZWQuaXNFcnJvcikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBbMCwgZGVmZXJyZWQudmFsdWVdO1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfdmFsdWVfZXhuXG5mdW5jdGlvbiBkZWZlcnJlZF92YWx1ZV9leG4oZGVmZXJyZWQpIHtcbiAgaWYgKCFkZWZlcnJlZC5pc0RldGVybWluZWQpIHtcbiAgICB0aHJvdyBFcnJvcihcIkRlZmVycmVkIGhhcyBub3QgcmV0dXJuZWQgeWV0LlwiKTtcbiAgfVxuICBpZiAoZGVmZXJyZWQuaXNFcnJvcikge1xuICAgIHRocm93IGRlZmVycmVkLmVycm9yO1xuICB9XG4gIHJldHVybiBkZWZlcnJlZC52YWx1ZTtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX3JldHVyblxuZnVuY3Rpb24gZGVmZXJyZWRfcmV0dXJuKHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKHZhbHVlKSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaXNFcnJvcjogZmFsc2UsXG4gICAgaXNEZXRlcm1pbmVkOiB0cnVlLFxuICB9O1xufVxuXG4vLyBQcm92aWRlczogZGVmZXJyZWRfY3JlYXRlXG5mdW5jdGlvbiBkZWZlcnJlZF9jcmVhdGUocHJvbWlzZV9jcmVhdG9yKSB7XG4gIHZhciBkZWZlcnJlZCA9IHtcbiAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcHJvbWlzZV9jcmVhdG9yKHJlc29sdmUpO1xuICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZGVmZXJyZWQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVmZXJyZWQuaXNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkZWZlcnJlZC5lcnJvciA9IGVycjtcbiAgICAgICAgZGVmZXJyZWQuaXNFcnJvciA9IHRydWU7XG4gICAgICAgIGRlZmVycmVkLmlzRGV0ZXJtaW5lZCA9IHRydWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLFxuICAgIGlzRXJyb3I6IGZhbHNlLFxuICAgIGlzRGV0ZXJtaW5lZDogZmFsc2UsXG4gIH07XG4gIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLy8gUHJvdmlkZXM6IGRlZmVycmVkX3RvX3Byb21pc2VcbmZ1bmN0aW9uIGRlZmVycmVkX3RvX3Byb21pc2UoZGVmZXJyZWQpIHtcbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8vIFByb3ZpZGVzOiBkZWZlcnJlZF9vZl9wcm9taXNlXG5mdW5jdGlvbiBkZWZlcnJlZF9vZl9wcm9taXNlKHByb21pc2UpIHtcbiAgdmFyIGRlZmVycmVkID0ge1xuICAgIHByb21pc2U6IHByb21pc2VcbiAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBkZWZlcnJlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgIGRlZmVycmVkLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICBkZWZlcnJlZC5pc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KSxcbiAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICBpc0RldGVybWluZWQ6IGZhbHNlLFxuICB9O1xuICByZXR1cm4gZGVmZXJyZWQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBIdWdvIEhldXphcmRcbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIFNoYWNoYXIgSXR6aGFreVxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL2Jsb2IvNC4wNy9vdGhlcmxpYnMvc3RyL3N0cnN0dWJzLmNcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2NvcS9qc2NvcS9ibG9iL3Y4LjExL2NvcS1qcy9qc19zdHViL3N0ci5qc1xuXG4vL1Byb3ZpZGVzOiByZV9tYXRjaFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0XG5cbnZhciByZV9tYXRjaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZV93b3JkX2xldHRlcnMgPSBbXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHgwMC0weDFGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHhGRiwgMHgwMywgICAgICAgLyogMHgyMC0weDNGOiBkaWdpdHMgMC05ICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHg4NywgICAgICAgLyogMHg0MC0weDVGOiBBIHRvIFosIF8gKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDA3LCAgICAgICAvKiAweDYwLTB4N0Y6IGEgdG8geiAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4ODAtMHg5Rjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4QTAtMHhCRjogbm9uZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYsICAgICAgIC8qIDB4QzAtMHhERjogTGF0aW4tMSBhY2NlbnRlZCB1cHBlcmNhc2UgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGICAgICAgICAvKiAweEUwLTB4RkY6IExhdGluLTEgYWNjZW50ZWQgbG93ZXJjYXNlICovXG4gIF07XG5cbiAgdmFyIG9wY29kZXMgPSB7XG4gICAgQ0hBUjogMCwgQ0hBUk5PUk06IDEsIFNUUklORzogMiwgU1RSSU5HTk9STTogMywgQ0hBUkNMQVNTOiA0LFxuICAgIEJPTDogNSwgRU9MOiA2LCBXT1JEQk9VTkRBUlk6IDcsXG4gICAgQkVHR1JPVVA6IDgsIEVOREdST1VQOiA5LCBSRUZHUk9VUDogMTAsXG4gICAgQUNDRVBUOiAxMSxcbiAgICBTSU1QTEVPUFQ6IDEyLCBTSU1QTEVTVEFSOiAxMywgU0lNUExFUExVUzogMTQsXG4gICAgR09UTzogMTUsIFBVU0hCQUNLOiAxNiwgU0VUTUFSSzogMTcsXG4gICAgQ0hFQ0tQUk9HUkVTUzogMThcbiAgfTtcblxuICBmdW5jdGlvbiBpc193b3JkX2xldHRlcihjKSB7XG4gICAgcmV0dXJuIChyZV93b3JkX2xldHRlcnNbICAoYyA+PiAzKV0gPj4gKGMgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fYml0c2V0KHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9zdHJpbmdfZ2V0KHMsKGkgPj4gMykpID4+IChpICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlX21hdGNoX2ltcGwocmUsIHMsIHBvcywgcGFydGlhbCkge1xuXG4gICAgdmFyIHByb2cgICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMV0pLFxuICAgICAgICBjcG9vbCAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzJdKSxcbiAgICAgICAgbm9ybXRhYmxlICAgICA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVbM10pLFxuICAgICAgICBudW1ncm91cHMgICAgID0gcmVbNF0gfCAwLFxuICAgICAgICBudW1yZWdpc3RlcnMgID0gcmVbNV0gfCAwLFxuICAgICAgICBzdGFydGNoYXJzICAgID0gcmVbNl0gfCAwO1xuXG4gICAgdmFyIHMgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzKTtcblxuICAgIHZhciBwYyA9IDAsXG4gICAgICAgIHF1aXQgPSBmYWxzZSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gbmV3IEFycmF5KG51bWdyb3VwcyksXG4gICAgICAgIHJlX3JlZ2lzdGVyID0gbmV3IEFycmF5KG51bXJlZ2lzdGVycyk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGdyb3Vwc1tpXSA9IHtzdGFydDogLTEsIGVuZDotMX1cbiAgICB9XG4gICAgZ3JvdXBzWzBdLnN0YXJ0ID0gcG9zO1xuXG4gICAgdmFyIGJhY2t0cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0udW5kbykge1xuICAgICAgICAgIGl0ZW0udW5kby5vYmpbaXRlbS51bmRvLnByb3BdID0gaXRlbS51bmRvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaXRlbS5wb3MpIHtcbiAgICAgICAgICBwYyA9IGl0ZW0ucG9zLnBjO1xuICAgICAgICAgIHBvcyA9IGl0ZW0ucG9zLnR4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1aXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHsgc3RhY2sucHVzaChpdGVtKTsgfTtcblxuICAgIHZhciBhY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cHNbMF0uZW5kID0gcG9zO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSgxICsgZ3JvdXBzLmxlbmd0aCoyKTtcbiAgICAgIHJlc3VsdFswXSA9IDA7IC8vIHRhZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBnID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZihnLnN0YXJ0IDwgMCB8fCBnLmVuZCA8IDApIHtcbiAgICAgICAgICBnLnN0YXJ0ID0gZy5lbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbMippICsgMSBdID0gZy5zdGFydDtcbiAgICAgICAgcmVzdWx0WzIqaSArIDEgKyAxIF0gPSBnLmVuZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIHZhciBwcmVmaXhfbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZihwYXJ0aWFsKSByZXR1cm4gYWNjZXB0ICgpO1xuICAgICAgZWxzZSBiYWNrdHJhY2sgKCk7XG4gICAgfVxuXG4gICAgLyogTWFpbiBERkEgaW50ZXJwcmV0ZXIgbG9vcCAqL1xuICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgdmFyIG9wID0gcHJvZ1twY10gJiAweGZmLFxuICAgICAgICAgIHNhcmcgPSBwcm9nW3BjXSA+PiA4LFxuICAgICAgICAgIHVhcmcgPSBzYXJnICYgMHhmZixcbiAgICAgICAgICBjID0gc1twb3NdLFxuICAgICAgICAgIGdyb3VwO1xuXG4gICAgICBwYysrO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUjpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoYyA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJOT1JNOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklORzpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChjID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HTk9STTpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJDTEFTUzpcbiAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1Byb3ZpZGVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0XG52YXIgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dCBcbi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnJcbnZhciBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyXG5cbi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9iZWZvcmVfdGVzdFxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciwgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dFxuZnVuY3Rpb24gZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2JlZm9yZV90ZXN0ICh2b3V0cHV0LCB2c3Rkb3V0LCB2c3RkZXJyKXtcbiAgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciA9IGNhbWxfbWxfY2hhbm5lbHNbdnN0ZGVycl07XG4gIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQgPSBjYW1sX21sX2NoYW5uZWxzW3ZzdGRvdXRdO1xuICB2YXIgb3V0cHV0ID0gY2FtbF9tbF9jaGFubmVsc1t2b3V0cHV0XTtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3Rkb3V0XSA9IG91dHB1dDtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3RkZXJyXSA9IG91dHB1dDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9hZnRlcl90ZXN0XG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyLCBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0XG5mdW5jdGlvbiBleHBlY3RfdGVzdF9jb2xsZWN0b3JfYWZ0ZXJfdGVzdCAodnN0ZG91dCwgdnN0ZGVycil7XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZG91dF0gPSBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0O1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRlcnJdID0gZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVycjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF9vdXRfY2hhbm5lbF9wb3NfZmRcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfb3V0X2NoYW5uZWxfcG9zX2ZkKGNoYW4pe1xuICB2YXIgaW5mbyA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbl07XG4gIHJldHVybiBpbmZvLm9mZnNldFxufVxuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kKGxvYyxzaGFwZSkge1xuICBmdW5jdGlvbiB1bmRlZl9tb2R1bGUgKF94KSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlLCBsb2MpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AgKHNoYXBlLHN0cnVjdCxpZHgpe1xuICAgIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHN3aXRjaChzaGFwZSl7XG4gICAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgICBzdHJ1Y3RbaWR4XT17ZnVuOnVuZGVmX21vZHVsZX07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgICBzdHJ1Y3RbaWR4XT1bMjQ2LCB1bmRlZl9tb2R1bGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgICBzdHJ1Y3RbaWR4XT1bXTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gWzBdO1xuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxzdHJ1Y3RbaWR4XSxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAxOi8vVmFsdWVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBzaGFwZVsxXTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVzID0gW107XG4gIGxvb3Aoc2hhcGUscmVzLDApO1xuICByZXR1cm4gcmVzWzBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZSxyZWFsLHgpIHtcbiAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgIHN3aXRjaChzaGFwZSl7XG4gICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICBjYXNlIDE6Ly9sYXp5XG4gICAgY2FzZSAyOi8vY2xhc3NcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF91cGRhdGVfZHVtbXkocmVhbCx4KTtcbiAgICB9XG4gIGVsc2VcbiAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlWzFdW2ldLHJlYWxbaV0seFtpXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vY2FzZSAxOi8vVmFsdWVcbiAgICBkZWZhdWx0OlxuICAgIH07XG4gIHJldHVybiAwXG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX2JsaXRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX2JsaXRfdG9fYnl0ZXMoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldChkc3QsIGRzdF9vZmYgKyBpLCBjYW1sX2JhX2dldF8xKHNyYywgc3JjX29mZiArIGkpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF90b19iaWdzdHJpbmcoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2FtbF9iYV9zZXRfMShkc3QsIGRzdF9vZmYgKyBpLCBjYW1sX2JhX2dldF8xKHNyYywgc3JjX29mZiArIGkpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2V0XzEsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX2JsaXRfZnJvbV9ieXRlcyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjYW1sX2JhX3NldF8xKGRzdCwgZHN0X29mZiArIGksIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQoc3JjLCBzcmNfb2ZmICsgaSkpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfaW50X2NvbXBhcmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmcoYmExLCBiYTFfb2ZmLCBiYTIsIGJhMl9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBjYW1sX2ludF9jb21wYXJlKGNhbWxfYmFfZ2V0XzEoYmExLCBiYTFfb2ZmICsgaSksIGNhbWxfYmFfZ2V0XzEoYmEyLCBiYTJfb2ZmICsgaSkpO1xuICAgIGlmIChjICE9IDApIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmcoYmEsIGJhX29mZiwgc3RyLCBzdHJfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gY2FtbF9pbnRfY29tcGFyZShjYW1sX2JhX2dldF8xKGJhLCBiYV9vZmYgKyBpKSwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzdHIsIHN0cl9vZmYgKyBpKSk7XG4gICAgaWYgKGMgIT0gMCkgcmV0dXJuIGNcbiAgfVxuICByZXR1cm4gMDtcbn1cbiIsIi8vLy8vLy8vLyBUSU1FX05PV1xuXG4vL1Byb3ZpZGVzOiB0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm9cbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX2ludDY0X29mX2ludDMyXG52YXIgbXNfdG9fbmFubyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMTAwMCoxMDAwKTtcbmZ1bmN0aW9uIHRpbWVfbm93X25hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2hfb3JfemVybygpe1xuICAgIHZhciBtcyA9IERhdGUubm93KCk7XG4gICAgLy8gbXVsdGlwbGUgYnkgdHdvIC0gaW50NjMgaW50ZWdlcnMgYXJlIHNoaWZ0ZWQgdG8gdGhlIGxlZnRcbiAgICB2YXIgbXNfaTYzID0gY2FtbF9pbnQ2NF9vZl9mbG9hdChtcyoyKTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9tdWwobXNfaTYzLG1zX3RvX25hbm8pO1xufVxuIl19
